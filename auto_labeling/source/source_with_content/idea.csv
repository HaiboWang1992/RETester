html_url,priority,type,state,subsystem,created_date,has_input_program,input property,symptom,refactoring_type,commit_html_url,root_cause,content_text
https://youtrack.jetbrains.com/issue/IDEA-340915/Bug-Extract-local-variables-causes-syntax-errors,Normal,Bug,Fixed,Java. Refactorings,20 Mar,1,nan,compile error,extract local variable,https://github.com/JetBrains/intellij-community/commit/6583f8ee65b0a9bf9c4eb224b1ecc84a06f3ba0a,overly weak preconditions,"Bug： Extract local variables causes syntax errors
What steps will reproduce the issue?
When extracting the variable for the super keyword in c()
    class A {
        public void £() {
        }
    }

    class B extends A {
        public void c() {
            super.£(); //select `super` and extract variable
        }
    }

Javathe refactoring result is as follows， there exists a syntax error.

What is the expected result?
The reconstruction of super keyword extraction variables should not be supported.
"
https://youtrack.jetbrains.com/issue/IDEA-332489/Inlining-refactoring-operation-leads-to-naming-conflicts,Normal,Bug,Fixed,Java. Refactorings,18 Mar,1,inner class,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/21617c81371b0f1573a0ccb54aa70dd205982687;https://github.com/JetBrains/intellij-community/commit/b8b69757376b839967435cb9a92a8853f927906d,overly weak preconditions,"Inlining refactoring operation leads to naming conflicts
What steps will reproduce the issue?
1.  Perform an inline refactoring operation on the 'foo()' method in the test case.
public class TestCase{
	public void main() {
		class T {
			public T() {}
		}
		/*]*/foo();/*[*/
	}
	
	public void foo() {
		class T {
			T t;
			public T() {}
		}
	}
}

 2. Result of the inline refactoring execution

3. The result indicates a naming conflict between the inner class 'T' in the 'foo()' method and the inner class 'T' in the 'main' method. Therefore, when performing an inline refactoring, it is important to check for naming conflicts between identifiers within the method body and the target method body.
What happens instead?
Please attach the IDE logs to the issue. You can get them by selecting Collect Logs and Diagnostic Data from the Help menu.
If possible, please attach a code sample, screenshot, or screencast that illustrates the problem.
To make the issue visible only to the JetBrains team, you can set its visibility to the jetbrains-team group. With the exception of images, all attachments are visible only to the JetBrains team by default.
If you can’t provide IDE logs, please provide information about the IDE version and the OS you are using. You can copy these details from the About dialog in the Help or App menu.
If you are experiencing performance issues, please also attach the relevant snapshots.
"
https://youtrack.jetbrains.com/issue/IDEA-195246/Inline-this-variable-only-and-keep-this-reference-Cannot-perform-refactoring-variable-is-accessed-for-writing,Normal,Bug,Fixed,Java. Refactorings,11 Mar,1,nan,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/8051e35d6dd3286700be0ac2f7e5f4aef8b9bc40,overly weak preconditions,"Inline this variable only and keep this reference: Cannot perform refactoring, variable is accessed for writing
String bla = ""bla"";

        System.out.println(bla);
        bla = ""bla3"";
        System.out.println(bla);
        System.out.println(bla);
        bla = ""bla4"";
        System.out.println(bla);  1. Use Ctrl-Alt-N (inline) on the second assignment.What is the expected result?Don't allow me to choose something that won't work.What happens instead?IntelliJ tells me after the fact that this refactoring doesn't apply to this situation. IntelliJ IDEA 2018.2 EAP (Ultimate Edition)Build #IU-182.3569.1, built on July 3, 2018IntelliJ IDEA EAP UserExpiration date: August 2, 2018JRE: 1.8.0_152-release-1226-b7 amd64JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.oWindows 10 10.0
"
https://youtrack.jetbrains.com/issue/IDEA-343148/Introduce-constant-causes-exception-for-implicit-classes,Normal,Bug,Fixed,Java. Refactorings,26 Jan,1,implicit class,exception,Introduce constant,https://github.com/JetBrains/intellij-community/commit/d72e824939e21dded0ec53be8fd0cd3272a10692;https://github.com/JetBrains/intellij-community/commit/ab3056d33d4280b304433bcdcb9ab8fe8a7b68ab;https://github.com/JetBrains/intellij-community/commit/ff0b78a15b95d566a179f26a90878ea1e4d7749f,ast rewrite issue,"`Introduce constant` causes exception for implicit classes
void main() {

    int a = 1<caret>;

    System.out.println(a);
}

JavaApply: ctrl+shift+c
Result: exception
"
https://youtrack.jetbrains.com/issue/IDEA-321620/Move-Static-Members-produces-red-code-when-static-import-is-present,Normal,Bug,Fixed,Java. Refactorings,17 Jan,1,nan,compile error,Move Static Members,https://github.com/JetBrains/intellij-community/commit/d62f8988b62c07bdc833671a38c193a8230bf2a1;https://github.com/JetBrains/intellij-community/commit/8e3d29b3f9e373d2b9a196fd922e3e6555fbf9f2,ast rewrite issue,"Move Static Members produces red code when static import is present
On the following code, move the method x() to class Y using the Move Members refactoring. Visibility should be ""Escalate"".
package one;

import static one.X.Y.*;

class X {
    void run() {
        x();
        y();
    }
    private static void x() {}
    
    static class Y {
        static void y() {}
    }
}

 Result:

package one;

import static one.X.Y.*;

class X {
    void run() {
        x(); // red code here
        y();
    }

    static class Y {
        static void y() {}

        private static void x() {}
    }
}

 The resulting code does not compile, because x() is private and it is not possible to statically import private members. Move members should either qualify the call with the class name or preferably escalate the visibility of x() to package-local.
"
https://youtrack.jetbrains.com/issue/IDEA-336815/Inline-variable-misleading-error-message-when-compile-errors-are-present,Normal,Bug,Fixed,Java. Refactorings,17 Jan,1,nan,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/fd00898d32a86f01ab267553eed33f7241df7974;https://github.com/JetBrains/intellij-community/commit/c6fbff80c0704b0b4573de7b6411110d29307284,flow analysis issue,"""Inline variable"" misleading error message when compile-errors are present
(follow up on IDEA-191147)
Try to inline the variable inlineMe:
class Scratch
{
    public static void main(String[] args)
    {
        int inlineMe = 3; // inline
        int dd = 4 + inlineMe;
        
        ""Error"".
    }
}

JavaExpected:
Error message about that the refactoring cannot be used because there is a compile error
Actual:
Error message ""Variable is never used before modification"" is shown, which is misleading
"
https://youtrack.jetbrains.com/issue/IDEA-300134/Introduce-Field-in-an-interface-should-probably-be-disabled,Normal,Bug,Fixed,Java. Refactorings,17 Jan,1,nan,compile error,Introduce Field,https://github.com/JetBrains/intellij-community/commit/72faf00daff065f2a205c4585980a8740e7d54ff,overly weak preconditions,"""Introduce Field"" in an interface should probably be disabled
Example:
interface Date {

  default int getMonth() {
    int result = 0;
    return result;
  }
}

JavaIt's possible to invoke ""Introduce field"" on the result variable. A private field is then generated, which naturally does not compile. It gets worse when the initialization is put in the current method or the constructor by the refactoring.
Trying to introduce a field for the 0 literal is not allowed as expected. However, a constant is a kind of field. Thus, it may be more user-friendly to delegate ""Introduce Field"" to ""Introduce Constant"" when inside an interface.
"
https://youtrack.jetbrains.com/issue/IDEA-198440/Introducing-field-of-local-class-type-should-probably-be-disallowed,Normal,Bug,Fixed,Java. Refactorings,17 Jan,1,local class,compile error,introduce field,https://github.com/JetBrains/intellij-community/commit/b2cf7e2e4ba97483ed8ff3c8145da778a04a361a;https://github.com/JetBrains/intellij-community/commit/44373573e7cfb169fb261b103b94de0402e1cb01,overly weak preconditions,"Introducing field of local class type should probably be disallowed
For example introduce a field from the new Local() expression in the following code:class K {
    void m() {
        class Local {
            void locally() {}
        }
        new Local().locally();
    }
} result something like (depending on where the field is initialized):class K {
    private final Local local;

    public K() {
        local = new Local();
    }

    void m() {
        class Local {
            void locally() {}
        }
        local.locally();
    }
} which does not compile.
"
https://youtrack.jetbrains.com/issue/IDEA-340087/Introduce-variable-throws-exception-in-implicit-classes,Normal,Bug,Fixed,Java. Refactorings,17 Jan,1,implicit class,exception,introduce variable,https://github.com/JetBrains/intellij-community/commit/7ed93305c1e2eebc2b2ba78c27c842d95115c105,ast rewrite issue,"Introduce variable throws exception in implicit classes
Call introduce variable:
class Nested {
}

void main() {
    System.out.println(<selection>Nested.class</selection>);
}

Javacom.intellij.util.IncorrectOperationException: Incorrect type 'java.lang.Class<null.Nested>' (JDK_X)
	at com.intellij.psi.impl.PsiJavaParserFacadeImpl.newException(PsiJavaParserFacadeImpl.java:388)
	at com.intellij.psi.impl.PsiJavaParserFacadeImpl.createTypeElementFromText(PsiJavaParserFacadeImpl.java:231)
	at com.intellij.psi.impl.source.tree.JavaTreeGenerator.generateTreeFor(JavaTreeGenerator.java:120)
	at com.intellij.psi.impl.source.tree.ChangeUtil.lambda$generateTreeElement$2(ChangeUtil.java:133)


 
"
https://youtrack.jetbrains.com/issue/IDEA-338428/Inline-pattern-variable-doesnt-work-when-its-located-in-nested-condition,Normal,Bug,Fixed,Java. Refactorings,11 Jan,1,nested condition,exception,inline variable,https://github.com/JetBrains/intellij-community/commit/fc4f8118d2abc4efb20d7668d7879991d3b83d3d,flow analysis issue,"Inline pattern variable doesn't work when it's located in nested condition
Code:
class Test {
  void test(Object obj) {
    if (Math.random() > 0.5 || (obj instanceof String <caret>s && s.isEmpty())) {
      System.out.println();
    }
  }
}

JavaExpected:
class Test {
  void test(Object obj) {
    if (Math.random() > 0.5 || (obj instanceof String && ((String) obj).isEmpty())) {
      System.out.println();
    }
  }
}

JavaActual:
java.lang.NullPointerException
	at java.base/java.util.Objects.requireNonNull(Objects.java:208)
	at java.base/java.util.ImmutableCollections$List12.<init>(ImmutableCollections.java:556)
	at java.base/java.util.List.of(List.java:812)
	at com.intellij.refactoring.inline.InlineLocalHandler.doInline(InlineLocalHandler.java:111)
	at com.intellij.refactoring.inline.InlineLocalHandler.perform(InlineLocalHandler.java:102)
	at com.intellij.refactoring.inline.InlineLocalHandler.lambda$inlineElement$0(InlineLocalHandler.java:74)

Java stack trace
"
https://youtrack.jetbrains.com/issue/IDEA-327261/Inline-method-doesnt-work-in-unnamed-class,Normal,Bug,Fixed,Java. Refactorings,4 Dec 2023,1,unnamed class,exception,inline method,https://github.com/JetBrains/intellij-community/commit/7ce61422f019746e8a72db1102472e4657a8334f,ast rewrite issue,"Inline method doesn't work in unnamed class
Inline `before` method:
void before() {
}

void after() {
    before();
}

 Nothing happens after that.
exception:
java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
	at com.intellij.refactoring.inline.InlineMethodProcessor.declareThis(InlineMethodProcessor.java:801)
	at com.intellij.refactoring.inline.InlineMethodProcessor.prepareBlock(InlineMethodProcessor.java:786)
	at com.intellij.refactoring.inline.InlineMethodProcessor.inlineMethodCall(InlineMethodProcessor.java:652)
	at com.intellij.refactoring.inline.InlineMethodProcessor.doRefactoring(InlineMethodProcessor.java:527)
	at com.intellij.refactoring.inline.InlineMethodProcessor.performRefactoring(InlineMethodProcessor.java:413)
	at com.intellij.refactoring.BaseRefactoringProcessor.lambda$doRefactoring$9(BaseRefactoringProcessor.java:524)
	at com.intellij.openapi.application.impl.ApplicationImpl.lambda$runEdtProgressWriteAction$6(ApplicationImpl.java:950)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$2(CoreProgressManager.java:186)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$executeProcessUnderProgress$13(CoreProgressManager.java:604)
	at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:679)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computeUnderProgress(CoreProgressManager.java:635)
	at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:603)
	at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:61)
	at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:173)
	at com.intellij.openapi.progress.util.PotemkinProgress.runInSwingThread(PotemkinProgress.java:150)
	at com.intellij.openapi.application.impl.ApplicationImpl.lambda$runEdtProgressWriteAction$7(ApplicationImpl.java:950)
	at com.intellij.openapi.application.impl.ApplicationImpl.runWriteActionWithClass(ApplicationImpl.java:958)
	at com.intellij.openapi.application.impl.ApplicationImpl.runEdtProgressWriteAction(ApplicationImpl.java:948)
	at com.intellij.openapi.application.impl.ApplicationImpl.runWriteActionWithNonCancellableProgressInDispatchThread(ApplicationImpl.java:931)
	at com.intellij.refactoring.BaseRefactoringProcessor.doRefactoring(BaseRefactoringProcessor.java:523)
	at com.intellij.refactoring.BaseRefactoringProcessor.lambda$execute$2(BaseRefactoringProcessor.java:329)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:222)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:174)
	at com.intellij.openapi.command.impl.CoreCommandProcessor.executeCommand(CoreCommandProcessor.java:164)
	at com.intellij.refactoring.BaseRefactoringProcessor.execute(BaseRefactoringProcessor.java:327)
	at com.intellij.refactoring.BaseRefactoringProcessor.doRun(BaseRefactoringProcessor.java:248)
	at com.intellij.refactoring.BaseRefactoringProcessor.lambda$run$12(BaseRefactoringProcessor.java:594)
	at com.intellij.refactoring.BaseRefactoringProcessor.run(BaseRefactoringProcessor.java:610)
	at com.intellij.refactoring.ui.RefactoringDialog.invokeRefactoring(RefactoringDialog.java:276)
	at com.intellij.refactoring.inline.InlineMethodDialog.doAction(InlineMethodDialog.java:76)
	at com.intellij.refactoring.ui.RefactoringDialog.doRefactorAction(RefactoringDialog.java:145)
	at com.intellij.refactoring.ui.RefactoringDialog$RefactorAction.actionPerformed(RefactoringDialog.java:251)
	at java.desktop/javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:1972)
	at com.intellij.openapi.ui.DialogWrapper$3.fireActionPerformed(DialogWrapper.java:792)
	at java.desktop/javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2313)
	at java.desktop/javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:405)
	at java.desktop/javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:262)
	at java.desktop/javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:279)
	at java.desktop/java.awt.Component.processMouseEvent(Component.java:6657)
	at java.desktop/javax.swing.JComponent.processMouseEvent(JComponent.java:3385)
	at java.desktop/java.awt.Component.processEvent(Component.java:6422)
	at java.desktop/java.awt.Container.processEvent(Container.java:2266)
	at java.desktop/java.awt.Component.dispatchEventImpl(Component.java:5027)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2324)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4969)
	at java.desktop/java.awt.LightweightDispatcher.processMouseEvent(Container.java:4583)
	at java.desktop/java.awt.LightweightDispatcher.dispatchEvent(Container.java:4524)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2310)
	at java.desktop/java.awt.Window.dispatchEventImpl(Window.java:2808)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4855)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:794)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:739)
	at java.desktop/java.awt.EventQueue$3.run(EventQueue.java:733)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:97)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:766)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:764)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:86)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:763)
	at com.intellij.ide.IdeEventQueue.defaultDispatchEvent(IdeEventQueue.kt:683)
	at com.intellij.ide.IdeEventQueue.dispatchMouseEvent(IdeEventQueue.kt:631)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.kt:586)
	at com.intellij.ide.IdeEventQueue.access$_dispatchEvent(IdeEventQueue.kt:69)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:362)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:361)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:787)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:361)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:356)
	at com.intellij.ide.IdeEventQueueKt.performActivity$lambda$1(IdeEventQueue.kt:989)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:105)
	at com.intellij.ide.IdeEventQueueKt.performActivity(IdeEventQueue.kt:989)
	at com.intellij.ide.IdeEventQueue.dispatchEvent$lambda$7(IdeEventQueue.kt:356)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:838)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.kt:398)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:207)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:128)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:121)
	at java.desktop/java.awt.WaitDispatchSupport$2.run(WaitDispatchSupport.java:191)
	at java.desktop/java.awt.WaitDispatchSupport$4.run(WaitDispatchSupport.java:236)
	at java.desktop/java.awt.WaitDispatchSupport$4.run(WaitDispatchSupport.java:234)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:318)
	at java.desktop/java.awt.WaitDispatchSupport.enter(WaitDispatchSupport.java:234)
	at java.desktop/java.awt.Dialog.lambda$show$2(Dialog.java:1081)
	at java.desktop/sun.awt.SunToolkit.performOnMainThreadIfNeeded(SunToolkit.java:2164)
	at java.desktop/java.awt.Dialog.show(Dialog.java:1041)
	at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl$MyDialog.show(DialogWrapperPeerImpl.java:740)
	at com.intellij.openapi.ui.impl.DialogWrapperPeerImpl.show(DialogWrapperPeerImpl.java:465)
	at com.intellij.openapi.ui.DialogWrapper.doShow(DialogWrapper.java:1723)
	at com.intellij.openapi.ui.DialogWrapper.show(DialogWrapper.java:1677)
	at com.intellij.refactoring.ui.RefactoringDialog.show(RefactoringDialog.java:106)
	at com.intellij.refactoring.inline.InlineMethodHandler.performInline(InlineMethodHandler.java:156)
	at com.intellij.refactoring.inline.InlineMethodHandler.inlineElement(InlineMethodHandler.java:41)
	at com.intellij.refactoring.inline.InlineRefactoringActionHandler.invoke(InlineRefactoringActionHandler.java:58)
	at com.intellij.refactoring.actions.BaseRefactoringAction.performRefactoringAction(BaseRefactoringAction.java:161)
	at com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(BaseRefactoringAction.java:110)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.doPerformActionOrShowPopup(ActionUtil.java:340)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.lambda$performActionDumbAwareWithCallbacks$4(ActionUtil.java:314)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performDumbAwareWithCallbacks(ActionUtil.java:363)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.performActionDumbAwareWithCallbacks(ActionUtil.java:314)
	at com.intellij.openapi.actionSystem.ex.ActionUtil.invokeAction(ActionUtil.java:539)
	at com.intellij.ui.popup.ActionPopupStep.performAction(ActionPopupStep.java:266)
	at com.intellij.ui.popup.ActionPopupStep.lambda$onChosen$3(ActionPopupStep.java:243)
	at com.intellij.ui.popup.AbstractPopup.lambda$dispose$18(AbstractPopup.java:1727)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.lambda$doWhenFocusSettlesDown$3(FocusManagerImpl.java:169)
	at com.intellij.util.ui.EdtInvocationManager.invokeLaterIfNeeded(EdtInvocationManager.java:33)
	at com.intellij.ide.IdeEventQueue.ifFocusEventsInTheQueue(IdeEventQueue.kt:214)
	at com.intellij.ide.IdeEventQueue.executeWhenAllFocusEventsLeftTheQueue(IdeEventQueue.kt:180)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:165)
	at com.intellij.openapi.wm.impl.FocusManagerImpl.doWhenFocusSettlesDown(FocusManagerImpl.java:159)
	at com.intellij.ui.popup.AbstractPopup.dispose(AbstractPopup.java:1725)
	at com.intellij.ui.popup.WizardPopup.dispose(WizardPopup.java:165)
	at com.intellij.ui.popup.list.ListPopupImpl.dispose(ListPopupImpl.java:391)
	at com.intellij.ui.popup.PopupFactoryImpl$ActionGroupPopup.dispose(PopupFactoryImpl.java:293)
	at com.intellij.openapi.util.ObjectTree.runWithTrace(ObjectTree.java:130)
	at com.intellij.openapi.util.ObjectTree.executeAll(ObjectTree.java:162)
	at com.intellij.openapi.util.Disposer.dispose(Disposer.java:262)
	at com.intellij.openapi.util.Disposer.dispose(Disposer.java:250)
	at com.intellij.ui.popup.WizardPopup.disposeAllParents(WizardPopup.java:273)
	at com.intellij.ui.popup.list.ListPopupImpl.disposePopup(ListPopupImpl.java:493)
	at com.intellij.ui.popup.list.ListPopupImpl.handleNextStep(ListPopupImpl.java:520)
	at com.intellij.ui.popup.list.ListPopupImpl._handleSelect(ListPopupImpl.java:480)
	at com.intellij.ui.popup.list.ListPopupImpl.handleSelect(ListPopupImpl.java:426)
	at com.intellij.ui.popup.PopupFactoryImpl$ActionGroupPopup.handleSelect(PopupFactoryImpl.java:305)
	at com.intellij.ui.popup.list.ListPopupImpl$1.actionPerformed(ListPopupImpl.java:278)
	at com.intellij.ui.popup.WizardPopup.proceedKeyEvent(WizardPopup.java:400)
	at com.intellij.ui.popup.WizardPopup.dispatch(WizardPopup.java:372)
	at com.intellij.ui.popup.PopupDispatcher.dispatchKeyEvent(PopupDispatcher.java:115)
	at com.intellij.ui.popup.PopupDispatcher.dispatch(PopupDispatcher.java:157)
	at com.intellij.ide.IdePopupManager.dispatch(IdePopupManager.java:111)
	at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.kt:563)
	at com.intellij.ide.IdeEventQueue.access$_dispatchEvent(IdeEventQueue.kt:69)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:362)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1$1.compute(IdeEventQueue.kt:361)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computePrioritized(CoreProgressManager.java:787)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:361)
	at com.intellij.ide.IdeEventQueue$dispatchEvent$processEventRunnable$1$1.invoke(IdeEventQueue.kt:356)
	at com.intellij.ide.IdeEventQueueKt.performActivity$lambda$1(IdeEventQueue.kt:989)
	at com.intellij.openapi.application.TransactionGuardImpl.performActivity(TransactionGuardImpl.java:113)
	at com.intellij.ide.IdeEventQueueKt.performActivity(IdeEventQueue.kt:989)
	at com.intellij.ide.IdeEventQueue.dispatchEvent$lambda$7(IdeEventQueue.kt:356)
	at com.intellij.openapi.application.impl.ApplicationImpl.runIntendedWriteActionOnCurrentThread(ApplicationImpl.java:838)
	at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.kt:398)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:207)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:128)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:117)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:105)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:92)

 
"
https://youtrack.jetbrains.com/issue/IDEA-331198/Exception-upon-Extract-method-on-String-template,Normal,Bug,Fixed,Java. Refactorings,4 Dec 2023,1,special string,exception,extract method,https://github.com/JetBrains/intellij-community/commit/34afca4ec6471def2a8c2e62e975a295e86915bc,flow analysis issue,"Exception upon ""Extract method"" on String template
Code sample: #
public class DummyClass {
    String str1;

    public String getStr1() {return this.str1;}

    public void setStr1(final String str1) {this.str1 = str1;}

    public void extraStr1(){
       String output = STR.""ABC \{str1}"";
    }
}

 Steps: #

put carret on STR
call ""Extract method"" refactoring
Select STR.""ABC \{str1}""

Expected: #
expression moved to separate method
Actual: #
java.lang.IllegalArgumentException: Required value was null.
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer.findFlowRange(CodeFragmentAnalyzer.kt:53)
	at com.intellij.refactoring.extractMethod.newImpl.CodeFragmentAnalyzer.<init>(CodeFragmentAnalyzer.kt:36)
	at com.intellij.refactoring.extractMethod.newImpl.ExtractMethodAnalyzerKt.findExtractOptions(ExtractMethodAnalyzer.kt:37)
	at com.intellij.refactoring.extractMethod.newImpl.ExtractMethodPipeline.findAllOptionsToExtract(ExtractOptionsPipeline.kt:137)
	at com.intellij.refactoring.extractMethod.newImpl.MethodExtractor.prepareDescriptorsForAllTargetPlaces$lambda$2(MethodExtractor.kt:93)
	at com.intellij.openapi.application.impl.ApplicationImpl.runReadAction(ApplicationImpl.java:908)
	at com.intellij.openapi.application.ReadAction.compute(ReadAction.java:75)
	at com.intellij.refactoring.extractMethod.newImpl.MethodExtractor$computeWithAnalyzeProgress$1.compute(MethodExtractor.kt:112)
	at com.intellij.openapi.progress.Task$WithResult.run(Task.java:355)
	at com.intellij.openapi.progress.impl.CoreProgressManager.startTask(CoreProgressManager.java:434)
	at com.intellij.openapi.progress.impl.ProgressManagerImpl.startTask(ProgressManagerImpl.java:130)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcessWithProgressSynchronously$8(CoreProgressManager.java:518)
	at com.intellij.openapi.progress.impl.ProgressRunner.lambda$new$0(ProgressRunner.java:84)
	at com.intellij.openapi.progress.impl.ProgressRunner.lambda$submit$4(ProgressRunner.java:248)
	at com.intellij.openapi.progress.ProgressManager.lambda$runProcess$0(ProgressManager.java:73)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$runProcess$1(CoreProgressManager.java:192)
	at com.intellij.openapi.progress.impl.CoreProgressManager.lambda$executeProcessUnderProgress$12(CoreProgressManager.java:610)
	at com.intellij.openapi.progress.impl.CoreProgressManager.registerIndicatorAndRun(CoreProgressManager.java:685)
	at com.intellij.openapi.progress.impl.CoreProgressManager.computeUnderProgress(CoreProgressManager.java:641)
	at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:609)
	at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:76)
	at com.intellij.openapi.progress.impl.CoreProgressManager.runProcess(CoreProgressManager.java:179)
	at com.intellij.openapi.progress.ProgressManager.runProcess(ProgressManager.java:73)
	at com.intellij.openapi.progress.impl.ProgressRunner.lambda$submit$5(ProgressRunner.java:248)
	at com.intellij.openapi.progress.impl.ProgressRunner$ProgressRunnable.run(ProgressRunner.java:498)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:702)
	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:699)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399)
	at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:699)
	at java.base/java.lang.Thread.run(Thread.java:833)

 
"
https://youtrack.jetbrains.com/issue/IDEA-318626/Change-signature-incorrectly-wraps-unwraps-arguments-when-changing-between-varargs-and-arrays,Normal,Bug,Fixed,Java. Refactorings,26 Jul 2023,1,varargs,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/be6a068d767f1b01d8fd9d150d2ca28afabf3e72,flow analysis issue,"Change signature incorrectly wraps/unwraps arguments when changing between varargs and arrays
What steps will reproduce the issue?
Two cases:


varargs to array:
Write a method that takes a varargs argument, then use ""Change signature..."" to change the argument type into an array. Optionally move the argument to a different position.


array to varargs:
Write a method that takes an array argument as the last argument, then change the argument type to varargs.


What is the expected result?

varargs to array:

Argument lists should be wrapped in a new array.
Arguments that are already arrays shouldn't be wrapped in a new array.


array to varargs:

Arguments that are array literals should be unwrapped.



What happens instead?
The IDE sometimes incorrectly wraps arguments (or doesn't when it should):


Changing varargs to array:
// Original method
void doSomething(int x, String... args) { /* ... */ }
doSomething(0, ""foo"", ""bar"");
doSomething(0, new String[]{""one"", ""two""});

// Change signature: String... -> String[]
void doSomething(int x, String[] args) { /* ... */ }
doSomething(0, ""foo"", ""bar"");               // Incorrect
doSomething(0, new String[]{""one"", ""two""}); // Correct

// Change signature: String... -> String[], reorder
void doSomething(String[] args, int x) { /* ... */ }
doSomething(new String[]{""foo"", ""bar""}, 0);               // Correct
doSomething(new String[]{new String[]{""one"", ""two""}}, 0); // Incorrect

Java

Changing array to varargs, when the array already is the last argument:
// Original method
void doSomething(int x, String[] args) { /* ... */ }
doSomething(0, new String[]{""one"", ""two""});

// Change signature: String[] -> String...
void doSomething(int x, String... args) { /* ... */ }
doSomething(0, new String[]{""one"", ""two""}); // Incorrect

Java

Changing array to varargs, when also reordering the array argument, works:
// Original method
void doSomething(String[] args, int x) { /* ... */ }
doSomething(new String[]{""one"", ""two""}, 1);

// Change signature: String[] -> String..., reorder
void doSomething(int x, String... args) { /* ... */ }
doSomething(1, ""one"", ""two""); // Correct

Java
IDE info:
IntelliJ IDEA 2023.1 (Ultimate Edition)
Build #IU-231.8109.175, built on March 28, 2023

 
"
https://youtrack.jetbrains.com/issue/IDEA-274500/Errors-when-extracting-constants-as-nested-enum,Normal,Bug,Fixed,Java. Refactorings,26 Jul 2023,1,enum,compile error,extract variable as enum,https://github.com/JetBrains/intellij-community/commit/779f0ecebc3f427c6c31756c351ccdb0791cfe4f,flow analysis issue,"Errors when extracting constants as nested enum
When extracting constants as a nested enum, the refactoring introduces errors at call sites of methods that are changed to expect the enum as a parameter.
The issue seems similar to IDEA-143251, but only comes up if the enum is created as a nested class.
What steps will reproduce the issue?
public class ExtractEnum {

    public static final int ONE = 1;
    public static final int TWO = 2;
    public static final int THREE = 3;

    public static String numString(int num) {
        switch (num) {
        case ONE:   return ""one"";
        case TWO:   return ""two"";
        case THREE: return ""three"";
        default:    throw new AssertionError(""unknown constant"");
        }
    }

    public static void main(String[] args) {
        System.out.println(numString(ONE));
        System.out.println(numString(TWO));
        System.out.println(numString(THREE));
    }
}

 1. Refactor > Extract delegate…
2. Check both ""Create nested class"" and ""Extract as enum""
3. Select ONE, TWO, and THREE
What is the expected result?
I would expect the following result:
public class ExtractEnum {

    public static String numString(Num num) {
        switch (num) {
        case ONE:   return ""one"";
        case TWO:   return ""two"";
        case THREE: return ""three"";
        default:    throw new AssertionError(""unknown constant"");
        }
    }

    public static void main(String[] args) {
        System.out.println(numString(Num.ONE));
        System.out.println(numString(Num.TWO));
        System.out.println(numString(Num.THREE));
    }

    public enum Num {
        ONE(1),
        TWO(2),
        THREE(3);
        private int value;

        public int getValue() {
            return value;
        }

        Num(int value) {
            this.value = value;
        }
    }
}

 What happens instead?
The enum is generated correctly, and the method parameter is changed to the enum type just fine.
However, at the call site of the method, the enum is converted to the original int value before passing to the method, even though the method expects the enum value.
        System.out.println(numString(Num.ONE.getValue()));
        System.out.println(numString(Num.TWO.getValue()));
        System.out.println(numString(Num.THREE.getValue()));

 
"
https://youtrack.jetbrains.com/issue/IDEA-314882/Inline-method-adds-unnecessary-parentheses-when-inlining-a-string-concatenation-into-a-string-concatenation,Normal,Bug,Fixed,Java. Refactorings,26 Jul 2023,1,nan,unnecessary change,inline method,https://github.com/JetBrains/intellij-community/commit/6a09b77b61b9014cc0d08c411e5f99443096347f,ast rewrite issue,"Inline method adds unnecessary parentheses when inlining a string concatenation into a string concatenation
Inline the string() method in the following code.
class X {
  String string() {
    return ""heavy"" + ""⚡️"" + ""metal"";
  }

  String x() {
    ""🤘"" + string() + ""🤘""
  }
}

 result:
class X {
    String x() {
        return ""🤘"" + (""heavy"" + ""⚡️"" + ""metal"") + ""🤘"";
    }
}

 Since both expressions are of the string type, the parentheses are unnecessary.
"
https://youtrack.jetbrains.com/issue/IDEA-313673/Extracted-method-erroneous-marked-as-static-despite-it-refers-non-static-class,Normal,Bug,Fixed,Java. Refactorings,26 Jul 2023,1,static method,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/7a80c0d0edff27d7d02a2ae6284c7f1cbbf39b50,flow analysis issue,"Extracted method erroneous marked as static despite it refers non-static class
Code:
class X {
  void test() {
    <selection>Runnable r = new Runnable() {
      @Override
      public void run() {
        System.out.println(new Y());
      }
    };</selection>
    r.run();
  }
  
  class Y {}
}

JavaResult of extract method is not compilable:
class X {
  void test() {
    Runnable r = getRunnable();
    r.run();
  }

  @NotNull
  private static Runnable getRunnable() {
    Runnable r = new Runnable() {
      @Override
      public void run() {
        System.out.println(new Y()); // X.this cannot be referenced from static context
      }
    };
    return r;
  }

  class Y {}
}

JavaThe extracted method should not be marked as static.
"
https://youtrack.jetbrains.com/issue/IDEA-308062/Inline-Super-class-performs-unexpectedly,Normal,Bug,Fixed,Java. Refactorings,23 Jun 2023,1,input options,behavior change,inline class,https://github.com/JetBrains/intellij-community/commit/8bdf9dfed95498dcdf0b84641846e6cd7be87c07,ast rewrite issue,"'Inline Super class' performs unexpectedly
Given 3 different files/classes:
public abstract class BaseClass {
    public static final int VALUE = 1;
}

 public class OtherClass extends BaseClass {
}

 public class YetAnotherClass {
    public static void main(String[] args) {
        System.out.println(BaseClass.VALUE);
    }
}

 I invoke 'Inline' action (Cmd+Opt+N), while caret is on BaseClass reference in OtherClass.java. In the opened dialog I pick 'this reference only' option:

After the refactoring finishes, YetAnotherClass.java looks like this:
public class YetAnotherClass {
    public static void main(String[] args) {
        System.out.println(OtherClass.VALUE);
    }
}

 Expected result: I don't expect YetAnotherClass.java file to be changed at all, since I've chosen to perform a local inlining.
IntelliJ IDEA 2023.1 EAP (Ultimate Edition)
Build #IU-231.2872, built on December 7, 2022
Licensed to IntelliJ IDEA EAP user: Dmitry Batrak
Expiration date: January 6, 2023
Runtime version: 17.0.5+8-b721.3 x86_64
VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o.
macOS 13.0.1
GC: G1 Young Generation, G1 Old Generation
Memory: 3072M
Cores: 16
Metal Rendering is ON
Registry:
    vcs.blame.show.affected.files.in.log=false
    ide.mac.touchbar.enabled=false
    idea.profiler.hprof.show.objectAddress=true
    editor.adjust.right.margin=true
    vcs.show.affected.files.as.tab=false
    index.run.configuration.jre=true
    ea.indicator.blinking.timeout=0

Non-Bundled Plugins:
    jetbrains.team.auth (231.2872)
    com.intellij.sisyphus (231.2872)
    com.jetbrains.idea.safepush (231.2872)
    com.jetbrains.intellij.api.watcher (231.2872)
    Jetbrains TeamCity Plugin (2022.12.123443)

Kotlin: 231-1.7.21-release-272-IJ2872

Kotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-309095/Improve-the-Safety-of-Introduce-Variable-Refactorings-concening-ClassCasts,Normal,Bug,Fixed,Java. Refactorings,23 Jun 2023,1,instanceof,exception,introduce variable,https://github.com/JetBrains/intellij-community/commit/6253884c82bd383a038f21a8af8e7744d9eebc30,flow analysis issue,"Improve the Safety of ""Introduce Variable"" Refactorings concening ClassCasts
Improve the Safety of ""Introduce Variable"" Refactorings concerning ClassCasts #

Description #
Considering such example:
1   /* CS1: Original Code Snippet */
2    void foo(Object obj){
3       if(obj instanceof Integer && ((Integer)obj).intValue() > 0){
4             System.out.println(((Integer)obj).intValue());
5       }else if(obj instanceof Float && ((Float)obj).floatValue() > 0.0){
6            System.out.println(((Float)obj).floatValue());
7       }
8    }

JavaIf we select the expression ((Integer)obj).intValue() (line 4 in CS1), and conduct refactoring ""extract local variable"", and name the new variable as value, we will get the following code snippet:
1   /* CS2: Refactored Code Snippet */
2    void foo(Object obj){
3       int value = ((Integer) obj).intValue();
4       if(obj instanceof Integer && value > 0){
5             System.out.println(value);
6       }else if(obj instanceof Float && ((Float)obj).floatValue() > 0.0){
7            System.out.println(((Float)obj).floatValue());
8       }
9    }

JavaSuch refactoring is incorrect and dangerous. If the method is called via foo(new Float(3.5)), the refactored version would result in ClassCastException whereas the original version would not.
"
https://youtrack.jetbrains.com/issue/IDEA-311673/Pull-members-up-refactoring-should-not-allow-pulling-up-synthetic-enum-methods,Normal,Bug,Fixed,Java. Refactorings,23 Jun 2023,1,enum,exception,pull up method,https://github.com/JetBrains/intellij-community/commit/b10f00ab17e6d77a417eadf4add6b441e9c89673,overly weak preconditions,"Pull members up refactoring should not allow pulling up synthetic enum methods
Pull Members Up allows to select the static values() and valueOf() methods of enums. But because they are synthetic they can not be moved and an exception is thrown after clicking Refactor.
Example to reproduce:
interface I {}
enum E implements I {}

Java
"
https://youtrack.jetbrains.com/issue/IDEA-311563/Pull-members-up-refactoring-should-not-allow-pulling-up-non-abstract-record-accessor-method,Normal,Bug,Fixed,Java. Refactorings,23 Jun 2023,1,record,compile error,pull up method,https://github.com/JetBrains/intellij-community/commit/d83f0ae5853be8fc2febdd51d84aeeeec81b3341,overly weak preconditions,"Pull members up refactoring should not allow pulling up non-abstract record accessor method
Example:
interface I {}
record R(int i) {

}

 Invoke the Pull Members Up refactoring on the record, select the accessor method i() and clear the abstract checkbox.
Result: the refactoring creates uncompilable code and throws an exception.
Expected: not possible to clear the abstract checkbox when trying to pull up a record accessor method.
"
https://youtrack.jetbrains.com/issue/IDEA-311776/Incorrect-warning-that-static-members-cant-be-pushed-down-to-non-static-classes,Normal,Bug,Fixed,Java. Refactorings,23 Jun 2023,1,local class,incorrect warning message,push down method,https://github.com/JetBrains/intellij-community/commit/c67c56220df69507c8ac0032d4c23f02d9ca9d9f,overly strong preconditions,"Incorrect warning that static members can't be pushed down to non-static classes
Non-static classes (and local and anonymous classes) can have static members since JDK 16.
Example:
class Foo {
  public static void foo() {} // push me down

  void m() {
    class FooExt extends Foo { }
  }
}

 
"
https://youtrack.jetbrains.com/issue/IDEA-315964/Intellij-Idea-removes-annotation-from-generic-parameters-when-converting-class-to-a-record,Normal,Bug,Fixed,Java. Refactorings,23 Mar 2023,1,annotation,behavior change,convert class to record,nan,nan,"Intellij Idea removes annotation from generic parameters when converting class to a record
What steps will reproduce the issue?
@Value
static class Foo {

    @Size(min = 1, max = 2)
    String bar;

    @NotEmpty
    @Size(min = 1, max = 2)
    String notEmptyBar;

    @Size(min = 3, max = 4)
    List<Object> objects;

    Optional<@Size(min = 3, max = 4) List<Object>> optionalObjects;
}

Ruby detectedIssue the convert to record action.
What is the expected result?
@Value
record Foo(
    @Size(min = 1, max = 2) String bar,
    @NotEmpty @Size(min = 1, max = 2) String notEmptyBar,
    @Size(min = 3, max = 4) List<Object> objects,
    Optional<@Size(min = 3, max = 4) List<Object>> optionalObjects
) {

}

Ruby detectedWhat happens instead?
@Value
record Foo(
    @Size(min = 1, max = 2) String bar,
    @NotEmpty @Size(min = 1, max = 2) String notEmptyBar,
    @Size(min = 3, max = 4) List<Object> objects,
    Optional<List<Object>> optionalObjects
) {

}

Ruby detectedNotice that optionalObjects is missing generic type annotations.
"
https://youtrack.jetbrains.com/issue/IDEA-102024/Moving-fields-from-one-class-to-another-can-be-incorrect,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,move field,https://github.com/JetBrains/intellij-community/commit/f00cc9d5305c862d7fb081374c387a09d3724bd7,flow analysis issue,"Moving fields from one class to another can be incorrect
Try to move:private static DomBundle BUNDLE = GWT.create(DomBundle.class);static DomMapperCss CSS = BUNDLE.style();After move to another class by refactoring you get:static DomMapperCss CSS = BUNDLE.style();private static DomBundle BUNDLE = GWT.create(DomBundle.class);But it is a back reference!
"
https://youtrack.jetbrains.com/issue/IDEA-104308/Change-Signature-Method-parameter-default-value-becomes-fully-qualified-after-refactoring-is-applied,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,unnecessary change,change method signature,https://github.com/JetBrains/intellij-community/commit/298432c18c9a2eba0ab8b959bb040d41c820a281,ast rewrite issue,"""Change Signature"": Method parameter default value becomes fully qualified after refactoring is applied
Initial code:class X {
  void foo() {
    
  }
  
  void bar() {
    foo();
  }
} Invoke ""Change Signature"" on foo and add parameter baz of type Map<String, Integer> with default value Collections.EMPTY_MAP (see screenshot.)Observe:import java.util.Map;

class X {
  void foo(Map<String, Integer> baz) {
    
  }
  
  void bar() {
    foo(java.util.Collections.EMPTY_MAP);
  }
} Expected: bar's parameter type is spelled as Collections.EMPTY_MAP or just EMPTY_MAP, not java.util.Collections.EMPTY_MAP.
"
https://youtrack.jetbrains.com/issue/IDEA-104536/red-code-after-inline-variable,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,foreach,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/55d981e071c53080b7a970f677a594a6dbcfc130,ast rewrite issue,"red code after inline variable
@Override
public boolean isDefault() {
    final List<GrCaseLabel> labels = findChildrenByType(GroovyElementTypes.CASE_LABEL);
    for (GrCaseLabel label : labels) {
      if (label.isDefault()) return true;
    }
    return false;  
  } inline labels:@Override
  public boolean isDefault() {
    for (GrCaseLabel label : ASTDelegatePsiElement.this.<GrCaseLabel>findChildrenByType(GroovyElementTypes.CASE_LABEL)) {
      if (label.isDefault()) return true;
    }
    return false;
  } 
"
https://youtrack.jetbrains.com/issue/IDEA-104986/Make-inner-class-incorrect-accessibility-warning-about-inner-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,inner class,incorrect warning message,move class,https://github.com/JetBrains/intellij-community/commit/a9544ca29678f6530a0b3aacc26d99f9b6dfab92,flow analysis issue,"Make inner class: incorrect accessibility warning about inner class
move class Upper into Target:package a;

class Upper {
  class Inner {
  }
  Inner i;
} package b;

class Target {
} get a warning: Class a.Upper.Inner will no longer be accessible from field Upper.i
"
https://youtrack.jetbrains.com/issue/IDEA-103509/extract-class-as-enum-refactoring-generates-bad-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,enum,compile error,extract class,https://github.com/JetBrains/intellij-community/commit/33dee73821c4baef87519268ed2a4b8524fa6bbe,ast rewrite issue,"extract class as enum refactoring generates bad code
1) There is a class:public class Test {
    static final int A = 0;
    static final int B = 0;
    static final int C = 0;

    int value = B;
} 2) Make Extract -> Class... refactoring3) In Extract Class dialog:  enter Name for new class ""MyEnum""   select Extract as enum checkbox  select A, B, C as Members to Extract  press Refactor4) We will see incorrectly generated code:public class Test {

    MyEnum value = MyEnum.B.getValue();// incompilable
} public enum MyEnum {
    A(0), A(0), B(0), B(0), C(0), C(0);// incompilable
    private int value1;

    public int getValue() {
        return value1;
    }

    MyEnum(int value) {
        value1 = value;
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-122014/Extract-method-duplicates-analysis-fails-in-case-of-inner-classes,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,inner class,behavior change,extract method,https://github.com/JetBrains/intellij-community/commit/90698ca76cc4228b1751a99f8a500d286a6eee08,Incorrect Type Resolving,"Extract method duplicates analysis fails in case of inner classes
Select f() body, do Extract method and you'll get replace g() body as well prompt.If you blindly accept this then the code meaning will be changed completely.public class A extends JComponent {

  private void f() {
    Color c = Color.RED;
    setBackground(c);
  }

  private class B extends JComponent {
    void g() {
      Color c = Color.RED;
      setBackground(c);
    }
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-105455/Introduce-Variable-refactoring-adds-redundant-casting,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,unnecessary change,introduce variable,https://github.com/JetBrains/intellij-community/commit/8e189439ca9aa63555f5dd20ebe161c79aa9cfe5;https://github.com/JetBrains/intellij-community/commit/c362124ffd1bdc4ec45d06c26203dd08b8ba7c1b,ast rewrite issue,"Introduce Variable refactoring adds redundant casting
Consider code snippet:    LibraryTable table = LibraryTablesRegistrar.getInstance().getLibraryTable(module.getProject());    <selection>table.getLibraries()</selection>Invoke ""Introduce Variable"" and get    LibraryTable table = LibraryTablesRegistrar.getInstance().getLibraryTable(module.getProject());    Library[] libraries = (Library[])table.getLibraries();
"
https://youtrack.jetbrains.com/issue/IDEA-105483/Add-constructor-parameters-ignores-parameters-whose-names-clash-with-field-names,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,change method signature,nan,nan,"'Add constructor parameters' ignores parameters whose names clash with field names
class Foo {
    final int bar;
    final HashSet<String> hashSet; // Invoke the quick fix on this line

    Foo(int bar) {
        super();
        this.bar = bar;
    }
}

class Bar {
    public static void main(String[] args) {
        new Foo(1);
    }
} In the Change signature dialog, rename ""set"" parameter to ""hashSet"". Press ""refactor"".Here's the result:class Foo {
    final int bar;
    final HashSet<String> hashSet; // this line is still red

    Foo(int bar, HashSet<String> hashSet) {
        super();
        this.bar = bar;
    }
}

class Bar {
    public static void main(String[] args) {
        new Foo(1, set);
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-106175/move-constant-from-nested-class-to-outer-generates-bad-code-sometimes-if-constant-used-in-annotation,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,behavior change,move constant,https://github.com/JetBrains/intellij-community/commit/bca1f12e1eb8a0ae446b73bb1eb930787723d9bc,flow analysis issue,"move constant from nested class to outer generates bad code sometimes if constant used in annotation
Code before:package ru;

public class Outer {
    static class Nested {
        final static String C0 = """";
        final static String C1 = """";
    }

    @A(Nested.C0)
    enum Enm {
        @A(Nested.C0)
        E0;

        @A(Nested.C1)
        void foo() {
        }
    }
}

@interface A {
    String value();
} Now try to move A and B constants to class Outer.Bad code after Move Members refactoring (in addition IDE internal error occured: Assertion failed: anchorBefore == null || anchorBefore.getTreeParent() == parent):package ru;

public class Outer {
    final static String C1 = """";

    static class Nested {
    }

    @A(Outer.C0)
    enum Enm {
        final static String C0 = """";
        @A(Outer.C0)
        E0;

        @A(Outer.C1)
        void foo() {
        }
    }
}

@interface A {
    String value();
} See screenshots for details.
"
https://youtrack.jetbrains.com/issue/IDEA-123758/Inlining-interfaces-with-constants-result-in-non-constant-fields,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline class,https://github.com/JetBrains/intellij-community/commit/d9fe7023db079c9c5aab67909ae0bca2c84ea5b7,ast rewrite issue,"Inlining interfaces with constants result in non constant fields
If you have an interface like this:public interface SimpleDialogPresenter {
  int BUTTON_POSITIVE = 1; //These are considered static and final since they are in an interface
  int BUTTON_NEGATIVE = 2;
  int BUTTON_NEUTRAL = 3;

  void onClick(int which);
} and a class like this:public class SimpleDialogPresenterImpl implements SimpleDialogPresenter {
  @Override
  public void onClick(int which) {
    //Do something
  }
} After inlining, the resulting class should be this:public class SimpleDialogPresenterImpl {
  public static int BUTTON_POSITIVE = 1;
  public static int BUTTON_NEGATIVE = 2;
  public static int BUTTON_NEUTRAL = 3;

  public void onClick(int which) {
    //Do something
  }
} Because they were public and static in the interface.
"
https://youtrack.jetbrains.com/issue/IDEA-124349/Extract-Parameter-refactoring-fails-for-nested-calls,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nested calls,fail to refactoring,extract parameter,https://github.com/JetBrains/intellij-community/commit/ee2a5d061508a841b1e9c50bbc8ed501ce8213c9,Incorrect Type Resolving,"Extract Parameter refactoring fails for nested calls
Sometimes when extracting parameters and using 'replace all' at the same time fails.Failing examplepublic class Test {

    private void test() {
        TestSubject subject = new TestSubject();
        boolean flag = false;

        if (subject.getSubject2().getVal() != flag) {
            System.out.println(subject.getSubject2().getVal());
        }
    }

    public static class TestSubject {
        public TestSubject2 getSubject2() {
            return new TestSubject2();
        }
    }

    public static class TestSubject2 {
        public boolean getVal() {
            return true;
        }
    }
} Steps to reproduce:1. Select ""subject.getSubject2().getVal()"" from the if-statement2. Use Extract Parameter refactoring: ctrl+alt+p3. Select ""Replace all occurences""What happens:Parameter is introduced in method signature but none of the statements is replaced. Also the refactoring popup 'looses focus' and has to be closed manually with mouse click. After closing the popup you can no longer use the Extract Parameter functionality (little red popup is displayed saying: ""Extract Parameter is not finished yet."". Restarting IDE helps, but the problem is reproducable every time.Used version:12.1.4Build 129.713Logs attached.Thanks!
"
https://youtrack.jetbrains.com/issue/IDEA-124385/Replace-anonymous-type-with-lambda-bug,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,replace anonymous with lambda,https://github.com/JetBrains/intellij-community/commit/f3e1d968b82749fdffe05cab6779432f3c8d4ca3,Incorrect Type Resolving,"Replace anonymous type with lambda bug
Convert to lamda will cause bugs and can cause compiler like errors in this case: 1. Declare variable A 2. Create anonymous class referencing variable A 3. Inside anonymous class define a new variable B with the same name as A 4. Use variable B 5. Convert to lambdaIf B is of another type than A then it can cause a compiler error so you can see the bug, if not the bug will not be easily detected by userspublic class Test {

    public void testLambdaConversionBug() {
        Object data = new Object();
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(data.getClass());
                {
                    Integer data=1;
                    System.out.println(data.longValue());

                }
            }
        });

    }
} After lambda conversion this is the result. As you can see the innermost data declaration gets renamed to data1, but the last usage now incorrecly references data instead of data1.public class Test {

    public void testLambdaConversionBug() {
        Object data = new Object();
        new Thread(() -> {
            System.out.println(data.getClass());
            {
                Integer data1 =1;
                System.out.println(data.longValue());
            }
        });

    }
} It should be like this:public class Test {

    public void testLambdaConversionBug() {
        Object data = new Object();
        new Thread(() -> {
            System.out.println(data.getClass());
            {
                Integer data1 =1;
                System.out.println(data1.longValue());
            }
        });

    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-108026/Renaming-an-entity-field-does-not-rename-the-setter-method-parameter,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,fail to refactoring,rename field,https://github.com/JetBrains/intellij-community/commit/46bb77d1c0b7e0c19942c84a37a47cf3b066b00f,ast rewrite issue,"Renaming an entity field does not rename the setter method parameter
If I rename a field in a class annotated with Ruslan, it renames the getter and setter methods, but it does not rename the parameter in the setter method. It works correctly if I comment out the Ruslan before doing the rename.e.g.private int newName;public int getNewName() {  return newName;}public void setNewName( int oldName ) {  this.newName = oldName;}----IDEA 12.1.3, Windows 7 64 bit, project uses Spring and JPA
"
https://youtrack.jetbrains.com/issue/IDEA-125141/Introduce-constant-field-throws-ClassCastException-when-variable-is-used-in-try-with-resources-statement,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,try-with-resources,exception,introduce field,https://github.com/JetBrains/intellij-community/commit/b1b602553c63d6056956627102d2e6a31ac44de4,ast rewrite issue,"Introduce constant/field throws ClassCastException when variable is used in try-with-resources statement
Consider the following code:import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class JavaClass {
    static String readFirstLineFromFile() throws IOException {
        try (BufferedReader br = createReader(""any"")) {
            return br<caret>.readLine();
        }
    }

    private static BufferedReader createReader(String path) {
        try {
            return new BufferedReader(new FileReader(path));
        } catch (FileNotFoundException e) {
            // for example purposes #createReader shouldn't throw any checked exception
            throw new RuntimeException(e);
        }
    }
} (where <caret> specifies the position of editor's caret). When I do introduce constant/field refactoring by pressing Alt+Ctrl+C/F, I get ClassCastException (see attached stacktrace).
"
https://youtrack.jetbrains.com/issue/IDEA-125126/Convert-to-Atomic-fail,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,convert to automic,https://github.com/JetBrains/intellij-community/commit/c4a90c57dc3217202c280a4e663120fef1d17fdf,flow analysis issue,"Convert to Atomic fail
Note: I don't know if convert to atomic belongs to JetBrains or if it's a third parties plugin (ignore it in this case)!Easy to reproduce:class AtomicFail {
    void someMethod() {
        boolean bool = false;

        if ( bool ) {
            System.out.println(""IntelliJ for ever :)"");
        }

        if ( ! bool ) {
            System.out.println(""WTF? :("");
        }
    }
} After calling ""Convert to atomic"" on bool variable:import java.util.concurrent.atomic.AtomicBoolean;

class AtomicFail {
    void someMethod() {
        final AtomicBoolean bool = new AtomicBoolean(false);

        if ( bool.get() ) {
            System.out.println(""IntelliJ for ever :)"");
        }

        if ( bool.set(bool.get())  {
            System.out.println(""WTF? :("");
        }
    }
} Result: incorrect syntax (missing a closing parenthesis). and an incorrect conversionregards,fred
"
https://youtrack.jetbrains.com/issue/IDEA-125259/Extract-method-removes-generic-casts,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,behavior change,extract method,https://github.com/JetBrains/intellij-community/commit/ec9a61b8bd974d4286b8f0add37475dd8196cd81,ast rewrite issue,"Extract method removes generic casts
E.g. cast to THashMap is removed from this code (taken from MapReduceIndex)final boolean b = ((THashMap<Key, Value>)newData).forEachEntry(new TObjectObjectProcedure<Key, Value>() {        @Override        public boolean execute(Key key, Value value) {          try {            myStorage.addValue(key, inputId, value);          }          catch (StorageException ex) {            exceptionRef.set(ex);            return false;          }          return true;        }      });
"
https://youtrack.jetbrains.com/issue/IDEA-108187/Extract-Parameter-Object-creates-wrong-Javadoc,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,extract parameter,https://github.com/JetBrains/intellij-community/commit/fa612bf031dec83b1a47897dbce28669cfa090fd,ast rewrite issue,"Extract Parameter Object creates wrong Javadoc
When I have the following method:    /**
     * @param x This is x
     * @param y This is y
     * @param z This is z
     */
    public void x(Integer x, String y, String z) {

    }
} And I extract this to a parameter object, using only y and z, IntelliJ will create the following Javadoc in the extracted class:     * @param x This is x
     * @param y This is y
     * @param z This is zRuby detectedwhich is wrong, it should have been:     * @param y This is y
     * @param z This is zRuby detected
"
https://youtrack.jetbrains.com/issue/IDEA-104417/Refactoring-creates-silly-assignment,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,rename field,https://github.com/JetBrains/intellij-community/commit/29db8a98836942bd8a9743f4e55fbfe19f454fe0,flow analysis issue,"Refactoring creates ""silly assignment""
Beforepublic class Bean {
    
    private boolean isVisible;

    public Bean(boolean visible) {
        isVisible = visible;
    }
} Then refactor-rename field ""isVisible"" to ""isEnabled"", select the parameter to be renamed, too, and edit the parameter name to ""isEnabled"" (see screenshot).Afterpublic class Bean {

    private boolean isEnabled;

    public Bean(boolean isEnabled) {
        isEnabled = isEnabled;
    }
} Note the silly assignment in the constructor.It should of course be ""this.isEnabled = isEnabled"".Build IU-130.169
"
https://youtrack.jetbrains.com/issue/IDEA-136958/Extract-variable-does-not-work-for-list-of-enums-that-implement-a-particular-type,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,enum,not available,extract variable,https://github.com/JetBrains/intellij-community/commit/21fd57c89f9bc114d99ce5ba7bcb7f56bffb229a,Incorrect Type Resolving,"Extract variable does not work for list of enums that implement a particular type
Extract variable on this statement {code:lang=java}interface I {}enum X implements I  {a}enum Y implements I {a}Arrays.asList(X.a, Y.a); //Cannot extract this to a variable(code}fails silently and does not extract a variable.
"
https://youtrack.jetbrains.com/issue/IDEA-138033/ExtractParameterObject-refactoring-changing-parameters-to-extract-default-names-produces-invalid-code-in-case-of-new-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract parameter,https://github.com/JetBrains/intellij-community/commit/e9095a215386f05ee9c53eceeee79a2a7e99d01d,flow analysis issue,"ExtractParameterObject refactoring: changing ""parameters to extract"" default names produces invalid code in case of new class generating
141.293Perform Extract | Parameter Object... refactoring for the following method:public void assignGroup(Person person, Group group, Date date){
        MyRegistry.add(date.toString() + ""user "" + person.getName() + ""assigned to group "" + group.getId());
        person.setGroup(group);
        group.getUsers().add(person);
    } In the Introduce Parameter Object dialog, select to create new class named AssignmentData, and also modify the default names for the extracted parameters: change 'person' to 'user', 'group' to 'usergroup', 'date' to 'eventdate'.As a result the class is generated with properties of these specified names:public class AssignmentData {
    private final Person user;
    private final Group usergroup;
    private final Date eventdate;
     public AssignmentData(Person person, Group group, Date date) {
        user = person;
        usergroup = group;
        eventdate = date;
    }
   <correspondent getters and setters> But the access methods used in refactored method code don't correspond to specified ones so the code is invalid: public void assignGroup(AssignmentData assignmentData){

        MyRegistry.add(assignmentData.getDate().toString() + ""user "" + assignmentData.getPerson().getName() + ""assigned to group "" + assignmentData.getGroup().getId());
        assignmentData.getPerson().setGroup(assignmentData.getGroup());
        assignmentData.getGroup().getUsers().add(assignmentData.getPerson());
    }
 Expected code: public void assignGroup(AssignmentData assignmentData){

        MyRegistry.add(assignmentData.getEventdate().toString() + ""user "" + assignmentData.getUser().getName() + ""assigned to group "" + assignmentData.getUsergroup().getId());
        assignmentData.getUser().setGroup(assignmentData.getUsergroup());
        assignmentData.getUsergroup().getUsers().add(assignmentData.getUser());
    } If the existing class is selected to be used, then the parameters renaming to this class existing properties works as expected. But in this case it would be nice to autocomplete the existing class properties in this dialog
"
https://youtrack.jetbrains.com/issue/IDEA-109272/Move-Members-refactoring-breaks-switch-statement-with-strings,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,switch case,compile error,move field,https://github.com/JetBrains/intellij-community/commit/51d17241964fe239016eee30ff6507e219a9e93d,ast rewrite issue,"""Move Members"" refactoring breaks switch statement with strings
Try using F6 to move the TEST string into the Test2 class with the following example code:public class Test1 {
  private static final String TEST = ""ABC"";
  private void test(String s) {
    switch (s) {
      case TEST:
    }
  }
}
class Test2 {} The case statement should get corrected to the following, but doesn't:case Test2.TEST: 
"
https://youtrack.jetbrains.com/issue/IDEA-125934/Rename-field-refactoring-shadows-local-but-doesnt-notify-user,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,rename field,https://github.com/JetBrains/intellij-community/commit/350760c993dee773aa52c8db38fb409884ba3d16,flow analysis issue,"Rename field refactoring shadows local but doesn't notify user
Consider the two classes (""A"" and ""B""):public class A {
    protected final int a = 1;
} andpublic class B {
    void main() {
        final int b = 2;
        new A() {
            void m() {
                System.out.println(b);
            }
        };
    }
} If in class ""A"" I do rename field ""a"" to ""b"", it silently does it, and in class ""B"" ""println"" statement becomes to print value of field (not local var).Expected: it should inform user that after renaming field will shadow local variable (it's unresolvable conflict).
"
https://youtrack.jetbrains.com/issue/IDEA-124747/Encapsulate-fields-refactoring-removes-my-comments,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,encapsulate field,https://github.com/JetBrains/intellij-community/commit/693bbf6ef822014c9ac090f2586348fd3a3709d2,ast rewrite issue,"""Encapsulate fields"" refactoring removes my comments
Before encapsulating bar field:public class Foo {

    static Object bar;
    public static void main(String[] args) {
        Foo/* a b c */.bar.toString();
    }
} After:public class Foo {

    private static Object bar;
    public static void main(String[] args) {
        Foo.getBar().toString();
    }

    public static Object getBar() {
        return bar;
    }

    public static void setBar(Object bar) {
        Foo.bar = bar;
    }
} Refactoring removed my /* a b c*/ comment.
"
https://youtrack.jetbrains.com/issue/IDEA-109541/Inline-resource-variable-leaves-uncompilable-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,try-with-resources,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/95ae5e69dbb7e8f979c894b17fef0771fd4198db,ast rewrite issue,"Inline resource variable leaves uncompilable code
Before:class C {
  void m() throws Exception {
    try (AutoCloseable inlineMe = null) {
      try (AutoCloseable r2 = inlineMe) {
        System.out.println(inlineMe + "", "" + r2);
      }
    }
  }
} After:class C {
  void m() throws Exception {
    try {
      try (AutoCloseable r2 = null) {
        System.out.println(r2 + "", "" + r2);
      }
    }
  }
} The surrounding try statement is now broken because it has no resource list, catch sections or finally block.Expected:class C {
  void m() throws Exception {
    try (AutoCloseable r2 = null) {
      System.out.println(r2 + "", "" + r2);
    }
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-109543/Safe-delete-resource-variable-leaves-uncompilable-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,try-with-resources,compile error,delete variable,https://github.com/JetBrains/intellij-community/commit/b8638b7b469db292888f2511b884d008103f0aef,ast rewrite issue,"Safe delete resource variable leaves uncompilable code
See also IDEA-109541Before:class C {
  void m() throws Exception {
    try (AutoCloseable deleteMe = null) {
      System.out.println(""hi!"");
    }
  }
} After:class C {
  void m() throws Exception {
    try {
      System.out.println(""hi!"");
    }
  }
} The try statement is now broken because it has no reource list, catch sections or finally block.Expected:class C {
  void m() throws Exception {
    System.out.println(""hi!"");
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-109576/Extract-interface-refactoring-breaks-foreach-loops,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,foreach,behavior change,extract interface,https://github.com/JetBrains/intellij-community/commit/17ff190b7cfacb805c560e4af0f06e651ba6d1fc,ast rewrite issue,"Extract interface refactoring breaks foreach loops
Extract interface (w/ rename and use interface where possible option) refactoring on a class that is used in an overriden method calls hierarchy breaks foreach loops.Please see example project attached. Before is before refactoring, after is after and image shows the refactoring settings.This only manifests in cases where loop is present in a method that overrides another method that also uses the class being refactored in the signature.I think I deserve bonus points for figuring out the minimal test-case!
"
https://youtrack.jetbrains.com/issue/IDEA-138895/Extract-Function-Parameter-produces-incorrect-code-when-invoked-from-anonymous-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,anonymous class,compile error,extract parameter,https://github.com/JetBrains/intellij-community/commit/45c5c2163f82c2dfe0a05993625fdf7870f7fdc9,ast rewrite issue,"'Extract Function Parameter' produces incorrect code when invoked from anonymous class
Select 'System.out.println();' and invoke 'Extract Function Parameter' in the following code:class A {
    void b() {
        Runnable c = new Runnable() {
            @Override
            public void run() {
                System.out.println();
            }
        };
    }
} It'll be transformed toclass A {
    void b(Runnable runnable) {
        Runnable c = new Runnable() {
            @Override
            public void run() {
                runnable.A.this.run();
            }
        };
    }
} which is not compilable.
"
https://youtrack.jetbrains.com/issue/IDEA-138745/Replace-method-duplicate-failed-for-constructor,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract parameter,https://github.com/JetBrains/intellij-community/commit/e1e48eb1e80337f20fa7d0cbeccfb13e62b37437,ast rewrite issue,"Replace method duplicate failed for constructor
Easier to explain it with an example:class A {
    public A(String a) {
    }
}

class B extends A {
    public B(String a) {
        super(a);
    }
    public B(String a) {
        super(a);
        String b = ""b"";
    }
}Kotlin detectedNote: I know there same constructor, I just wanted to create a new one with a new parameter, check below. And here I put only a simple example.How to produce the issue:1) Select variable b in second B constructor;2) Extract as parameter (ctrl+alt+P on windows);3) After selecting parameter name, a popup ask to ""Process Method B duplicate"", choose ""Replace""Here the result:class A {
    public A(String a) {
    }
}

class B extends A {
    public B(String a) {
        B(a, null);      // <== failure, should be: this(a, null);
    }
    public B(String a, String b) {
        super(a);
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-126312/Bad-inline-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,inline method,https://github.com/JetBrains/intellij-community/commit/f0f8dd1db2faaa6c0b9b30a98cff70215357f79a,Incorrect Type Resolving,"Bad inline method
Have this code:  public boolean isConsideredFinal(int cl) {
    return haveSeenAllExpectedAtCl(cl, countExpectedDirectlyAtCl());
  }

  private boolean haveSeenAllExpectedAtCl(int cl, int countExpectedDirectlyAtCl) {
    return cl == cl()
        && countSeenDirectlyAtCl() == countExpectedDirectlyAtCl;
  } Put cursor at haveSeenAllExpectedAtCl on line 5.  Press control-alt-N (inline method).Resulting code is:  public boolean isConsideredFinal(int cl) {
    return cl == this.cl1()
        && countSeenDirectlyAtCl() == countExpectedDirectlyAtCl();
  } This is buggy because the ""this.cl()"" method call was rewritten as ""this.cl1()"".(Only tested in IntelliJ IDEA 12.1.4)
"
https://youtrack.jetbrains.com/issue/IDEA-139615/Extract-Interface-doesnt-handle-multiple-type-parameters-creates-broken-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,extract interface,https://github.com/JetBrains/intellij-community/commit/6be67cfec0478d935a34950329e99f5d4fd443d6,ast rewrite issue,"Extract Interface doesn't handle multiple type parameters, creates broken code
I have an interface with 2 methods and 2 type parameters and some code that uses it:interface Bar<T, U> {
    T method1();
    U method2(T t);
}

class Foo {
    void foo(Bar<String, Integer> bar) {
        bar.method1();
    }
} If I extract method1 to another type SuperBar and ask IDEA to replace uses with the new type where possible, it leaves 2 type parameters on the usages of SuperBar, although it only has one type parameter.interface SuperBar<T> {
    T method1();
}
interface Bar<T, U> extends SuperBar<T> {
    U method2(T t);
}
class Foo {
    void foo(SuperBar<String, Integer> superBar) {
                     ^^^^^^^^^^^^^^^^^ SuperBar only has one type parameter
        superBar.method1();
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-139292/Extract-method-refactoring-in-local-anonymous-class-introduces-unnecessary-parameter,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,unnecessary change,extract method,https://github.com/JetBrains/intellij-community/commit/b044c4fcee31ba6c36c981f23413907be9fb63a0,flow analysis issue,"""Extract method"" refactoring in local/anonymous class introduces unnecessary parameter
In the following example, if the Extract method refactoring is applied to the body of the lambda expression assigned to runnable and class Local is chosen as the destination of the new method, IDEA introduces a parameter to pass the value of value to the new method:class Example  {
    void foo(int value) {
        class Local {
            void bar() {
                Runnable runnable = () -> {
                    System.out.println(value);
                };
            }
        }
    }
}Kotlin detectedclass Example  {
    void foo(int value) {
        class Local {
            void bar() {
                Runnable runnable = () -> {
                    print(value);
                };
            }
            
            private void print(int value) {
                System.out.println(value);
            }
        }
    }
}Kotlin detectedThis is unnecessary because the scope of the new method will contain the parameter value. Removing the parameter of method print() afterwards leads to semantically equivalent code. The same happens regardless whether value is a parameter or a local variable or whether Local is a local or anonymous class.I don't know whether there's a significant difference in terms of performance, e.g. relating to when certain object can be garbage collected (value could have a complex type instead). But the current behavior certainly seems counter-intuitive to me.
"
https://youtrack.jetbrains.com/issue/IDEA-139827/Avoid-the-perform-of-rename-refactoring-at-the-implicit-enum-elements-e.g.-values-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,enum,compile error,rename method,https://github.com/JetBrains/intellij-community/commit/a43a311851eca1d0c6c05f1f2b1012e94a6886b7,overly weak preconditions,"Avoid the perform of rename refactoring at the implicit enum elements (e.g. values() method)
Steps to reproduce:1)  Create class with inner enum;2)  try rename enum method;Test Datapublic class Test {

  {
    Season.values();
    Season.va<caret>lueOf(""""); //perform rename at me
  }

  enum Season {WINTER, SPRING, SUMMER, AUTUMN}
} 
"
https://youtrack.jetbrains.com/issue/IDEA-110332/Reordering-parameters-via-Change-Signature-refactoring-breaks-Javadoc,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/424001aef52825cf062f9567b6db936512440c9e;https://github.com/JetBrains/intellij-community/commit/c50d84e703c0e5f06f0efe92c23ed7cab2f91d32;https://github.com/JetBrains/intellij-community/commit/58e9f5ffd84921e126149b2b2d1ca55454a27dc7,ast rewrite issue,"Reordering parameters via 'Change Signature' refactoring breaks Javadoc
Before/**
Does what it should, on time, sometimes.

@param param1 The 1st parameter.
@param param2 The 2nd parameter.
*/
public void doSomething(String param1, Integer param2) {
   // my code here
} After/**
Does what it should, on time, sometimes.
*/
* @param param2 The 2nd parameter.
@param param1 The 1st parameter.
public void doSomething(Integer param2, String param1) {
   // my code here
} 
"
https://youtrack.jetbrains.com/issue/IDEA-127135/Inline-call-to-getter-generates-invalid-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/1c70a2804a2db833c2a2582e83fdc96eee7febf5,ast rewrite issue,"""Inline call to getter"" generates invalid code
Create a project and enter the following for CallToSimpleGetter.java:public class CallToSimpleGetter {
    private String someString = """";

    public void execute() {
        getFirst();
    }

    public String getFirst() {
        return someString;
    }
} 1. Place the cursor on the call to ""getFirst()"" in the execute() method.2. Press Option-Return (on a Mac)3. Select menu item ""Inline call to getter""Code is replaced with:public class CallToSimpleGetter {
    private String someString = """";

    public void execute() {
        someString;
    }

    public String getFirst() {
        return someString;
    }
} but this code is now invalid:1. There is a red line under ""someString;"" (in the execute() method), and2. If you hover the mouse over the red line, you get the popup error message ""Not a statement"".
"
https://youtrack.jetbrains.com/issue/IDEA-127411/Problem-with-inline-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,inline method,https://github.com/JetBrains/intellij-community/commit/b585c95984775b61cdea18bbfbbbdc4e9ae6b641,flow analysis issue,"Problem with inline method
I have:public class TextField {
    private final JTextField textField = new JTextField();

    public void onValueSet(ValueSetEvent<?> event) {
        setTextField();
    }

    private void setTextField() {
        textField.setText(""foo"");
    }
} When I inline setTextField() I get:public class TextField {
    private final JTextField textField = new JTextField();

    public void onValueSet(ValueSetEvent<?> event) {
        this.textField1.setText(""foo"");
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-140384/Javadoc-link-breaks-on-refactoring,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/6f39da37617a8c800cb447ed84a0827601623d2e,ast rewrite issue,"Javadoc @link breaks on refactoring
Consider the following Java code:    public void abc(Integer arg1, String arg2, Integer arg3) {}

    /** {@link #abc(Integer, String, Integer)} */
    public void def() {} After invoking Safe Delete on parameter arg2 (which is unused), the code changes to:    public void abc(Integer arg1, Integer arg3) {}

    /** {@link #abc(String, String)} */
    public void def() {} The javadoc link is now broken. The result after the refactoring should of course be:    public void abc(Integer arg1, Integer arg3) {}

    /** {@link #abc(Integer, Integer)} */
    public void def() {} 
"
https://youtrack.jetbrains.com/issue/IDEA-127819/Refactoring-Parameterized-anonymous-to-Inner-class-gets-same-name-as-outer-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,anonymous class,compile error,parameterize anonymous to inner class,https://github.com/JetBrains/intellij-community/commit/bdbfc53c07be529875acc8f48f41196f9e2f9e43,ast rewrite issue,"Refactoring (Parameterized) anonymous to Inner class gets same name as outer class
Without genericspublic class JavaOne {    void somefun() {        JavaOne javaOne = new Java<caret>One() {        };    }}givespublic class JavaOne {    void somefun() {        JavaOne javaOne = new MyJavaOne();       }    private static class MyJavaOne extends JavaOne {   //GOOD. by default name is MyJavaOne    }}But if the class is parameterizedpublic class TempClass<K, V> {    void somfun() {        TempClass<K, V> tempClass = new Temp<caret>Class<K, V>(){            void anonymousFun() {                System.out.println("""");            }        };    }}By default, the inner class gets the same name and there is error shown in the editor. True, that the user can reset the name in the pop up while refactoring , it will be good to have the same behavior as the non-parameterized class case. public class TempClass<K, V> {    void somfun() {        TempClass<K, V> tempClass = new TempClass<>();    }    private static class TempClass<K, V> extends TempClass<K, V> {  //""Duplicate class"" error        void anonymousFun() {            System.out.println("""");        }    }}Expected behavior:The inner class should be MyTempClass
"
https://youtrack.jetbrains.com/issue/IDEA-110978/Refactors-this-as-null-when-converting-for-each-loop-to-indexed-for-loop,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,foreach,compile error,replace foreach with for,https://github.com/JetBrains/intellij-community/commit/615ffb9356ec7863975611d7406bb2f143d36eb7,flow analysis issue,"Refactors this as null when converting for-each loop to indexed for loop
Heyho,in intellij there is an option to replace a for-each loop with an indexed for loop:Correctfor (Node node : new ArrayList<Node>()) {
} Failsfor (Node node : this) {
} So for some reason it generates for the first snippet:Failedfor (int i1 = 0; i1 < null.size(); i1++) {
    Node node = null.get(i1);
} So the null should be replaced with this or removed.The other example worksMax
"
https://youtrack.jetbrains.com/issue/IDEA-140839/Generic-arguments-are-incorrectly-refactored-when-nested-classes-are-involved.,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,move class to upper level,https://github.com/JetBrains/intellij-community/commit/cde47646e57a27a37b0c8b3c95556085efb3a834,ast rewrite issue,"Generic arguments are incorrectly refactored when nested classes are involved.
Version: Android studio 1.2 RC 31. Create a java snippet:class Main {
  static abstract class A implements List<A.B> {
    static class B {
    }
  }
} class A refers its nested class B as its generic argument.2. Refactor ""A"" class with ""Move/to upper level"" refactoring.3. Class gets moved into a separate file.Expected:class is now declared like this: abstract class A implements List<A.B> {
  static class B {
  }
} with nested class properly qualified.Actual:class is declared this way: abstract class A implements List<B> {
  static class B {
  }
} ""A.B"" is incorrectly simplified to ""B"", which doesn't complile. Before class body starts, its inner elements must be referred only properly qualified.
"
https://youtrack.jetbrains.com/issue/IDEA-110601/Change-Signature-with-parameter-propagation-breaks-parameter-in-method-call,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,change method signature,https://github.com/JetBrains/intellij-community/commit/ec8876bed5211e18840dd161da48d37f086e61f2,ast rewrite issue,"Change Signature with parameter propagation breaks parameter in method call
I've got three classes (see attachment1.png).When I change signature of ClassA#methodA with propagation until ClassB.methodB(see attachment2.png)then IDEA breaks the call to classB.methodB in ClassC#methodC with removing the original parameters (see attachment3.png)Here are the classespublic class ClassA {    public String methodA() {        return null;    }}public class ClassB {    private ClassA classA = new ClassA();    public String methodB(int var1, String var2) { return classA.methodA();    }}public class ClassC {    private ClassB classB = new ClassB();    public void methodC(String string) {        int var1 = 1;        String var2 = ""c"";        classB.methodB(var1, var2);    }}
"
https://youtrack.jetbrains.com/issue/IDEA-111735/Change-Signature-refactoring-corrupts-javadoc-links-references-to-the-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/3069f9ae10d30d0a476d17f6e237473133a298ec,ast rewrite issue,"Change Signature refactoring corrupts javadoc @links references to the method
Performing a change signature refactoring on a method corrupts javadoc@links references to the method being refactored. ExampleThe first parameter in the foo method is changed from List<DateTime> to Iterable<DateTime>Before Refactor    public void foo(List<DateTime> dates, Collection<TimeUnit> timeUnits)
    { ... }

    /**
     * ... use {@link #foo(java.util.List, java.util.Collection)} as ...
     */
    public void bar()   { ... } After Refactor    public void foo(Iterable<DateTime> dates, Collection<TimeUnit> timeUnits)
    { ... }

    /**
     * ... use {@link #foo(Iterable} as ...
     */
    public void bar()   { ... } Notice the Javadoc link is corrupted.
"
https://youtrack.jetbrains.com/issue/IDEA-141301/Refactor-extract-interface-creates-not-compilable-code-if-enum-constants-are-selected-in-dialog,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,enum,compile error,extract interface,https://github.com/JetBrains/intellij-community/commit/4c5bee489fe2640fb7fc20332d9a2eea5107e72e,overly weak preconditions,"Refactor/extract interface creates not compilable code if enum constants are selected in dialog
142.2327in ExtractInterface refactoring dialog one can select the enumeration constant as a member to extract. The result is always bad - you get interface like that:public interface FooEnumInterface {
    public FOO3(12), public FOO1(10){
        // some body
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-141299/Refactor-replace-constructor-with-factory-method-with-builder-creates-not-compilable-code-for-enums,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,enum,compile error,replace constructor with factory method,https://github.com/JetBrains/intellij-community/commit/38e2d2cd6c8aba6f895027e56a9da3105ac3438c,overly weak preconditions,"Refactor | replace constructor with factory method / with builder creates not compilable code for enums
142.2327public enum FooEnum {
    FOO1(10),FOO2(11),FOO3(12);
    int arg;

    FooEnum(int arg) {
        this.arg = arg;
    }
} try ""replace constructor with factory method"" refactoring (it is enabled):public enum FooEnum {
    FOO1(10),FOO2(11),FOO3(12);
    int arg;

    private FooEnum(int arg) {
        this.arg = arg;
    }

    private static FooEnum createFooEnum(int arg) {
        return new FooEnum(arg);
    }
} try ""replace constructor with builder"" refactoring (it is enabled):public enum FooEnum {
    FOO1(0),FOO2(1),FOO3(2);
    int arg;

    public FooEnum(int arg) {
        this.arg = arg;
    }
}
public class FooEnumBuilder {
    private int myArg;

    public FooEnumBuilder setPropArg(int arg) {
        myArg = arg;
        return this;
    }

    public FooEnum createFooEnum() {
        return new FooEnum(myArg);
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-141562/Extract-method-does-not-generate-required-parameter,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/f2cddf72019fa7225ea953959bfded3c460e121d,flow analysis issue,"Extract method does not generate required parameter
static String guessTestDataName(PsiMethod method) {    String testName = getTestName(method);    if (testName == null) return null;    PsiClass psiClass = method.getContainingClass();    if (psiClass == null) return null;    PsiMethod prevSiblingOfType = PsiTreeUtil.getPrevSiblingOfType(method, PsiMethod.class);    PsiMethod[] methods = psiClass.getAllMethods();    for (PsiMethod psiMethod : methods) {<sel>      List<String> strings = collectTestDataByExistingFiles(psiMethod);      if (strings != null && !strings.isEmpty()) {        String s = strings.get(0);        return new File(new File(s).getParent(), testName + ""."" + FileUtilRt.getExtension(new File(s).getName())).getPath();      }</sel>    }    return null;  }
"
https://youtrack.jetbrains.com/issue/IDEA-141634/Introduce-variable-may-produce-not-compilable-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,introduce variable,https://github.com/JetBrains/intellij-community/commit/eaa9b80df11ac90ae782ebc8638b19cd8a057cba,ast rewrite issue,"Introduce variable may produce not compilable code
142.snapshot from 18.06.15steps to reproduce: override paintChildren in BalloonImpl.MyComponent@Override
protected void paintChildren(Graphics g) {
   int a = myComp.getHeight();
}  introduce variable for myComp.getHeight() press enter for height nameresulting code is:protected void paintChildren(Graphics g) {
   int height = myComp.getHeight();
   int a = BalloonImpl.this.height;
} which does not compile
"
https://youtrack.jetbrains.com/issue/IDEA-142163/Extract-method-failure-in-Java8-lambda,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/4684772197ca13b910ee918000a3ce1a8eb198f8,flow analysis issue,"Extract method failure in Java8 lambda
Java version:oleg@oleg-desktop:/opt$ java -version
java version ""1.8.0_45""
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)Ruby detectedI have the following piece of code in default BitSet test(final List<T> items) {
    try {
      return ourPredicatesCache.get(Pair.create(this, items), () -> {
        final BitSet result = new BitSet(items.size());
        for (int i = 0; i < items.size(); i++) {
          result.set(i, test(items.get(i)));
        }
        return result;
      });
    } catch (final ExecutionException e) {
      Logs.error(e);
      throw new RuntimeException(e);
    }
  }   I want to extract the following        final BitSet result = new BitSet(items.size());
        for (int i = 0; i < items.size(); i++) {
          result.set(i, test(items.get(i)));
        }
        return result; IDEA fails to mark items as input argument.Resulting code   default BitSet test(final List<T> items) {
    try {
      return ourPredicatesCache.get(Pair.create(this, items), () -> {
        return getBitSet();
      });
    } catch (final ExecutionException e) {
      Logs.error(e);
      throw new RuntimeException(e);
    }
  }

  @NotNull
  default BitSet getBitSet() {
    final BitSet result = new BitSet(items.size());
    for (int i = 0; i < items.size(); i++) {
      result.set(i, test(items.get(i)));
    }
    return result;
  } 
"
https://youtrack.jetbrains.com/issue/IDEA-112590/Extract-class-as-enum-breaks-code-when-multiple-constants-are-in-one-declaration,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,enum,compile error,extract class,https://github.com/JetBrains/intellij-community/commit/832256ec3375a6c00e3275aca658bc12e09d0450,ast rewrite issue,"Extract class as enum breaks code when multiple constants are in one declaration
Extract class as enum on the following and select all 4 fields:class X {
    public static final int LEFT = 0, RIGHT = 1, CENTERED = 2, JUSTIFIED = 3;
} Result, comma debris left behind:class X {
    ,,,
} When selecting just one field to extract, the type of the other fields is changed to the newly created enum:class X{
    , public static final Orientation RIGHT = 1, CENTERED = 2, JUSTIFIED = 3;
} (Noticed this when I was looking at IDEA-112022)
"
https://youtrack.jetbrains.com/issue/IDEA-142291/Pull-members-up-to-cyclically-dependent-class-causes-StackOverflowError,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,cyclically dependent class,crash,pull members up,https://github.com/JetBrains/intellij-community/commit/0c0d95fbc980aaaf332ecb5c1d390026ff2e9c2a,flow analysis issue,"'Pull members up' to cyclically dependent class causes StackOverflowError
class C extends C {
    @Override
    public void test() {
    }
} Press Alt+Enter on @Override annotation and choose 'Pull members up' action.null
java.lang.StackOverflowError
 at gnu.trove.TObjectCanonicalHashingStrategy.equals(TObjectCanonicalHashingStrategy.java:12)
 at com.intellij.util.containers.ConcurrentHashMap.isEqual(ConcurrentHashMap.java:3610)
 at com.intellij.util.containers.ConcurrentHashMap.isEqual(ConcurrentHashMap.java:3606)
 at com.intellij.util.containers.ConcurrentHashMap.get(ConcurrentHashMap.java:949)
 at com.intellij.util.containers.ConcurrentWeakKeySoftValueHashMap.get(ConcurrentWeakKeySoftValueHashMap.java:231)
 at com.intellij.psi.impl.source.resolve.ResolveCache$2.get(ResolveCache.java:108)
 at com.intellij.psi.impl.source.resolve.ResolveCache.resolveWithCaching(ResolveCache.java:182)
 at com.intellij.psi.impl.PsiImplUtil.multiResolveImpl(PsiImplUtil.java:787)
 at com.intellij.psi.impl.PsiImplUtil.multiResolveImpl(PsiImplUtil.java:776)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.multiResolve(PsiJavaCodeReferenceElementImpl.java:368)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.advancedResolve(PsiJavaCodeReferenceElementImpl.java:361)
 at com.intellij.psi.impl.source.PsiClassReferenceType.resolveGenerics(PsiClassReferenceType.java:140)
 at com.intellij.psi.impl.source.PsiClassReferenceType.resolve(PsiClassReferenceType.java:88)
 at com.intellij.refactoring.util.classMembers.MemberInfoStorage.a(MemberInfoStorage.java:69)
 at com.intellij.refactoring.util.classMembers.MemberInfoStorage.buildSubClassesMap(MemberInfoStorage.java:58)
 at com.intellij.refactoring.util.classMembers.MemberInfoStorage.a(MemberInfoStorage.java:73)
 at com.intellij.refactoring.util.classMembers.MemberInfoStorage.buildSubClassesMap(MemberInfoStorage.java:58)
 at com.intellij.refactoring.util.classMembers.MemberInfoStorage.a(MemberInfoStorage.java:73)
Java stack trace...
"
https://youtrack.jetbrains.com/issue/IDEA-142361/Extract-Variable-in-lambda-expression-fails,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/6804eceb62d0690b5e666a56d846f615cef20739,flow analysis issue,"Extract Variable in lambda expression fails
In the following snippet extracting variable for ""text.length() - 1"" fails:class Test {
  public void doTest() {
    String text = ""xxx"";
    Runnable runnable = () -> Test.this.toVoid(text.length() - 1);
  }

  private void toVoid(Object o) {
  }
} After extraction:class Test {
  public void doTest() {
    String text = ""xxx"";
    Runnable runnable = () -> {
      int i = i;
      Test.this.toVoid(i);
    };
  }

  private void toVoid(Object o) {
  }
} IU-142.3030
"
https://youtrack.jetbrains.com/issue/IDEA-142350/Change-Signature-Default-values-are-used-inside-of-methods-overriding-callers-chosen-for-parameter-propagation,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,change method signature,https://github.com/JetBrains/intellij-community/commit/51af5a631242524a80626ce9d1907a0a53c8ea50,ast rewrite issue,"Change Signature: Default values are used inside of methods overriding callers chosen for parameter propagation
Suppose I have the following code in Java:class A {
    public void foo() {

    }

    public void bar() {
        foo();
    }
}

class B extends A {
    public void foo() {

    }

    public void bar() {
        foo();
        super.foo();
    }
} Apply Change Signature to A.foo(), add new integer parameter with default value and choose A.bar() (or B.bar()) to propagate parameters to. The result is:class A {
    public void foo(int n) {

    }

    public void bar(int n) {
        foo(n); // OK
    }
}

class B extends A {
    public void foo(int n) {

    }

    public void bar(int n) {
        foo(1); // n is not passed to `foo`, default value is used instead. Expected `foo(n)`
        super.foo(n); // OK
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-142378/Cannot-delete-refactor-a-type-variable-for-a-generic-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/1aea1b76e711d38369a45638c698d65426b62865,Incorrect Type Resolving,"Cannot delete-refactor a type variable for a generic method?
If I have a generic method:    <T> void foo(String s) { ... }where T is unused, I cannot use the change-signature refactor to delete the unused type variable (the way I can with a class declaration.)  I can do a safe-delete on T, but then it is not deleted from methods that override this method in subclasses.
"
https://youtrack.jetbrains.com/issue/IDEA-90322/Cannot-use-Extract-Variable-inside-string-containing-injected-language,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,special string,not available,extract variable,https://github.com/JetBrains/intellij-community/commit/9558ec4df46e77acb65fd06035e052b2bb8de476,selection parsing issue,"Cannot use Extract Variable inside string containing injected language
Create a string containing an injected language, such as:String[] parts = someString.split("",|<caret>\t"");Kotlin detectedor:    new org.springframework.jdbc.core.JdbcTemplate().queryForInt(""<caret>select something from cool_table"");Kotlin detectedMove the cursor to the position specified by ""<caret>"".Hit Ctrl+Alt+V.Expected: Offer to extract the string into a variable.Actual: IDEA selects the whole line and complains that it is not an expression.
"
https://youtrack.jetbrains.com/issue/IDEA-90740/Inline-refactoring-fails-to-run-when-it-clearly-could,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/4580e8da2ab01d15208472b93fdc4732fe57410f,overly strong preconditions,"Inline refactoring fails to run when it clearly could
Consider this sample code:    public void testInlineRefactoring() {
        int[] array = new int[10];
        int index = computeIndex();
        array[index] = 22;
    }

    private int computeIndex() {
        return 0;
    } If you attempt to use the ""inline"" refactoring on the local variable called ""index"", Intellij will refuse to complete the refactoring.  It says, ""Cannot perform refactoring. Variable 'index' is accessed for writing.""It should rewrite the line as:    public void testInlineRefactoring() {
        int[] array = new int[10];
        array[computeIndex()] = 22; // the right-hand side of 'index' assignment is inlined here
    }

    private int computeIndex() {
        return 0;
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-112570/Extract-Method-from-statement-lambda-does-not-take-parameters-from-enclosing-scope,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/47262762d20b9346f6209e17967f09e8b44aa106,flow analysis issue,"Extract Method from statement lambda does not take parameters from enclosing scope
public static void changeColorAndMakeStringOfOldColors(List<Shape> shapes, Color newColor, StringBuilder stringBuilder) {
        shapes.forEach(shape -> {
            <selection>stringBuilder.append(shape);
            shape.setColor(newColor);</selection>
        });
    }Kotlin detectedExtract Method offers shape as parameter, but not newColor or stringBuilder.
"
https://youtrack.jetbrains.com/issue/IDEA-91288/Inline-Refactoring-should-not-be-allowed-for-variables-initialized-with-condition,Minor,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/a9d8837b82827bcbaa99ee7f75424966d7336d40,ast rewrite issue,"Inline Refactoring should not be allowed for variables initialized with condition
Build 112.236Consider the following code snip:Integer iii = flag ? 1 : 2;
iii.byteValue(); Inline Refactoring is allowed for iii and results with invalid code.
"
https://youtrack.jetbrains.com/issue/IDEA-90390/Inline-variable-performed-incorrectly-for-return-inside-try,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,try catch,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/2b84533a1fe927a76fcadf073ae7585926ea048a,overly weak preconditions,"Inline variable performed incorrectly for return inside try
Original code:        private static InputStream getInputUnchecked(InputSupplier<InputStream> inputSupplier)
        {
            InputStream in;
            try {
                in = inputSupplier.getInput();
            }
            catch (IOException e) {
                throw Throwables.propagate(e);
            }
            return in;
        } Inlining the variable produces the following incorrect code:            try {
            }
            catch (IOException e) {
                throw Throwables.propagate(e);
            }
            return inputSupplier.getInput(); 
"
https://youtrack.jetbrains.com/issue/IDEA-143340/Inline-lambda-variable-may-produce-uncompilable-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/67bfb2b357c8744348ef0ee5fd06e1f5bbfe0a2c,ast rewrite issue,"Inline lambda variable may produce uncompilable code
142.snapshot from 31.07.15InvocationHandler handler = (proxy, method, args1) -> null;
        Reflect proxy = (Reflect) Proxy.newProxyInstance(
                            Reflect.class.getClassLoader(),
                            new Class[] { Reflect.class },
                            handler);Kotlin detectedinline handler variable, get code with the error:Reflect proxy = (Reflect) Proxy.newProxyInstance(
                            Reflect.class.getClassLoader(),
                            new Class[] { Reflect.class },
                (proxy, method, args1) -> null); // error, proxy is already definedKotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-93084/Invert-Boolean-for-class-field-renames-corresponding-constructor-parameter-incorrectly,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,convert boolean,https://github.com/JetBrains/intellij-community/commit/bf1cc2576fccd6140380ef81109141125337f781,ast rewrite issue,"""Invert Boolean"" for class field renames corresponding constructor parameter incorrectly
Consider the following snippet.  class AccessChecker {
    private final boolean myMustNotAccess;

    public AccessChecker(boolean mustNotAccess) {
      myMustNotAccess = mustNotAccess;
    }
  }  Place the caret on myMustNotAccess and invoke ""Invert Boolean."" Give it a new name, myMustAccess. A dialog pops up with a suggestion to also rename constructor parameter mustNotAccess to mustAccess. Select the checkbox and press OK.Expected: constructor parameter is named mustAccess.Observed: constructor paremeter is named myMustAccess, which coincides with the name of the field.
"
https://youtrack.jetbrains.com/issue/IDEA-92815/Extract-method-refactoring-with-Fold-parameters-is-too-clever-breaks-functioning-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options,behavior change,extract method,https://github.com/JetBrains/intellij-community/commit/bfef30ff032724ef8bb3f7d43d261092c911c42f,Incorrect Type Resolving,"Extract method refactoring with ""Fold parameters"" is too clever - breaks functioning code
Consider the following code:                Object[] array = ...;                if (someCondition) {                    // assert array.length == 1;                    System.out.println(array[0]);                } else {                    // assert array.length == 0;                    System.out.println(""Nothing"");                                    }Now select the entire if statement and extract a method.The result is                doSomething(someCondition, array[0]);and doSomething() is created as            private void doSomething(boolean someCondition, Object x) {                if (someCondition) {                    // assert array.length == 1;                    System.out.println(x);                } else {                    // assert array.length == 0;                    System.out.println(""Nothing"");                }            }But this obviously breaks code. Of course this does not happen if you have the assert statements in place, or if you remember to uncheck ""Fold parameters"". But that new feature is checked by default and no visual warnings are given to the user that it may change the behavior of the code.And those who have been using Intellij IDEA refactorings for a long time are at a disadvantage here, because they are more likely to use Ctrl+M without deliberation.
"
https://youtrack.jetbrains.com/issue/IDEA-114908/Moving-a-static-method-and-static-inner-class-creates-broken-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,inner class,crash,move class to upper level,https://github.com/JetBrains/intellij-community/commit/7b3af34395bbabe246cc9d639dff8a0e2490de57,flow analysis issue,"Moving a static method and static inner class creates broken code
Create the following classesclass Foo {

    static void foo() {
    }

    static class Bar {
        void foo() {
            Foo.foo();
        }
    }
}

class Baz {
}  Put the caret on Foo.foo() Invoke Refactor -> Move Select foo() and Bar in the list of members Enter Baz as the destination classThis is the resultclass Foo {

}

class Baz {
    static void foo() {
    }

    static class Bar {
        void foo() {
            foo();
        }
    }
} Bar.foo() calls itself but it should call Baz.foo(). The generated code would recurse infinitely and overflow the stack.
"
https://youtrack.jetbrains.com/issue/IDEA-144043/Pull-Members-Up-refactoring-breaks-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,pull members up,https://github.com/JetBrains/intellij-community/commit/3d5df4668dd718f944887215d181e8350521af08;https://github.com/JetBrains/intellij-community/commit/9ce5f869de988ee4e164f9f54632ba11c9806e9a,ast rewrite issue,"""Pull Members Up"" refactoring breaks code
When pulling a method up to a super class and making it abstract, the public modifier disappears. The breaks the code when the two classes are in different packages. Possibly this is a consequence of the changes made for IDEA-135292.package a;
public class A {}

package b;
public class B extends A {
  public void m() {} // pull me up and make abstract

  void n() {
    new A();
  }
} Note also that class A is made abstract silently, which breaks the instantiation in n(). I at least expected a warning that this might happen.
"
https://youtrack.jetbrains.com/issue/IDEA-144369/Extract-delegate-converts-field-to-foo.field-foo.field-1,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,unnecessary change,extract delegate,https://github.com/JetBrains/intellij-community/commit/eb50c82b985a090b7c57add19e3a1002f9091782,ast rewrite issue,"""Extract delegate"" converts field++ to foo.field = foo.field + 1
Suppose class A has a numeric field called val, and I extract this into class B using Extract Delegate.  Then IDEA seems to change code such asval++;Kotlin detectedtob.val = b.val + 1;Kotlin detectedwhere b is the new field of type B, when I'd expect to seeb.val++; 
"
https://youtrack.jetbrains.com/issue/IDEA-93582/Moving-more-than-one-static-method-at-a-time-leaves-broken-calls-between-them.,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,move method,https://github.com/JetBrains/intellij-community/commit/75335192ab42d9c71434ae7f48e775d0cc7bcea3,ast rewrite issue,"Moving more than one static method at a time leaves broken calls between them.
interface Eff<A, B> {        B f(A a);    }    abstract class POne<A> {        abstract A _1();         static <A> POne<Hooray<A>> sequence(final Hooray<POne<A>> as) {            return new POne<Hooray<A>>() {                public Hooray<A> _1() { return as.map(POne.<A>__1());                }            };        }        static <A> Eff<POne<A>, A> __1() {            return new Eff<POne<A>, A>() {                public A f(final POne<A> p) { return p._1();                }            };        }    }    final class ProductOne {     }    final class Hooray<A> {        public <B> Hooray<B> map(final Eff<A, B> f) {            return null;        }    }I select the two static methods __1 and sequence in POne, and press F6 to move them.  I select ProductOne as the target, and now ProductOne looks like:    final class ProductOne {        static <A> POne<Hooray<A>> sequence(final Hooray<POne<A>> as) {            return new POne<Hooray<A>>() {                public Hooray<A> _1() { return as.map(<A>__1());                }            };        }        static <A> Eff<POne<A>, A> __1() {            return new Eff<POne<A>, A>() {                public A f(final POne<A> p) { return p._1();                }            };        }    }The innermost return in sequence is not valid Java syntax, <A>__1(), it needs to be ProductOne.<A>__1().  IDEA doesn't even detect it as a problem, it doesn't appear red.  Maven throws a fit on it.
"
https://youtrack.jetbrains.com/issue/IDEA-93741/Move-static-member-does-not-update-static-imports,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,overloaded method,compile error,Move Static Members,https://github.com/JetBrains/intellij-community/commit/5516da73c78277f66419cb05b2a4cbd6d85598d5,flow analysis issue,"Move static member does not update static imports
The possible cause is that I moved two overloaded methods at once
"
https://youtrack.jetbrains.com/issue/IDEA-131240/Deleting-an-unused-overloaded-static-method-removes-wrong-static-import,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,overloaded method,compile error,delete method,https://github.com/JetBrains/intellij-community/commit/f9550d45309bd0e33c1825e70a6999796a303566,flow analysis issue,"Deleting an unused overloaded static method removes wrong static import
Suppose we have the following overloaded static methods:package staticimport;

public class Util {
    public static void check(int i) {}
    public static void check(String s) {}
} Then we use one of them as a static import:package staticimport;

import static staticimport.Util.check;

public class Importer {
    public static void test() { check(""hello""); }
} First bug: If we go to Util, it shows both methods as used (or rather, it doesn't show the int version as unused).Second bug: Then if we delete the int version, it removes the static import from Importer, leaving the code in a broken state:package staticimport;

public class Importer {
    public static void test() { check(""hello""); }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-144265/Convert-to-Instance-Method-breaks-assignments-to-instance-variable-when-there-is-a-method-parameter-with-the-same-name,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,convert to instance method,https://github.com/JetBrains/intellij-community/commit/03ab26830f5e9f1ff8712f006917f22fd35124bd,Incorrect Type Resolving,"""Convert to Instance Method"" breaks assignments to instance variable when there is a method parameter with the same name
Given the following code:public class Foo {

    public String bar;

    public static void setBar(Foo foo, String bar) {
        foo.bar = bar;
    }
} When you invoke ""Convert to Instance Method"" on setBar, then it produces this bad code:public class Foo {

    public String bar;

    public void setBar(String bar) {
        bar = bar;
    }
} The expected correct code would be:public class Foo {

    public String bar;

    public void setBar(String bar) {
        this.bar = bar;
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-131261/Invert-Boolean-works-incorrectly-in-case-of-a-recursive-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,recursive method,behavior change,invert boolean,https://github.com/JetBrains/intellij-community/commit/cd02a08a010c3b3db34dd5e08c1c6a758cb3ca82,overly weak preconditions,"Invert Boolean works incorrectly in case of a recursive method
public class Main {
    static void foo(int i, boolean b) {
        System.out.println(b);
        if (i > 0) {
            foo(i - 1, b);
        }
    }

    public static void main(String[] args) {
        foo(3, true);
    }
} This code prints true true true true.Invert the boolean parameter of foo and the result is:public class Main {
    static void foo(int i, boolean d) {
        System.out.println(!d);
        if (i > 0) {
            foo(i - 1, !d);  // <-- note wrong negation here
        }
    }

    public static void main(String[] args) {
        foo(3, false);
    }
} This code prints true false true false, which differs from the original result.
"
https://youtrack.jetbrains.com/issue/IDEA-81323/Move-method-in-the-class-with-same-name-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,move method,https://github.com/JetBrains/intellij-community/commit/14710359c5f76f65bdb79c4c239907b4250f1aa9,ast rewrite issue,"Move method in the class with same name method
Source.javaclass Source {
  void usage() {
    Target.foo(1);
    foo(""one"");
  }

  private static void foo(String x){}
} Target.javaclass Target {
  public static void foo(int x){}
} Try to move method foo into Target class with escalate visibilityThe result is:class Target {
  public static void foo(int x){}
  private static void foo(String x){} //should be at least package-local
}
 
"
https://youtrack.jetbrains.com/issue/IDEA-81418/Type-migration-issue,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,type migration,https://github.com/JetBrains/intellij-community/commit/1842922b0a37500f67b199388e10e11fa916b26a;https://github.com/JetBrains/intellij-community/commit/92f10aa629ca8d54e099ec1b38b8e75f2518a9b4,Incorrect Type Resolving,"Type migration issue
if you have multiple variables of the same type defined in one line, the Type Migration option on refactors the first variables accessors and mutators.given the following example, after the refactor to a type of Integer the setBar() and getBar() will still be of type Long.private Long foo, bar;

public Long getFoo() {
  return foo;
}

public void setFoo(Long foo) {
  this.foo = foo;
}

public Long getBar() {
  return bar;
}

public void setBar(Long bar) {
  this.bar = bar;
}
 
"
https://youtrack.jetbrains.com/issue/IDEA-81430/Introduce-variable-does-not-insert-this-class-qualifier-in-front-of-field-references,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options,behavior change,introduce variable,https://github.com/JetBrains/intellij-community/commit/4188ab657c94c5dead5449c0a1ce041c70a5871e,ast rewrite issue,"Introduce variable does not insert this/class qualifier in front of field references
With ""Enable in place mode"" enabled.Before:class X {
  public static final String s = ""s"";

  public static void main(String... args) {
    // introduce variable named s for static field reference s here
    s
  }
} After:class X {
  public static final String s = ""s"";

  public static void main(String... args) {
    // variable 's' might not have been initialized
   final String s = s;
  }
} Expected:class X {
  public static final String s = ""s"";

  public static void main(String... args) {
    // reference to static field 's' qualified with class 
    final String s = X.s;
  }
} The problem does not occur when ""Enable in place mode"" is disabled
"
https://youtrack.jetbrains.com/issue/IDEA-81427/Rename-inserts-this-qualifier-before-static-field-reference,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,rename variable,https://github.com/JetBrains/intellij-community/commit/edbf9c3db050d0a5baeefc6f8ae75b4c3afeb6ab,ast rewrite issue,"Rename inserts this qualifier before static field reference
Before:class X {
  public static final String s = ""s"";

  public static void main(String... args) {
    String s1 = s; // rename s1 to s (Shift+F6)
  }
} After:class X {
  public static final String s = ""s"";

  public static void main(String... args) {
    String s = this.s; // 'X.this' cannot be referenced from a static context
  }
} Expected:class X {
  public static final String s = ""s"";

  public static void main(String... args) {
    String s = X.s; // use class name as qualifier
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-91985/Extract-method-does-not-work-when-a-comment-is-selected-at-the-end-of-the-statements,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,not available,extract method,https://github.com/JetBrains/intellij-community/commit/4347e15507fbdc8709d9b5156a07b64e789e9808,selection parsing issue,"Extract method does not work when a comment is selected at the end of the statements
I have following code:double paymentSaveAmount = solution.getValue(i + 1, 0);   // todo fix this When I select solution.getValue(i + 1, 0);   // todo fix this  for method extraction, IDEA warns that it can not be done, because selected block is not a set of statements or an expression. But when I deselect // todo fix this  it just works.
"
https://youtrack.jetbrains.com/issue/IDEA-142867/Refactor-Rename-only-current-method-keeps-Override-annotation,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,compile error,rename method,https://github.com/JetBrains/intellij-community/commit/5071ef8aeb357abbb30e24d82847349f98d550c7,ast rewrite issue,"Refactor / Rename only current method keeps @Override annotation
Provide an overriding Java method with @Override annotation:class SubSon {
    public void doMyOwn() {}
}
class GrandSon extends SubSon {
    @Override public void doMyOwn() { super.doMyOwn(); }
}  Put the caret on GrandSon.doMyOwn() method, Refactor / Rename, ask to rename only current method, not base.Result: the method is renamed, but the annotation is kept, the code is not compilable.142.3230.1.
"
https://youtrack.jetbrains.com/issue/IDEA-82103/Move-Method-breaks-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,move method,https://github.com/JetBrains/intellij-community/commit/5fa5c0f5985bfc34e167a5d3c5827a8dd035e8c2,ast rewrite issue,"Move Method breaks code
Beforeclass Flim {
    Flam flam = new Flam();

    void beep() {}

    public static void main(String[] args) {
        Flim flim = new Flim();
        flim.beep();
    }
}

class Flam {
} After Refactor->Move of beepclass Flim {
    Flam flam = new Flam();

    public static void main(String[] args) {
        Flim flim = new Flim();
        flam.beep();
    }
}

class Flam {
    void beep() {}
} The line ""flam.beep()"" is invalid and should read ""flim.flam.beep()""
"
https://youtrack.jetbrains.com/issue/IDEA-145512/Missing-import-after-inline-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/d9403ffcb7f4ac2d2cd67edf79445232aa085fcc,Incorrect Type Resolving,"Missing import after inline method
Two files:import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

import static java.util.stream.Collectors.toMap;

class Issue {
    public static void filterMap() {
        new HashMap<Long, Set<Integer>>()
                .entrySet()
                .stream()
                .collect(toMap(Entry::getKey, Entry::getValue));
    }
} public class WithMethod {
    public static void main(String[] args) {
        Issue.filterMap();
    }
} Try to inline filterMap method call in WithMethod.Expected resultAll method references are resolved. No new import needimport java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;

import static java.util.stream.Collectors.toMap;

public class WithMethod {
    public static void main(String[] args) {
        new HashMap<Long, Set<Integer>>()
                .entrySet()
                .stream()
                .collect(toMap(Entry::getKey, Entry::getValue));
    }
} Actual resultMissing import for Map.Entryimport java.util.HashMap;
import java.util.Set;

import static java.util.stream.Collectors.toMap;

public class WithMethod {
    public static void main(String[] args) {
        new HashMap<Long, Set<Integer>>()
                .entrySet()
                .stream()
                .collect(toMap(Entry::getKey, Entry::getValue));
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-82286/Inline-superclass-breaks-code-on-inlining-interface-into-abstract-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline interface,https://github.com/JetBrains/intellij-community/commit/3c5d7a568d5a1140554e6be9ee28a181241389e2,ast rewrite issue,"Inline superclass breaks code on inlining interface into abstract class
When the (Java) interface methods do not have the (redundant) modifiers ""public abstract"".Before:abstract class StraightLine implements Inline {
}

interface Inline {

    void go(); // inline this method
} After:abstract class StraightLine {
    void go(); // broken code here, expected ""public abstract""
} 
"
https://youtrack.jetbrains.com/issue/IDEA-110654/Change-Signature-inserts-unnecessary-new-line-in-comment-block,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/2bcd0fb291ab0ff7305b128a3ba69949a04b40e0,ast rewrite issue,"Change Signature inserts unnecessary new line in comment block
If the java doc of a method has at least @return and @param then the refactoring Change Signature inserts every time a new line above the first @param.This does not happen if @return is not available or no @param is available.before    /**
     * @param a
     * @return
     */
    private void method(int a) {
    } after    /**
     *
     * @param a
     * @return
     */
    private void method(int a) {
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-82661/change-type-signature-refactoring-results-in-the-bad-code-when-that-type-is-used-in-the-instanceof,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,instanceof,compile error,change class signature,https://github.com/JetBrains/intellij-community/commit/7bd0e144e9a245222375c6df12c53b425ce64a44,flow analysis issue,"change type signature refactoring results in the bad code when that type is used in the instanceof
Thispublic class ChangeClassSignatureAddParameter {

    public void test( Object object ) {
        if ( object instanceof MyClass ) {
            MyClass myClass = ( MyClass ) object;
        }
    }

    public class MyClass {

    }

} after refactoring MyClass and adding a type parameter becomes thatpublic class ChangeClassSignatureAddParameter {

    public void test( Object object ) {
        if ( object instanceof MyClass<Object> ) { // should be left unchanged as ""instanceof MyClass""
            MyClass<Object> myClass = ( MyClass<Object> ) object;
        }
    }

    public class MyClass<T> {

    }

} 
"
https://youtrack.jetbrains.com/issue/IDEA-145795/Inline-method-refactoring-can-change-behavior.,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,inline method,https://github.com/JetBrains/intellij-community/commit/4afad1703cfd29ce34a23ccd13a0ec7223ad8bf9,ast rewrite issue,"""Inline method"" refactoring can change behavior.
This example runs and prints ""prefix 4 suffix""public class Example
{
    public static void main(String[] args)
    {
        int x = 2;
        System.out.println(getString(x + 2, "" suffix""));
    }

    private static String getString(int number, String suffix)
    {
        return ""prefix "" + number + suffix;
    }
} After applying the ""inline method"" refactoring to getString(), I get the following code.public class Example
{
    public static void main(String[] args)
    {
        int x = 2;
        System.out.println(""prefix "" + x + 2 + "" suffix"");
    }
} It's missing parens around x + 2, so it prints ""prefix 22 suffix"".
"
https://youtrack.jetbrains.com/issue/IDEA-146250/Refactoring-variable-out-of-lambda-expression-places-variable-outside-of-the-lambda,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/0b63f8295ccead804ee56982a0acade5156447bf,flow analysis issue,"Refactoring variable out of lambda expression places variable outside of the lambda
In this code, if you try to extract method.getReturnType() and have it replace both occurrences, the variable is placed outside the lambda:    import java.lang.reflect.Method;
    import java.util.Collection;
    import java.util.Map;
    import java.util.stream.Collectors;
    import java.util.stream.Stream;
    
    class LambdaTest
    {

        //~ Methods ------------------------------------------------------------

        public void foo(Class<?> cls)
        {
            Stream.of(cls.getMethods())
                  .filter(method ->
                          Collection.class.isAssignableFrom(
                              method.getReturnType())
                          || Map.class.isAssignableFrom(method.getReturnType()))
                  .collect(Collectors.<Method>toList());
        }
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-117252/Extract-variable-bug,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,foreach;input options,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/19ac5df6f26287c0710cd3afc0432e251114fa13,Incorrect Type Resolving,"Extract variable bug
Hi.I am using Intellij Idea 13 EAP build 132.947.I noticed that extract variable feature doesn't consider scope in which it was called.I wrote a small sample to demonstrate it.Beforepublic class ExtractVariableSample {

  public static void main(String[] args) {
    Collection<String> strings = new ArrayList<>();
    new Object() {
      public void foo(String s) {
        System.out.println(s.hashCode());
      }
    };
    for (String s : strings) {
      System.out.println(s.hashCode());
    }
  }
} When I select ""s.hashCode()"" in ""for"" loop and press alt + cmd + v (extract variable), Idea suggest to replace 2 code occurrences. And if I agree, it produces code that can not be compiled.Afterpublic class ExtractVariableSample {

  public static void main(String[] args) {
    Collection<String> strings = new ArrayList<>();
    final int x = s.hashCode();
    new Object() {
      public void foo(String s) {
        System.out.println(x);
      }
    };
    for (String s : strings) {
      System.out.println(x);
    }
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-146332/Extract-method-produces-invalid-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,try catch,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/cc02620e6df25133d9dcf1c39563b5b66ba482e3,flow analysis issue,"Extract method produces invalid code
Go to DumbServiceImpl.updateFinished, select try-finally statement, extract a method. The resulting if (extracted()) break; is clearly incorrect at the end of a method body.
"
https://youtrack.jetbrains.com/issue/IDEA-132706/Extract-method-incorrectly-replaces-break-with-return,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,extract method,https://github.com/JetBrains/intellij-community/commit/350c0b2a0ac82bbeac8a859b1c7f0ad6c63c8e59,ast rewrite issue,"Extract method incorrectly replaces break with return
When running extract method over a break statement, return is generated instead of break:Example:package x;

import java.util.List;

public class IntellijFail {
  int a = 1;
  public List<Pojo> things;

  void fool() {
    while(a == 1) {
      Pojo x = things.get(0); // from here

      if(x.it > 0.5) {
        break;
      }

      things.remove(x); // to here

      double y = 2 * x.it;
    }
    a = 2;
  }

  static class Pojo {
    double it;
    Pojo(double w) {
      it = w;
    }
  }
} result:package x;

import java.util.List;

public class IntellijFail {
  int a = 1;
  public List<Pojo> things;

  void fool() {
    while(a == 1) {
      Pojo x = getPojo();
      if (x == null) {
        return;   // BUG: THIS SHOULD BE break
      }

      double y = 2 * x.it;
    }
    a = 2;
  }

  private Pojo getPojo() {
    Pojo x = things.get(0); // from here

    if(x.it > 0.5) {
      return null;
    }

    things.remove(x); // to here
    return x;
  }

  static class Pojo {
    double it;
    Pojo(double w) {
      it = w;
    }
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-133095/Extract-method-refactoring-produces-incorrect-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/9d9caf96205190e88e1a5be44b9392419f4f5233,flow analysis issue,"Extract method refactoring produces incorrect code
I have the following Java code  public static List<Boolean> getLociEnrichment(final InputQuery<BedTrackData> query,
                                                final GenomeQuery genomeQuery,
                                                final BINARIZATION binarization,
                                                final int binSize,
                                                final List<Location> locations) {
    final List<Boolean> bins = binarization.process(query, genomeQuery, binSize);
    final GenomeBins genomeBins = new GenomeBins(genomeQuery, binSize);
    return locations.stream().map(l -> {
      final Chromosome chromosome = l.getChromosome();
      final int offset = genomeBins.getOffset(chromosome);
      final int startOffset = offset + l.getStartOffset() / binSize;
      final int endOffset = offset + l.getEndOffset() / binSize;
      // compute max vote
      int positives = 0;
      for (int i = startOffset; i < endOffset; i++) {
        if (bins.get(i)) {
          positives++;
        }
      }
      return positives > (endOffset - startOffset) / 2;
    }).collect(Collectors.toList());
  } I select the following piece of code and expect it to be extracted as method with boolean return value.final Chromosome chromosome = l.getChromosome();
      final int offset = genomeBins.getOffset(chromosome);
      final int startOffset = offset + l.getStartOffset() / binSize;
      final int endOffset = offset + l.getEndOffset() / binSize;
      // compute max vote
      int positives = 0;
      for (int i = startOffset; i < endOffset; i++) {
        if (bins.get(i)) {
          positives++;
        }
      }
      return positives > (endOffset - startOffset) / 2; Extract method dialog prompts to create method with void return type, which leads to incorrect code.
"
https://youtrack.jetbrains.com/issue/IDEA-83723/Intruduce-constant-refactoring-fails-on-specific-string,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,special string,fail to refactoring,introduce constant,https://github.com/JetBrains/intellij-community/commit/13125689278e41d6e047ca71a88d930bf00746bf,flow analysis issue,"Intruduce constant refactoring fails on specific string
When introducing string constant from text in square braces with text after eg.:String asd = ""[this_text_with_braces_should_be_selected]aaaaaaaaaaaaa$"";Idea selects alot of wrong one letter candidates for replacement. Even in code text, not only in another strings. If proceed with replacement code became a mess.
"
https://youtrack.jetbrains.com/issue/IDEA-117634/Unexpected-Type-Migration-warning,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,incorrect warning message,type migration,https://github.com/JetBrains/intellij-community/commit/7cecc22ed36287effa7846a902ef7f6d4d92a054;https://github.com/JetBrains/intellij-community/commit/ba4fcac2a496515007edffd89f2562ec6b0f6e8a,overly strong preconditions,"Unexpected Type Migration warning
The following code produces the warning ""Cannot convert type of expression set from java.util.Set<java.lang.String> to java.util.Collection<java.lang.String>"" when I try to migrate the type. I see no reason for the warning and ignoring it completes the migration without any problems.class X {
   Set<String> mySet = new HashSet();
  void foo(Set<String> set) { // invoke Type Migration on the ""set"" parameter
    mySet.retainAll(set);
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-146787/Refactor-Extract-constant-places-constant-in-wrong-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract constant,https://github.com/JetBrains/intellij-community/commit/2f4fddec5a17a95fe5a0baa708010843ee5cb946,ast rewrite issue,"Refactor / Extract constant places constant in wrong class
When using ""Extract constant"" on an expression coming from an inner static class, the constant is placed in that static inner class instead of the class in which it is used.
"
https://youtrack.jetbrains.com/issue/IDEA-83713/Inline-variable-incorrect-result-for-variables-that-are-initialized-by-a-static-method-call,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/c6603783575dc406c4abe97ed2023459ed64c387,ast rewrite issue,"Inline variable: incorrect result for variables that are initialized by a static method call
Create the following two source files:Demo.javapublic class Demo
{

   public static void main(String[] args)
   {
      System.out.println(Source.LISTENER);
   }

} Source.javapublic class Source
{
   public static final ActionListener LISTENER = mock(ActionListener.class);
} Go to the LISTENER variable in Source.java and select Refactor > Inline... Inline all occurencesExpected resultExpected Resultimport static org.mockito.Mockito.mock;

import java.awt.event.ActionListener;

public class Demo
{

    public static void main(String[] args)
    {
        System.out.println(mock(ActionListener.class));
    }

} Actual resultResult of inline variable operationimport java.awt.event.ActionListener;

public class Demo
{

    public static void main(String[] args)
    {
        System.out.println(Source.mock(ActionListener.class));
    }

} IDEA does not add the required static import and just adds the mock method to the original occurences.
"
https://youtrack.jetbrains.com/issue/IDEA-84207/Refactor-Move-method-bug,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,move method,https://github.com/JetBrains/intellij-community/commit/6482929c2dde241dfee63af6573a5a58db735240,ast rewrite issue,"Refactor / Move method bug
I try to move a method from its original class to another class by using the GUI of the refactoring tool. I explain for you the situation by the following example:The initial situation (before moving the method m):   The orginal class of the method m:       class A{           void n(B b){               m(b);           }            void m(B b){                 System.out.print(""display for me the shape""+this +"" "" + b.getI() + ""times"");           }        }    The target class of the method m:       class B{           private final int i;           public B(int i) {                this.i = i;           }           public int getI() {           return i;           }      }--------- After performing the refactoring operation move, I get the following result:----- The class A      class A{           void n(B b){               b.m(this);           }        } The class B (here there is a problem to be explaining in the buttom)       class B{           private final int i;           public PrintVisitor(int i) {                 this.i = i;            }           public int getI() {            return i;            }           void m(A a){                 System.out.print(""display for me the shape""+ a +"" "" + b.getI() + ""times"");           }      }----------Discussion:    The problem appears in the class B and exactly in the method expresssion b.getI(), because in the right case the tool should detect automatically when moving the method that it will be getI() instead of b.getI() when the method m takes place in the class B.My question is: is this a bug or just an ill use from me and if this is a bug I ask if it is possible to correct it because I need to apply the operation move on the case presented above.
"
https://youtrack.jetbrains.com/issue/IDEA-96962/Inline-method-to-super-constructor-call-break-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/f6e0f4bd7a3c886daddba58cc585bfd430324642,overly weak preconditions,"Inline method to super constructor call break code
Build: 124.147Some code:public class BBB {
  public BBB(String x) {
  }
}

public class AAA extends BBB {
  public AAA(String x) {
    super(test(x));
  }

  private static String test(String x) {
     String y = x.trim();
     return y.length() > 0 ? y : ""aaaa"";
  }
} Inline call method 'test' into super constructor call break code:public class AAA extends BBB {
  public AAA(String x) {
    String y = x.trim();
    super(y.length() > 0 ? y : ""aaaa"");
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-97203/Change-constructor-signature-add-Exception-break-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/dea70f5fdd099399dbeea45c62f6ae8b401975c4,ast rewrite issue,"Change constructor signature (add Exception) break code
Build: 124.147Some code:public class Base {
  public Base(String name) {
  }
}

public class AAA extends Base {
  public AAA(String name) {
    super(name);
  }
} Change constructor signature (add Exception) break code:public class Base {
  public Base(String name) throws Exception {
  }
}

public class AAA extends Base {
  public AAA(String name) {
    try {
      super(name);
    } catch (Exception e) {
      e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.
    }
  }
} Change method signature (add Exception) works fine.
"
https://youtrack.jetbrains.com/issue/IDEA-118166/Extracting-a-constant-from-annotation-value-does-not-search-for-the-same-value-within-the-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,fail to refactoring,extract constant,https://github.com/JetBrains/intellij-community/commit/0d7a9088b5fe17d76920d502443d0757d1d25d9d,Incorrect Type Resolving,"Extracting a constant from annotation value does not search for the same value within the code
Extracting a constant from annotation value does not search for the same value within the codeSnippet@Model(usages = @Usage(""${__REQUEST_PARAMETERS}""),
  description = ""Defines Request Parameters"",
  descriptionKey = ""tags.models.requestParameters.description""
)
public class SomeClass extends IModel {
   //....
  @Override
  public String getModelName() {
     return ""__REQUEST_PARAMETERS"";
  }
} For example I'm selecting a string ""__REQUEST_PARAMETERS"" in annotation @Usage and extracting a constant by using Ctrl+Alt+C hot key. But I expect that IDE will detect this string in getModelName() method and will ask me to replace it also like if I'm extracting a method. But IDEA does not.Thank you.
"
https://youtrack.jetbrains.com/issue/IDEA-147539/Move-Static-Members-refactor-breaks-switch-statements,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,switch case,behavior change,Move Static Members,https://github.com/JetBrains/intellij-community/commit/25d3334300900f18fb897b6ee030faafef3a9231,ast rewrite issue,"Move Static Members refactor breaks switch statements
Before refactor:/* Constants.java */ 
public class Constants { 
public static final String FOO = ""FOO""; 
}

/* FooConstants.java */ 
public class FooConstants {}

/* Example.java */ 
public class Example { 
public method example(String foo) { 
switch (foo) { 
case Constants.FOO: ... 
} 
} 
} After refactor:/* Constants.java */ 
public class Constants { 
}

/* FooConstants.java */ 
public class FooConstants { 
public static final String FOO = ""FOO""; 
}

/* Example.java */ 
public class Example { 
public method example(String foo) { 
switch (foo) { 
case FOO: ... 
} 
} 
} 
"
https://youtrack.jetbrains.com/issue/IDEA-146900/Make-method-static-with-delegation-breaks-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,make method static,https://github.com/JetBrains/intellij-community/commit/40db0beb8de23768a64bb7a4c2a2cdc20ed45470,ast rewrite issue,"""Make method static"" with delegation breaks code
Please see the screenshots with a sequence to reproduce the problem. After the refactoring, the order of parameters at the call site and in the method declaration do not match. The object parameter is added to the front of the list in the declaration and to the end in the method call.
"
https://youtrack.jetbrains.com/issue/IDEA-85307/Extract-constant-in-interface-adds-private-modifier-to-generated-constant,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract constant,https://github.com/JetBrains/intellij-community/commit/e165e269af3e956a2ad92985d6e661f6925279db,ast rewrite issue,"""Extract constant"" in interface adds ""private"" modifier to generated constant
import com.intellij.util.xml.Attribute;

public interface Test {

  @Attribute(""class"")
  void test();
  
} introduce constant for ""class""118.322
"
https://youtrack.jetbrains.com/issue/IDEA-133947/Replace-with-lambda-refactoring-doesnt-take-synchronized-into-account,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,behavior change,replace with lambda,https://github.com/JetBrains/intellij-community/commit/e90b046aa4ba2460a84d46bb8a03b370cd65b8f8,overly weak preconditions,"Replace with lambda refactoring doesn't take synchronized into account
I have the following code:    IntStream.range(0, myAtomicFormulas.length)
        .parallel()
        .forEach(i -> enumerateWithMax(i, myM, myK, new Consumer<Formula>() {
          @Override
          public synchronized void accept(final Formula formula) {
            result.add(formula);
          }
        }));Kotlin detectedIn this case replace with lambda refactoring produces    IntStream.range(0, myAtomicFormulas.length)
        .parallel()
        .forEach(i -> enumerateWithMax(i, myM, myK, formula -> {
          result.add(formula);
        }));Kotlin detectedWhich is incorrect due to synchronize semantics.
"
https://youtrack.jetbrains.com/issue/IDEA-146229/parameter-name-in-interface-method-is-not-renamed,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,fail to refactoring,rename field,https://github.com/JetBrains/intellij-community/commit/05bf2e75165cee3170e71a3dd6dcc2c852c545ff,ast rewrite issue,"parameter name in interface method is not renamed
interface Foo {
    void setFoo(int foo);
}

class Bar implements Foo {
    int foo;

    @Override
    public void setFoo(int foo) {
        this.foo = foo;
    }
} Place cursor on foo field, rename to bar – IntelliJ suggests ""Rename setter name as well"" – click Yes – it renames everything except parameter name in the interface method, i. e. it remains void setBar(int foo)
"
https://youtrack.jetbrains.com/issue/IDEA-97902/Inline-conditional-expression.-unnecessary-cast-to-boolean,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java ternary conditional,unnecessary change,inline variable,https://github.com/JetBrains/intellij-community/commit/c66e1c07b8fb43b1a11b0fbc139ca9f6055f7be3,ast rewrite issue,"Inline conditional expression. unnecessary cast to boolean
private static void checkModifierIsNotAllowedImpl(@NotNull GrModifierList modifierList,
                                                    @NotNull @GrModifier.GrModifierConstant String modifier,
                                                    @Nullable String message,
                                                    @NotNull AnnotationHolder holder, 
                                                    final boolean explicit) {
    final boolean has = explicit ? modifierList.hasModifierProperty(modifier) : modifierList.hasExplicitModifier(modifier);
    if (has) {
      PsiElement toHighlight = PsiUtil.findModifierInList(modifierList, modifier);
      if (toHighlight == null) toHighlight = modifierList;
      final Annotation annotation = holder.createErrorAnnotation(toHighlight, message);
      annotation.registerFix(new GrModifierFix((PsiMember)modifierList.getParent(), modifierList, modifier, true, false));
    }
  } try to inline 'has' variable I get the following result  private static void checkModifierIsNotAllowedImpl(@NotNull GrModifierList modifierList,
                                                    @NotNull @GrModifier.GrModifierConstant String modifier,
                                                    @Nullable String message,
                                                    @NotNull AnnotationHolder holder,
                                                    final boolean explicit) {
    if ((boolean)(explicit ? modifierList.hasModifierProperty(modifier) : modifierList.hasExplicitModifier(modifier))) {
      PsiElement toHighlight = PsiUtil.findModifierInList(modifierList, modifier);
      if (toHighlight == null) toHighlight = modifierList;
      final Annotation annotation = holder.createErrorAnnotation(toHighlight, message);
      annotation.registerFix(new GrModifierFix((PsiMember)modifierList.getParent(), modifierList, modifier, true, false));
    }
  }
 build 123.91
"
https://youtrack.jetbrains.com/issue/IDEA-147535/refactor-deleting-a-method-argument-retains-javadocs-of-deleted-argument,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/a6bd93a9c79836004c1f6a7076af49f6d79e5df4,ast rewrite issue,"refactor deleting a method argument retains javadocs of deleted argument
system: 1.8.0_40-release-b92x64 Oracle Corporation, Mac OS X(x86_64) v10.11.1 unknown (2560x1600)When I delete a method argument through the refactor dialog, the argument is deleted in the method (and its uses), but the javadoc entry is not. instead it is moved to the top of the list of args.To replicate1. have a method with >1 argument and the javadoc entries for all arguments in order.2. select refactor arguments3. Delete the last argument4. hit apply5. observe that while the argument is gone, it is in the list, now at the top of the arguments.
"
https://youtrack.jetbrains.com/issue/IDEA-98396/Extract-method-insert-casts-in-duplicated-usages,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options;instanceof,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/7228521cd171ca76cc24ecc4cb1c9d9529e12fd2,ast rewrite issue,"Extract method: insert casts in duplicated usages
void foo(Object x) {
  if (x instanceof String) x = ((String)x).substring(1);
  if (x instanceof String) x = <selection>((String)x).substring(1)</selection>;
}Kotlin detectedExtract method from selected expression and agree with duplicated code suggestion. The result will be as follows:  void foo(Object x) {
        if (x instanceof String) x = getSubstring(x); //red code. Cast to String expected
        if (x instanceof String) x = getSubstring((String) x);
    }

    private String getSubstring(String x) {
        return ((String)x).substring(1);
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-97682/Extract-constant-fails-for-Strings-which-contain-XPath-expressions,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,special string,crash,extract constant,https://github.com/JetBrains/intellij-community/commit/f038ae950e06e3de761362bf6788b870ff038415,selection parsing issue,"Extract constant fails for Strings which contain XPath expressions
Hi,I'm unable to use the ""Extract constant"" refactoring for strings which contain an XPath expression, for example:XPathExpression expr = xPath.compile(""/message/controlActProcess/subject/careProvisionEvent/author/location/healthCareFacility/id/@extension"");Ruby detectedIf I move my caret on a random XPath node, let's say ""controlActProcess"", and press Alt-Maj-C, the live template is inserted but the caret is at offset 0 (before the package statement), instead of being inside the ""red box"".In the logs, the following error appears:PsiIdentifier:MESSAGE_CONTROL_ACT_PROCESS_SUBJECT_CARE_PROVISION_EVENT_AUTHOR_LOCATION_HEALTH_CARE_FACILITY_ID_EXTENSION 
java.lang.Throwable
 at com.intellij.openapi.diagnostic.Logger.error(Logger.java:54)
 at com.intellij.openapi.diagnostic.Logger.error(Logger.java:57)
 at com.intellij.idea.IdeaLogger.error(IdeaLogger.java:90)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.a(InplaceRefactoring.java:677)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.buildTemplateAndStart(InplaceRefactoring.java:269)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.performInplaceRefactoring(InplaceRefactoring.java:209)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.access$301(AbstractInplaceIntroducer.java:62)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:223)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduceField.IntroduceConstantHandler.showRefactoringDialog(IntroduceConstantHandler.java:176)
 at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.a(BaseExpressionToFieldHandler.java:192)
 at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler.invokeImpl(BaseExpressionToFieldHandler.java:131)
 at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:465)
 at com.intellij.refactoring.introduceField.BaseExpressionToFieldHandler$3.pass(BaseExpressionToFieldHandler.java:451)
 at com.intellij.refactoring.introduceField.ElementToWorkOn.processElementToWorkOn(ElementToWorkOn.java:126)
 at com.intellij.refactoring.introduceField.IntroduceConstantHandler.invoke(IntroduceConstantHandler.java:72)
 at com.intellij.refactoring.actions.BaseRefactoringAction.actionPerformed(BaseRefactoringAction.java:96)
 at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher$3.performAction(IdeKeyEventDispatcher.java:561)
 at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.processAction(IdeKeyEventDispatcher.java:609)
 at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.d(IdeKeyEventDispatcher.java:464)
 at com.intellij.openapi.keymap.impl.IdeKeyEventDispatcher.dispatchKeyEvent(IdeKeyEventDispatcher.java:208)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:479)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:244)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:163)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:151)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:147)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:139)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:97)
Java stack trace2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - IntelliJ IDEA 12.0  Build #IU-123.72 2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - JDK: 1.7.0_09 2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - VM: Java HotSpot(TM) Client VM 2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - Vendor: Oracle Corporation 2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - OS: Windows 7 2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - Last Action: IntroduceConstant 2012-12-17 15:21:19,624 [18650358]  ERROR - inplace.VariableInplaceRenamer - Current Command: Extract Constant I can extract my constant if I put the caret just before the opening quote, but it's not very convenient...I guess this may also affect strings with other injected languages (RegExps?).ThanksBastien
"
https://youtrack.jetbrains.com/issue/IDEA-97001/Couldnt-finish-Introduce-Field-refactoring,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,crash,introduce field,https://github.com/JetBrains/intellij-community/commit/6391d81307f1946e98a3abe6f8e7620603b8820c,Incorrect Type Resolving,"Couldn't finish Introduce Field refactoring
–I was just extracting a field out of new statement, I forgot to check some checkboxes so I probably did a Cmd+Z, then retried the Introduce Field refactoring, but it just failed and now IntelliJ forbids further refactorings to avoid incomplete refactoring. –I can repeat the process, I have the following codeHere's what is relevant in the IDEA log :        } else if (new AcrossJVMSerializationFeature().isWriteReplace(method)) {
            return new AcrossJVMSerializationFeature().writeReplace(proxy);
        } I want to create a field form the new expression => Cmd+Alt+FI just select the new expression !Then I click right on the checkbox of the popup that says Replace all occurencesThen game over, other refactorings are now impossible, compilation or syntax highlighting is not updated anymore => I must restart IDEA.2012-12-07 21:59:26,136 [12581567]  ERROR - l.source.PsiClassReferenceType - Assertion failed:  
java.lang.Throwable
 at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:98)
 at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:105)
 at com.intellij.psi.impl.source.PsiClassReferenceType.resolveGenerics(PsiClassReferenceType.java:142)
 at com.intellij.psi.impl.source.PsiClassReferenceType.resolve(PsiClassReferenceType.java:92)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.b(JavaCodeStyleManagerImpl.java:397)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.a(JavaCodeStyleManagerImpl.java:291)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableName(JavaCodeStyleManagerImpl.java:229)
 at com.intellij.psi.codeStyle.JavaCodeStyleManager.suggestVariableName(JavaCodeStyleManager.java:122)
 at com.intellij.refactoring.introduceField.IntroduceFieldDialog$2.getSuggestedNameInfo(IntroduceFieldDialog.java:219)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestFieldName(InplaceIntroduceFieldPopup.java:115)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestNames(InplaceIntroduceFieldPopup.java:107)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:56)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:30)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:209)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$3.run(AbstractInplaceIntroducer.java:323)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.restartInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:336)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup$2.itemStateChanged(InplaceIntroduceFieldPopup.java:178)
 at javax.swing.AbstractButton.fireItemStateChanged(AbstractButton.java:2056)
 at javax.swing.AbstractButton$Handler.itemStateChanged(AbstractButton.java:2358)
 at javax.swing.DefaultButtonModel.fireItemStateChanged(DefaultButtonModel.java:440)
 at javax.swing.JToggleButton$ToggleButtonModel.setSelected(JToggleButton.java:255)
 at javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:272)
 at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)
 at java.awt.Component.processMouseEvent(Component.java:6382)
 at javax.swing.JComponent.processMouseEvent(JComponent.java:3275)
 at java.awt.Component.processEvent(Component.java:6147)
 at java.awt.Container.processEvent(Container.java:2083)
 at java.awt.Component.dispatchEventImpl(Component.java:4744)
 at java.awt.Container.dispatchEventImpl(Container.java:2141)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4619)
 at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4280)
 at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4210)
 at java.awt.Container.dispatchEventImpl(Container.java:2127)
 at java.awt.Window.dispatchEventImpl(Window.java:2489)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:704)
 at java.awt.EventQueue.access$400(EventQueue.java:82)
 at java.awt.EventQueue$2.run(EventQueue.java:663)
 at java.awt.EventQueue$2.run(EventQueue.java:661)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:98)
 at java.awt.EventQueue$3.run(EventQueue.java:677)
 at java.awt.EventQueue$3.run(EventQueue.java:675)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.awt.EventQueue.dispatchEvent(EventQueue.java:674)
 at com.intellij.ide.IdeEventQueue.d(IdeEventQueue.java:673)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:494)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:296)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:211)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:201)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:196)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:188)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
Java stack trace2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - IntelliJ IDEA 12.0  Build #IU-123.72 2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - JDK: 1.6.0_37 2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - VM: Java HotSpot(TM) 64-Bit Server VM 2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - Vendor: Apple Inc. 2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - OS: Mac OS X 2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - Last Action: IntroduceField 2012-12-07 21:59:26,139 [12581570]  ERROR - l.source.PsiClassReferenceType - Current Command: Extract Field 2012-12-07 21:59:26,139 [12581570]  ERROR - siJavaCodeReferenceElementImpl - getManager() == null! 
java.lang.Throwable
 at com.intellij.openapi.diagnostic.Logger.error(Logger.java:54)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.multiResolve(PsiJavaCodeReferenceElementImpl.java:393)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.advancedResolve(PsiJavaCodeReferenceElementImpl.java:383)
 at com.intellij.psi.impl.source.PsiClassReferenceType.resolveGenerics(PsiClassReferenceType.java:143)
 at com.intellij.psi.impl.source.PsiClassReferenceType.resolve(PsiClassReferenceType.java:92)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.b(JavaCodeStyleManagerImpl.java:397)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.a(JavaCodeStyleManagerImpl.java:291)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableName(JavaCodeStyleManagerImpl.java:229)
 at com.intellij.psi.codeStyle.JavaCodeStyleManager.suggestVariableName(JavaCodeStyleManager.java:122)
 at com.intellij.refactoring.introduceField.IntroduceFieldDialog$2.getSuggestedNameInfo(IntroduceFieldDialog.java:219)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestFieldName(InplaceIntroduceFieldPopup.java:115)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestNames(InplaceIntroduceFieldPopup.java:107)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:56)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:30)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:209)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$3.run(AbstractInplaceIntroducer.java:323)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.restartInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:336)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup$2.itemStateChanged(InplaceIntroduceFieldPopup.java:178)
 at javax.swing.AbstractButton.fireItemStateChanged(AbstractButton.java:2056)
 at javax.swing.AbstractButton$Handler.itemStateChanged(AbstractButton.java:2358)
 at javax.swing.DefaultButtonModel.fireItemStateChanged(DefaultButtonModel.java:440)
 at javax.swing.JToggleButton$ToggleButtonModel.setSelected(JToggleButton.java:255)
 at javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:272)
 at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)
 at java.awt.Component.processMouseEvent(Component.java:6382)
 at javax.swing.JComponent.processMouseEvent(JComponent.java:3275)
 at java.awt.Component.processEvent(Component.java:6147)
 at java.awt.Container.processEvent(Container.java:2083)
 at java.awt.Component.dispatchEventImpl(Component.java:4744)
 at java.awt.Container.dispatchEventImpl(Container.java:2141)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4619)
 at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4280)
 at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4210)
 at java.awt.Container.dispatchEventImpl(Container.java:2127)
 at java.awt.Window.dispatchEventImpl(Window.java:2489)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:704)
 at java.awt.EventQueue.access$400(EventQueue.java:82)
 at java.awt.EventQueue$2.run(EventQueue.java:663)
 at java.awt.EventQueue$2.run(EventQueue.java:661)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:98)
 at java.awt.EventQueue$3.run(EventQueue.java:677)
 at java.awt.EventQueue$3.run(EventQueue.java:675)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.awt.EventQueue.dispatchEvent(EventQueue.java:674)
 at com.intellij.ide.IdeEventQueue.d(IdeEventQueue.java:673)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:494)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:296)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:211)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:201)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:196)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:188)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
Java stack traceLater in the log : 
java.lang.Throwable
 at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:98)
 at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:105)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.getKind(PsiJavaCodeReferenceElementImpl.java:89)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.getCanonicalText(PsiJavaCodeReferenceElementImpl.java:284)
 at com.intellij.psi.impl.source.PsiClassReferenceType.getCanonicalText(PsiClassReferenceType.java:190)
 at com.intellij.psi.statistics.JavaStatisticsManager.getVariableNameUseKey1(JavaStatisticsManager.java:52)
 at com.intellij.psi.statistics.JavaStatisticsManager.createVariableUseInfo(JavaStatisticsManager.java:39)
 at com.intellij.psi.statistics.JavaStatisticsManager.getVariableNameUseCount(JavaStatisticsManager.java:66)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl$6.compare(JavaCodeStyleManagerImpl.java:898)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl$6.compare(JavaCodeStyleManagerImpl.java:895)
 at java.util.Arrays.mergeSort(Arrays.java:1270)
 at java.util.Arrays.sort(Arrays.java:1210)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.a(JavaCodeStyleManagerImpl.java:903)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableName(JavaCodeStyleManagerImpl.java:230)
 at com.intellij.psi.codeStyle.JavaCodeStyleManager.suggestVariableName(JavaCodeStyleManager.java:122)
 at com.intellij.refactoring.introduceField.IntroduceFieldDialog$2.getSuggestedNameInfo(IntroduceFieldDialog.java:219)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestFieldName(InplaceIntroduceFieldPopup.java:115)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestNames(InplaceIntroduceFieldPopup.java:107)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:56)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:30)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:209)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$3.run(AbstractInplaceIntroducer.java:323)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.restartInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:336)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup$2.itemStateChanged(InplaceIntroduceFieldPopup.java:178)
 at javax.swing.AbstractButton.fireItemStateChanged(AbstractButton.java:2056)
 at javax.swing.AbstractButton$Handler.itemStateChanged(AbstractButton.java:2358)
 at javax.swing.DefaultButtonModel.fireItemStateChanged(DefaultButtonModel.java:440)
 at javax.swing.JToggleButton$ToggleButtonModel.setSelected(JToggleButton.java:255)
 at javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:272)
 at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)
 at java.awt.Component.processMouseEvent(Component.java:6382)
 at javax.swing.JComponent.processMouseEvent(JComponent.java:3275)
 at java.awt.Component.processEvent(Component.java:6147)
 at java.awt.Container.processEvent(Container.java:2083)
 at java.awt.Component.dispatchEventImpl(Component.java:4744)
 at java.awt.Container.dispatchEventImpl(Container.java:2141)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4619)
 at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4280)
 at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4210)
 at java.awt.Container.dispatchEventImpl(Container.java:2127)
 at java.awt.Window.dispatchEventImpl(Window.java:2489)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:704)
 at java.awt.EventQueue.access$400(EventQueue.java:82)
 at java.awt.EventQueue$2.run(EventQueue.java:663)
 at java.awt.EventQueue$2.run(EventQueue.java:661)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:98)
 at java.awt.EventQueue$3.run(EventQueue.java:677)
 at java.awt.EventQueue$3.run(EventQueue.java:675)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.awt.EventQueue.dispatchEvent(EventQueue.java:674)
 at com.intellij.ide.IdeEventQueue.d(IdeEventQueue.java:673)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:494)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:296)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:211)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:201)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:196)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:188)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
Java stack trace2012-12-07 21:59:26,143 [12581574]  ERROR - siJavaCodeReferenceElementImpl - IntelliJ IDEA 12.0  Build #IU-123.72 2012-12-07 21:59:26,143 [12581574]  ERROR - siJavaCodeReferenceElementImpl - JDK: 1.6.0_37 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - VM: Java HotSpot(TM) 64-Bit Server VM 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - Vendor: Apple Inc. 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - OS: Mac OS X 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - Last Action: IntroduceField 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - Current Command: Extract Field 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - getManager() == null! 
java.lang.Throwable
 at com.intellij.openapi.diagnostic.Logger.error(Logger.java:54)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.multiResolve(PsiJavaCodeReferenceElementImpl.java:393)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.advancedResolve(PsiJavaCodeReferenceElementImpl.java:383)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.resolve(PsiJavaCodeReferenceElementImpl.java:340)
 at com.intellij.psi.impl.source.PsiJavaCodeReferenceElementImpl.getCanonicalText(PsiJavaCodeReferenceElementImpl.java:288)
 at com.intellij.psi.impl.source.PsiClassReferenceType.getCanonicalText(PsiClassReferenceType.java:190)
 at com.intellij.psi.statistics.JavaStatisticsManager.getVariableNameUseKey1(JavaStatisticsManager.java:52)
 at com.intellij.psi.statistics.JavaStatisticsManager.createVariableUseInfo(JavaStatisticsManager.java:39)
 at com.intellij.psi.statistics.JavaStatisticsManager.getVariableNameUseCount(JavaStatisticsManager.java:66)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl$6.compare(JavaCodeStyleManagerImpl.java:898)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl$6.compare(JavaCodeStyleManagerImpl.java:895)
 at java.util.Arrays.mergeSort(Arrays.java:1270)
 at java.util.Arrays.sort(Arrays.java:1210)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.a(JavaCodeStyleManagerImpl.java:903)
 at com.intellij.psi.impl.source.codeStyle.JavaCodeStyleManagerImpl.suggestVariableName(JavaCodeStyleManagerImpl.java:230)
 at com.intellij.psi.codeStyle.JavaCodeStyleManager.suggestVariableName(JavaCodeStyleManager.java:122)
 at com.intellij.refactoring.introduceField.IntroduceFieldDialog$2.getSuggestedNameInfo(IntroduceFieldDialog.java:219)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestFieldName(InplaceIntroduceFieldPopup.java:115)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup.suggestNames(InplaceIntroduceFieldPopup.java:107)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:56)
 at com.intellij.refactoring.introduceParameter.AbstractJavaInplaceIntroducer.suggestNames(AbstractJavaInplaceIntroducer.java:30)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:209)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$3.run(AbstractInplaceIntroducer.java:323)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.restartInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:336)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup$2.itemStateChanged(InplaceIntroduceFieldPopup.java:178)
 at javax.swing.AbstractButton.fireItemStateChanged(AbstractButton.java:2056)
 at javax.swing.AbstractButton$Handler.itemStateChanged(AbstractButton.java:2358)
 at javax.swing.DefaultButtonModel.fireItemStateChanged(DefaultButtonModel.java:440)
 at javax.swing.JToggleButton$ToggleButtonModel.setSelected(JToggleButton.java:255)
 at javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:272)
 at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)
 at java.awt.Component.processMouseEvent(Component.java:6382)
 at javax.swing.JComponent.processMouseEvent(JComponent.java:3275)
 at java.awt.Component.processEvent(Component.java:6147)
 at java.awt.Container.processEvent(Container.java:2083)
 at java.awt.Component.dispatchEventImpl(Component.java:4744)
 at java.awt.Container.dispatchEventImpl(Container.java:2141)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4619)
 at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4280)
 at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4210)
 at java.awt.Container.dispatchEventImpl(Container.java:2127)
 at java.awt.Window.dispatchEventImpl(Window.java:2489)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:704)
 at java.awt.EventQueue.access$400(EventQueue.java:82)
 at java.awt.EventQueue$2.run(EventQueue.java:663)
 at java.awt.EventQueue$2.run(EventQueue.java:661)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:98)
 at java.awt.EventQueue$3.run(EventQueue.java:677)
 at java.awt.EventQueue$3.run(EventQueue.java:675)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.awt.EventQueue.dispatchEvent(EventQueue.java:674)
 at com.intellij.ide.IdeEventQueue.d(IdeEventQueue.java:673)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:494)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:296)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:211)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:201)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:196)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:188)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
Java stack trace2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - IntelliJ IDEA 12.0  Build #IU-123.72 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - JDK: 1.6.0_37 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - VM: Java HotSpot(TM) 64-Bit Server VM 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - Vendor: Apple Inc. 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - OS: Mac OS X 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - Last Action: IntroduceField 2012-12-07 21:59:26,144 [12581575]  ERROR - siJavaCodeReferenceElementImpl - Current Command: Extract Field Then when I tried again to refactor I couldn't as the previous isn't finished, and got this error in the log :2012-12-07 21:59:26,202 [12581633]  ERROR - t.template.TemplateBuilderImpl - Assertion failed: container: RangeMarker(valid,908,3224) 15531 markers: [21, 56], [1320, 1349], [1882, 1917] 
java.lang.Throwable
 at com.intellij.openapi.diagnostic.Logger.assertTrue(Logger.java:98)
 at com.intellij.codeInsight.template.TemplateBuilderImpl.buildTemplate(TemplateBuilderImpl.java:198)
 at com.intellij.codeInsight.template.TemplateBuilderImpl.buildInlineTemplate(TemplateBuilderImpl.java:174)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.a(InplaceRefactoring.java:345)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.access$000(InplaceRefactoring.java:93)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring$2.run(InplaceRefactoring.java:315)
 at com.intellij.openapi.application.RunResult.run(RunResult.java:37)
 at com.intellij.openapi.command.WriteCommandAction$2$1.run(WriteCommandAction.java:125)
 at com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(ApplicationImpl.java:986)
 at com.intellij.openapi.command.WriteCommandAction$2.run(WriteCommandAction.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.WriteCommandAction.performWriteCommandAction(WriteCommandAction.java:119)
 at com.intellij.openapi.command.WriteCommandAction.access$000(WriteCommandAction.java:34)
 at com.intellij.openapi.command.WriteCommandAction$1.run(WriteCommandAction.java:75)
 at com.intellij.openapi.command.WriteCommandAction.execute(WriteCommandAction.java:80)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.buildTemplateAndStart(InplaceRefactoring.java:312)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.performInplaceRefactoring(InplaceRefactoring.java:209)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.access$301(AbstractInplaceIntroducer.java:62)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:223)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$3.run(AbstractInplaceIntroducer.java:323)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.restartInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:336)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup$2.itemStateChanged(InplaceIntroduceFieldPopup.java:178)
 at javax.swing.AbstractButton.fireItemStateChanged(AbstractButton.java:2056)
 at javax.swing.AbstractButton$Handler.itemStateChanged(AbstractButton.java:2358)
 at javax.swing.DefaultButtonModel.fireItemStateChanged(DefaultButtonModel.java:440)
 at javax.swing.JToggleButton$ToggleButtonModel.setSelected(JToggleButton.java:255)
 at javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:272)
 at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)
 at java.awt.Component.processMouseEvent(Component.java:6382)
 at javax.swing.JComponent.processMouseEvent(JComponent.java:3275)
 at java.awt.Component.processEvent(Component.java:6147)
 at java.awt.Container.processEvent(Container.java:2083)
 at java.awt.Component.dispatchEventImpl(Component.java:4744)
 at java.awt.Container.dispatchEventImpl(Container.java:2141)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4619)
 at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4280)
 at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4210)
 at java.awt.Container.dispatchEventImpl(Container.java:2127)
 at java.awt.Window.dispatchEventImpl(Window.java:2489)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:704)
 at java.awt.EventQueue.access$400(EventQueue.java:82)
 at java.awt.EventQueue$2.run(EventQueue.java:663)
 at java.awt.EventQueue$2.run(EventQueue.java:661)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:98)
 at java.awt.EventQueue$3.run(EventQueue.java:677)
 at java.awt.EventQueue$3.run(EventQueue.java:675)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.awt.EventQueue.dispatchEvent(EventQueue.java:674)
 at com.intellij.ide.IdeEventQueue.d(IdeEventQueue.java:673)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:494)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:296)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:211)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:201)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:196)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:188)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
Java stack trace2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - IntelliJ IDEA 12.0  Build #IU-123.72 2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - JDK: 1.6.0_37 2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - VM: Java HotSpot(TM) 64-Bit Server VM 2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - Vendor: Apple Inc. 2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - OS: Mac OS X 2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - Last Action: IntroduceField 2012-12-07 21:59:26,203 [12581634]  ERROR - t.template.TemplateBuilderImpl - Current Command: Extract Field 2012-12-07 21:59:26,204 [12581635]  ERROR - com.intellij.ide.IdeEventQueue - Error during dispatching of java.awt.event.MouseEvent[MOUSE_RELEASED,(709,545),absolute(709,567),button=1,modifiers=Button1,clickCount=1] on frame2 
java.lang.RuntimeException: java.lang.StringIndexOutOfBoundsException: String index out of range: -887
 at com.intellij.openapi.command.WriteCommandAction.execute(WriteCommandAction.java:88)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.buildTemplateAndStart(InplaceRefactoring.java:312)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.performInplaceRefactoring(InplaceRefactoring.java:209)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.access$301(AbstractInplaceIntroducer.java:62)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$2.run(AbstractInplaceIntroducer.java:223)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.startInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:207)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer$3.run(AbstractInplaceIntroducer.java:323)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:83)
 at com.intellij.refactoring.introduce.inplace.AbstractInplaceIntroducer.restartInplaceIntroduceTemplate(AbstractInplaceIntroducer.java:336)
 at com.intellij.refactoring.introduceField.InplaceIntroduceFieldPopup$2.itemStateChanged(InplaceIntroduceFieldPopup.java:178)
 at javax.swing.AbstractButton.fireItemStateChanged(AbstractButton.java:2056)
 at javax.swing.AbstractButton$Handler.itemStateChanged(AbstractButton.java:2358)
 at javax.swing.DefaultButtonModel.fireItemStateChanged(DefaultButtonModel.java:440)
 at javax.swing.JToggleButton$ToggleButtonModel.setSelected(JToggleButton.java:255)
 at javax.swing.JToggleButton$ToggleButtonModel.setPressed(JToggleButton.java:272)
 at javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:236)
 at java.awt.Component.processMouseEvent(Component.java:6382)
 at javax.swing.JComponent.processMouseEvent(JComponent.java:3275)
 at java.awt.Component.processEvent(Component.java:6147)
 at java.awt.Container.processEvent(Container.java:2083)
 at java.awt.Component.dispatchEventImpl(Component.java:4744)
 at java.awt.Container.dispatchEventImpl(Container.java:2141)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4619)
 at java.awt.LightweightDispatcher.processMouseEvent(Container.java:4280)
 at java.awt.LightweightDispatcher.dispatchEvent(Container.java:4210)
 at java.awt.Container.dispatchEventImpl(Container.java:2127)
 at java.awt.Window.dispatchEventImpl(Window.java:2489)
 at java.awt.Component.dispatchEvent(Component.java:4572)
 at java.awt.EventQueue.dispatchEventImpl(EventQueue.java:704)
 at java.awt.EventQueue.access$400(EventQueue.java:82)
 at java.awt.EventQueue$2.run(EventQueue.java:663)
 at java.awt.EventQueue$2.run(EventQueue.java:661)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:98)
 at java.awt.EventQueue$3.run(EventQueue.java:677)
 at java.awt.EventQueue$3.run(EventQueue.java:675)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.security.AccessControlContext$1.doIntersectionPrivilege(AccessControlContext.java:87)
 at java.awt.EventQueue.dispatchEvent(EventQueue.java:674)
 at com.intellij.ide.IdeEventQueue.d(IdeEventQueue.java:673)
 at com.intellij.ide.IdeEventQueue._dispatchEvent(IdeEventQueue.java:494)
 at com.intellij.ide.IdeEventQueue.dispatchEvent(IdeEventQueue.java:333)
 at java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:296)
 at java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:211)
 at java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:201)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:196)
 at java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:188)
 at java.awt.EventDispatchThread.run(EventDispatchThread.java:122)
Caused by: java.lang.StringIndexOutOfBoundsException: String index out of range: -887
 at java.lang.String.substring(String.java:1937)
 at com.intellij.codeInsight.template.TemplateBuilderImpl.buildTemplate(TemplateBuilderImpl.java:205)
 at com.intellij.codeInsight.template.TemplateBuilderImpl.buildInlineTemplate(TemplateBuilderImpl.java:174)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.a(InplaceRefactoring.java:345)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring.access$000(InplaceRefactoring.java:93)
 at com.intellij.refactoring.rename.inplace.InplaceRefactoring$2.run(InplaceRefactoring.java:315)
 at com.intellij.openapi.application.RunResult.run(RunResult.java:37)
 at com.intellij.openapi.command.WriteCommandAction$2$1.run(WriteCommandAction.java:125)
 at com.intellij.openapi.application.impl.ApplicationImpl.runWriteAction(ApplicationImpl.java:986)
 at com.intellij.openapi.command.WriteCommandAction$2.run(WriteCommandAction.java:122)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:115)
 at com.intellij.openapi.command.impl.CommandProcessorImpl.executeCommand(CommandProcessorImpl.java:97)
 at com.intellij.openapi.command.WriteCommandAction.performWriteCommandAction(WriteCommandAction.java:119)
 at com.intellij.openapi.command.WriteCommandAction.access$000(WriteCommandAction.java:34)
 at com.intellij.openapi.command.WriteCommandAction$1.run(WriteCommandAction.java:75)
 at com.intellij.openapi.command.WriteCommandAction.execute(WriteCommandAction.java:80)
 ... 54 more
Java stack trace2012-12-07 21:59:26,205 [12581636]  ERROR - com.intellij.ide.IdeEventQueue - IntelliJ IDEA 12.0  Build #IU-123.72 2012-12-07 21:59:26,205 [12581636]  ERROR - com.intellij.ide.IdeEventQueue - JDK: 1.6.0_37 2012-12-07 21:59:26,205 [12581636]  ERROR - com.intellij.ide.IdeEventQueue - VM: Java HotSpot(TM) 64-Bit Server VM 2012-12-07 21:59:26,205 [12581636]  ERROR - com.intellij.ide.IdeEventQueue - Vendor: Apple Inc. 2012-12-07 21:59:26,205 [12581636]  ERROR - com.intellij.ide.IdeEventQueue - OS: Mac OS X 2012-12-07 21:59:26,205 [12581636]  ERROR - com.intellij.ide.IdeEventQueue - Last Action: IntroduceField
"
https://youtrack.jetbrains.com/issue/IDEA-133700/Wrong-result-of-Inline-Refactor,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,inline method,https://github.com/JetBrains/intellij-community/commit/5cfd7bb6814a7fff08b047480564f6098acc5c40,ast rewrite issue,"Wrong result of Inline Refactor
public class JavaClass {
    String bar() {
        return ""bar"";
    }

    String baz(boolean condition) {
        if (condition)
            return bar<caret>();

        return ""default"";
    }
} Actual:public class JavaClass {
    String bar() {
        return ""bar"";
    }

    String baz(boolean condition) {
        return ""bar"";
        if (condition)

        return ""default"";
    }
} Expected:public class JavaClass {
    String bar() {
        return ""bar"";
    }

    String baz(boolean condition) {
        if (condition) return ""bar"";

        return ""default"";
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-152098/Extract-parameter-object-when-existing-class-used-replaces-parameters-with-wrong-getters,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,extract parameter object,https://github.com/JetBrains/intellij-community/commit/7a0ae14c434c269d39e4d7c25ff661415a8e96e1,flow analysis issue,"Extract parameter object when existing class used replaces parameters with wrong getters
class P {
  private String myClass;
  public String getSourceClass() {return myClass;}
}

void foo(String aClass) {
  sout(aClass);
} would change the call to  sout(p.getaclass()) 
"
https://youtrack.jetbrains.com/issue/IDEA-152114/Change-signature-warns-but-not-change-method-reference-to-lambda,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/aa00a3b1ba2939d22defb183f21f586853a63cef,flow analysis issue,"'Change signature' warns but not change method reference to lambda
Build: 145.75Here is code snippet:    public static void print() {
        List<Integer> someNumbers = A.returnAllNumbers(A::alwaysTrue);
    }

    private static List<Integer> returnAllNumbers(Predicate<Integer> predicate) {
        return new ArrayList<>();
    }

    public static boolean alwaysTrue(int a) {
        return true;
    } When tries to change method signature of alwaysTrue(int a) for instance by adding new parameter IDEA shows warning: Changed method is used in method reference. Proceeding would result in conversion to lambda expression But if click Continue no conversion happens and code left incompilable:List<Integer> someNumbers = A.returnAllNumbers(A::alwaysTrue);  // signature now alwaysTrue(int, boolean)Kotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-152294/Introducing-parameters-breaks-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,introduce parameter,https://github.com/JetBrains/intellij-community/commit/32dd35be57e2f149068d483ee343125720a133b6,ast rewrite issue,"Introducing parameters breaks code
...
        extract(""/config"", ""./config"", "".lic"");
...


    private static void extract(final String from, final String to, final String... extensions) throws IOException {

        Reflections reflections = new Reflections();
        final Set<String> resources = reflections.getResources(new StringPredicate(extensions));

}
 try to introduce parameternew StringPredicate(extensions) result final StringPredicate stringPredicate = new StringPredicate(extensions);
 extract(""/config"", ""./config"", stringPredicate, "".lic""); instead of  final StringPredicate stringPredicate = new StringPredicate("".lic"");
 extract(""/config"", ""./config"", stringPredicate); 
"
https://youtrack.jetbrains.com/issue/IDEA-152334/Refactor-Extract-Method-leads-to-Variable-...-is-already-defined-in-the-scope,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/5673683e95f7d048b8ad47ea7b3d673a22b375bb,flow analysis issue,"Refactor/Extract/Method leads to ""Variable [...] is already defined in the scope""
I have the following code calculating expenses and revenues based on a named query of a @Entity.ExampleEntity.javaimport javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;

@Entity
@NamedQueries(value = {
        @NamedQuery(name = ""revenues"", query = """"),
        @NamedQuery(name = ""expenses"", query = """")
})
public class ExampleEntity {

    @Id
    private String id;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }
} ExampleProvider.javaimport javax.ejb.Stateless;
import javax.inject.Inject;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.Query;
import java.io.Serializable;
import java.math.BigDecimal;

@Stateless
public class ExampleProvider implements Serializable {

    @Inject
    @PersistenceContext
    EntityManager entityManager;

    public BigDecimal getRevenue() {
        final Query query = this.entityManager.createNamedQuery(""revenues"");
        final BigDecimal revenues = (BigDecimal) query.getSingleResult();
        final BigDecimal revenue;

        if (revenues == null) {
            revenue = BigDecimal.ZERO;
        } else {
            revenue = revenues;
        }

        return revenue;
    }

    public BigDecimal getExpense() {
        final Query query = this.entityManager.createNamedQuery(""expenses"");
        final BigDecimal expenses = (BigDecimal) query.getSingleResult();
        final BigDecimal expense;

        if (expenses == null) {
            expense = BigDecimal.ZERO;
        } else {
            expense = expenses;
        }

        return expense;
    }
}
 Now, the methods getRevenue and getExpense look quite similar and when I Refactor/Extract/Method the snippet        final Query query = this.entityManager.createNamedQuery(""expenses"");
        final BigDecimal expenses = (BigDecimal) query.getSingleResult();
        final BigDecimal expense;

        if (expenses == null) {
            expense = BigDecimal.ZERO;
        } else {
            expense = expenses;
        } IntelliJ advised me to change the signature to refactor the name of the named query to a parameter which leads to the situation that each a parameter and a local variable are both identically named.    public BigDecimal getExpense() {
        final BigDecimal expense = getResult(""expenses"");

        return expense;
    }

    private BigDecimal getResult(String expenses) {
        final Query query = this.entityManager.createNamedQuery(expenses);
        final BigDecimal expenses = (BigDecimal) query.getSingleResult(); // Variable 'expenses' is already defined in the scope
        final BigDecimal expense;

        if (expenses == null) {
            expense = BigDecimal.ZERO;
        } else {
            expense = expenses;
        }
        
        return expense;
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-151960/Unable-to-inline-variable-used-in-lambda,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/af1a898ee882ad5e2e779e62ec01eed4c1c56aa1,flow analysis issue,"Unable to inline variable used in lambda
private void withStream(Stream<Object> stream) {
        String leg = """";
        stream.forEach(o -> new StringBuilder().append(leg).append(""123""));
    } Try to inline variable legExpected result    private void withStream(Stream<Object> stream) {
        stream.forEach(o -> new StringBuilder().append("""").append(""123""));
    } ActualIDEA shows message: Variable leg is never used before modification
"
https://youtrack.jetbrains.com/issue/IDEA-86007/Inline-Class-does-not-add-braces-to-if-statements-when-they-are-needed,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,inline class,https://github.com/JetBrains/intellij-community/commit/56311ae33e2cf3dc0d63b6e6bdde1414cd9ef491,ast rewrite issue,"Inline Class does not add braces to if statements when they are needed
If you start with this code: public class Demo {

    static class MyParent {
        private final String value;

        MyParent(String value) {
            this.value = value;
        }
    }

    static class MyChild extends MyParent {
        MyChild(String value) {
            super(value);
        }
    }

    public static void main(String[] args) {

        String value = ""something"";
        final MyParent p;
        if (true)
            p = new MyChild(value);
        else
            p = new MyParent(""value"");
    }
}Kotlin detectedAnd you Inline MyChild, then the result is invalid. For me it looks like this:         String value = ""something"";
        final MyParent p;
        if (true)
            final String value1 = value;p = new MyParent(value1);
        else
            p = new MyParent(""value"");Kotlin detectedThe Inline Class refactorings needs to add the braces to If statements when needed. It probably needs to add braces to other Statement PSI Nodes as well. I see this problem a lot with if statements though. The refactorings works most the time. It seems there is a conflict when there is a naming conflict within the calling scope.
"
https://youtrack.jetbrains.com/issue/IDEA-119021/Wrong-accessibility-warnings-when-inlining-a-static-class-to-anonymous,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,incorrect warning message,inline class,https://github.com/JetBrains/intellij-community/commit/fbb0fd6132bc0967699c0abf489274c34d96c361,overly weak preconditions,"Wrong accessibility warnings when inlining a static class to anonymous
private static class IdSet {

    private final MyTIntHashSet mySet;

    private IdSet(final int initialCapacity) {
      mySet = new MyTIntHashSet(initialCapacity, 0.98f);
    }

    public void ensureCapacity(int desiredCapacity) {
      mySet.ensureCapacity(desiredCapacity);
    }

    public boolean add(int val) {
      return mySet.add(val);
    }

    private static class MyTIntHashSet extends TIntHashSet {
      public MyTIntHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor);
      }

      @Override
      public void compact() {
        if (((int)(capacity() * _loadFactor)/ Math.max(1, size())) >= 3) {
          super.compact();
        }
      }
    }
  } Invoke ""inline"" on new MyTIntHashSet. Some warnings are displayed about fields that would be inaccessible. Proceed. Everything's OK!
"
https://youtrack.jetbrains.com/issue/IDEA-152481/Inline-super-class-applied-to-interface-tries-to-modify-constructor,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline class,https://github.com/JetBrains/intellij-community/commit/3cd6b264233db374e55bf1787f75aca71031fab1,flow analysis issue,"'Inline super class' applied to interface tries to modify constructor
Build: 145.184.1Consider such code snippet:public class A implements I {
    A(int i) {
        System.out.println(i);
    }
}

public interface I {}

public class B extends A implements I { // place caret on I
    B(boolean mode) {
        super(mode? 1: 0);
    }
} Place caret on I in declaration of class B and invoke 'Inline super class' refactoring. Applying the refactoring creates uncompilable code.Seems in case of inlining interface IDEA should not touch constructors at all.
"
https://youtrack.jetbrains.com/issue/IDEA-152583/Inline-super-class-refactoring-confused-by-method-with-array-creation-shows-constructor-warning,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,incorrect warning message,inline class,https://github.com/JetBrains/intellij-community/commit/84f7bc13b88faece0da83c9af920adf913e378f8,ast rewrite issue,"Inline super class refactoring confused by method with array creation, shows constructor warning
Build: 146.348Continuation of IDEA-152539, a bit different code snippet.Consider such code sample:public class MetaPerson {
    public MetaPerson(String name) { }

    public static MetaPerson[] emptyArray() {
        return new MetaPerson[0];
    }
}

public class Person extends MetaPerson { 
    public Person(String name) {
        super(name);
    }
}

public class Roster {
    public static void main(String[] args) {
        final MetaPerson p = new MetaPerson(""""); //inline MetaPerson
    }
} In case there is third class with method instantinating MetaPerson there is the same error message  'Constructor matching super not found'  (without exception), which seems wrong for me. And again it happens only if there are emptyArray() method.
"
https://youtrack.jetbrains.com/issue/IDEA-151634/Invert-Boolean-incorrectly-modifies-boolean-variable-of-enhanced-FOR-cycle,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,foreach,behavior change,invert boolean,https://github.com/JetBrains/intellij-community/commit/3537458aa386f9048676e5eff5c60bbc9fcac9aa,overly weak preconditions,"Invert Boolean incorrectly modifies boolean variable of enhanced FOR cycle
Build: 144.3950As IDEA doesn't invert expression inside enhanced FOR cycle (which seems difficult/impossible) new code after 'Invert Boolean' refactoring behaves differently than old one.Example:        boolean positiveArray[] = new boolean[3];
        Arrays.fill(positiveArray, true);

        for (boolean value : positiveArray) {
            System.out.println(""Value = "" + value);
        } // prints three 'true'Kotlin detectedSet caret on 'for' cycle line on value variable and invoke 'Invert Boolean' refactor.This causes inversion of value only in printing line and so the code prints three false now.Seems 'Invert Boolean' refactoring should be prohibited for boolean variable inside enhanced for statement.
"
https://youtrack.jetbrains.com/issue/IDEA-151809/No-warning-when-Pull-Up-method-to-the-interface-dependent-on-the-instance-variable,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options,compile error,pull up method,https://github.com/JetBrains/intellij-community/commit/e1f2670f5afb003d264f131d31e9850dade53b2d,overly weak preconditions,"No warning when Pull Up method to the interface dependent on the instance variable
Build: 144.4216The following code contains instance variable and method dependent on it. public interface IPlanet {}

public class SimplePlanet implements IPlanet {
    double mass;

    private double mass() {
        return mass;
    }
} When Pull Up mass() method to the interface as default method (unchecking abstract checkbox) it creates incompilable code:public interface IPlanet {
    default double mass() {
        return mass;
    }
} It was expected standard Problems detected warning would be shown.
"
https://youtrack.jetbrains.com/issue/IDEA-152600/Inline-variable-which-represent-functional-reference-breaks-method-refence,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,method reference,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/e6a5fc8f31273f918e16f48a5408aae95ac43016,ast rewrite issue,"Inline variable which represent functional reference breaks method refence
Consider such code sample:interface Task  {
    void doit();
}

class SuperClient extends Client {
    public static void main(String[] args) {
        Task t = () -> System.out.println(""hello""); // inline 't'
        Runner r = t::doit;
        r.run();
    }
} Inlining variable t creates uncompilable code:Runner r = (Task) () -> System.out.println(""hello"")::doit;Kotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-86639/Erroneous-behavior-when-inlining-parent-interfaces,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline interface,https://github.com/JetBrains/intellij-community/commit/4c730104a876c9e02679f1ce96e7c7a7e2d2c06f,ast rewrite issue,"Erroneous behavior when inlining parent interfaces
Given the following class hierarchy:public interface IterableWrapper<T> extends Iterable<T> {}public interface SomethingIterable<T> extends IterableWrapper<T> {}Position the cursor on ""IterableWrapper"" in ""SomethingIterable"" and do the Inline refactor (ctrl-alt-n).The result is:public interface SomethingIterable<T> implements Iterable {}This has two errors: - We've lost the type parameters for Iterable; - Should be ""extends"", not ""implements""
"
https://youtrack.jetbrains.com/issue/IDEA-134349/Create-Local-Variable-does-not-make-variable-final-though-selected-and-required,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/02e43742537ec3a7ce7c35bb8148e7bff3277459,others,"Create Local Variable: does not make variable final though selected and required
Following code:public class Foo {
  public Runnable getMessage(final Bar bar) {
    if (bar.getMessage() == null) {
      System.out.println(""no message"");
    }
    return new Runnable() {
      @Override
      public void run() {
        System.out.println(bar.getMessage());
      }
    };
  }
}

public class Bar {
  public String getMessage() {
    return ""Hello"";
  }
} When I select the first bar.getMessage() and invoke Create Local Variable, select ""Replace all occurrences (2 occurrences)"", the selected ""Declare final"" will become disabled but remains selected. As a result I'm getting following uncompilable result:public class Foo {
  public Runnable getMessage(final Bar bar) {
    String message = bar.getMessage();
    if (message == null) {
      System.out.println(""no message"");
    }
    return new Runnable() {
      @Override
      public void run() {
        System.out.println(message);
      }
    };
  }
}

public class Bar {
  public String getMessage() {
    return ""Hello"";
  }
} But even worse: when I select the second bar.getMessage(), I don't have the option to replace both occurrences.
"
https://youtrack.jetbrains.com/issue/IDEA-86870/Push-Members-Down-for-implements-element-loses-generic-parameters,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,behavior change,push members down,https://github.com/JetBrains/intellij-community/commit/95733028b58bebf2247d4bab4a9fea139be0c820,ast rewrite issue,"'Push Members Down' for 'implements' element loses generic parameters
Invoke the refactoring on 'B' class for the following code and select 'implements List' item.abstract class A extends B {
}
abstract class B implements List<String> {
}  IDEA will produce the codeabstract class A extends B implements List {
}
abstract class B {
} Note that '<String>' parameter for 'List' is lost.
"
https://youtrack.jetbrains.com/issue/IDEA-152105/Inline-method-doesnt-apply-to-comments-and-search-string,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,inline method,nan,nan,"'Inline method' doesn't apply to comments and search string
Build: 145.75Even user selects corresponding cheboxes and IDEA finds such code it doesn't apply change.For instance there is such code:public class B {
    void foo() {
        String tmp = bar();
//        tmp = bar();
        System.out.println(""that's a bar()"");
    }

    String bar() {
        return ""blah"";
    }
} Trying to inline bar() method with option ""Search in comments and strings"", IDEA finds both comment and text string, but when perform refactor only first statement of foo() changed.
"
https://youtrack.jetbrains.com/issue/IDEA-152822/Replace-Constructor-with-Factory-Method-refactoring-should-warn-when-method-is-already-present,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,Replace Constructor with Factory Method,https://github.com/JetBrains/intellij-community/commit/ad19b800f92307861b67753cecfbedc22373d856,overly weak preconditions,"""Replace Constructor with Factory Method"" refactoring should warn when method is already present
For example invoke ""Replace Constructor with Factory Method..."" on the following code and create a method with name ""createA"":class A {
  public A() {}

  public static A createA() {
    return A.createA();
  }
} The result is two createA() methods, which does not compile. I expected a warning that a method with that name was already present.
"
https://youtrack.jetbrains.com/issue/IDEA-135083/Extract-variable-from-expression-lambda-and-changing-name-breaks-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/111f487f7e0d078d4d389df37775c387a0a0af58,ast rewrite issue,"Extract variable from expression lambda and changing name breaks code
To reproduce extract the string constant from the following code (make sure in-place mode for refactoring is enabled) and give it a different name than suggested.class X {
  void foo() {
    Runnable r = () -> System.out.println(""extract me"");
  }
} Result:class X {
  void foo() {
    final String different = ""extract me"";
    Runnable r = () -> System.out.println(s);
  }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-152514/Invert-boolean-works-incorrectly-with-final-fields,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,invert boolean,https://github.com/JetBrains/intellij-community/commit/e836aa498028125decb9a6ff6748d7262c083808,ast rewrite issue,"'Invert boolean' works incorrectly with final fields
When final field is initialized in constructor, Invert boolean inverts it there but also update declaration statement which makes code uncompilable.Consider such example:public class Final {
    final public boolean mode;

    Final(boolean mode) {
        this.mode = mode;
    }
} If user inverts mode field then it modifies declaration to:final public boolean mode = true; Which makes code of constructor uncompilable. The same happens with static field, but not with method local variable.
"
https://youtrack.jetbrains.com/issue/IDEA-87191/Pull-Members-Up-refactor-fails-to-merge-superinterfaces,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,pull members up,https://github.com/JetBrains/intellij-community/commit/da14fb5c428734fb0deacc8bb96a55c9c858ae6d,ast rewrite issue,"Pull Members Up refactor fails to merge superinterfaces
Given classes:    static abstract class A implements Collection<String> { }     static abstract class B extends A implements Collection<String> { }If you do a ""Pull Members Up"" refactor on B, and ask it to pull up the ""implements Collection<String>"", it succeeds but then results in broken code:    static abstract class A implements Collection<String>, Collection<String> { }What it should do is either fail (because that member is already there), or better, identify the fact that the supertype is already there and merge the two (compatible) superinterface declarations into one.
"
https://youtrack.jetbrains.com/issue/IDEA-87320/Extract-Method-creates-conflicting-local-variable,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract method,nan,nan,"Extract Method creates conflicting local variable
Using IDEA 177.499.    public static void create(Map<String, Metric> metrics) {
        if (!metrics.containsKey(""nexus.kernel.Executor.IdleTimePercent"")) {
            PositiveDeltaMetric idleTimeDelta = new PositiveDeltaMetric(""nexus.kernel.Executor.IdleTimeDelta"",
                                                                        metrics.get(""nexus.kernel.Executor.IdleTimeNanos""));
            DivideMetric idleTimeDeltaPerThread = new DivideMetric(""nexus.kernel.Executor.IdleTimeDeltaPerThread"",
                                                                   idleTimeDelta,
                                                                   metrics.get(""nexus.kernel.Executor.PoolSize""));
            Metric idleTimePercent = new PercentTimeMetric(""nexus.kernel.Executor.IdleTimePercent"",
                                                           idleTimeDeltaPerThread);
            metrics.put(idleTimePercent.getName(), idleTimePercent);
        }
    } If I select the expression assigned to idleTimeDelta and use the Extract Method refactoring, I get the following:    public static void create(Map<String, Metric> metrics) {
        if (!metrics.containsKey(""nexus.kernel.Executor.IdleTimePercent"")) {
            Map<String, Metric> metrics;
            PositiveDeltaMetric idleTimeDelta = positiveDelta(metrics);
            DivideMetric idleTimeDeltaPerThread = new DivideMetric(""nexus.kernel.Executor.IdleTimeDeltaPerThread"",
                                                                   idleTimeDelta,
                                                                   metrics.get(""nexus.kernel.Executor.PoolSize""));
            Metric idleTimePercent = new PercentTimeMetric(""nexus.kernel.Executor.IdleTimePercent"",
                                                           idleTimeDeltaPerThread);
            metrics.put(idleTimePercent.getName(), idleTimePercent);
        }
    }

    private static PositiveDeltaMetric positiveDelta(Map<String, Metric> metrics) {
        return new PositiveDeltaMetric(""nexus.kernel.Executor.IdleTimeDelta"",
                                                                    metrics.get(""nexus.kernel.Executor.IdleTimeNanos""));
    } Notice the unnecessary and conflicting metrics local variable which has been created.
"
https://youtrack.jetbrains.com/issue/IDEA-87461/Dont-introduce-variable-from-last-segments-of-qualified-expressions,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,introduce variable,https://github.com/JetBrains/intellij-community/commit/2d257630389eb866ff777648b5403506c6942f02,overly weak preconditions,"Don't introduce variable from last segments of qualified expressions
super.foo(); // select 'foo()', introduce variableKotlin detectedresult:Foo foo = foo();
super.foo; Same for normal calls:x.foo(); // select 'foo()', introduce variableKotlin detectedresultFoo foo = foo();
x.foo; 
"
https://youtrack.jetbrains.com/issue/IDEA-135610/Inline-variable-doesnt-work-in-special-case,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/a94175f4f8d771d939e09f64b2da907d4f464965,flow analysis issue,"Inline variable doesn't work in special case
I have following code:   public static String replaceProcessID(String content, String processId) {
        content  = content.replaceAll(prozessInstanzIdPattern, ""<base:ProzessInstanzID>"" + processId +""</base:ProzessInstanzID>"");
        return content;
    } Let's suppose my caret position is on ""content = "" and I hit Ctrl+Shift+N (Inline shortcut), I got ""Cannot find initializer for parameter""It should be inlined into :    public static String replaceProcessID(String content, String processId) {
        return  content.replaceAll(prozessInstanzIdPattern, ""<base:ProzessInstanzID>"" + processId +""</base:ProzessInstanzID>"");
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-153700/Inline-variable-with-2-dimension-array-produces-uncompilable-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,multi dimension array,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/bb5a0f66e9e1b588a56690a40cd004c8a48dc0fe,overly weak preconditions,"'Inline variable' with 2-dimension array produces uncompilable code
Object[][] params = new Object[][]{{""""}};
        Object[][] params2 = {{""""}};
        List<Object[]> l1 = Arrays.asList(params);
        List<Object[]> l2 = Arrays.asList(params2); Try to inline variable params or params2
"
https://youtrack.jetbrains.com/issue/IDEA-87521/Change-Signature-refactoring-doesnt-keep-existing-parameter-javadoc,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/51b6f9e052fde0558f8a8b6cb10ba09e444a5cd8,ast rewrite issue,"Change Signature refactoring doesn't keep existing parameter javadoc
I renamed and changed the type of a method parameter. After refactoring the javadoc for the old parameter was removed and only the name of the ""new"" parameter was there. Renaming the parameter should keep the existing javadoc comment and only rename the parameter in the javadoc.I have also seen this error occurring (and not been fixed) during refactoring: IDEA-59501
"
https://youtrack.jetbrains.com/issue/IDEA-87543/Pull-Members-Up-fails-when-class-type-parameters-are-aliased-with-superclass-type-parameters,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,pull members up,https://github.com/JetBrains/intellij-community/commit/4b5ba694dc43153234d58b1462c1b2bfea56dce3,ast rewrite issue,"Pull Members Up fails when class type parameters are aliased with superclass type parameters
Givenpublic interface Bar<T> { }public interface Base<T> { }public class Foo<T,U> implements Base<U> {    void foo(Bar<U> bar) { }}If you try and do a ""pull members up"" to pull foo() into Base, it will erroneously create a signature     void foo(Bar<Object> bar)when it should base Bar<T> (since U in Foo is T in Base).  If the type parameter T in Foo were instead called X (Foo<X,U>), the failure does not happen.  Seems that having a conflict between type parameter T in Foo and T in Base (which are unrelated) causes something to give up and fall back to an erased type.  (This may be related to IDEA-86405.)
"
https://youtrack.jetbrains.com/issue/IDEA-131841/Issue-in-refractorencapsulate-field-when-using-increment-operator-on-a-member,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,encapsulate field,https://github.com/JetBrains/intellij-community/commit/19210dd1b5d9ec098687e2b523af722127c4ca8e,overly weak preconditions,"Issue in refractor>encapsulate field when using increment operator on a member
Encapsulate field when using an increment operator on a member does not account for the return value of the increment operator. example:classA{    public static int member1;}used in:somemethodcall(classA.member1++)When refactored, the method call is replaced bysomemethodcall(classA.setmember1(classA.getmember1()+1))since the return type of setmember1 is void by default, the somemethodcall fails to compile
"
https://youtrack.jetbrains.com/issue/IDEA-153692/Refactror.-Extract-method-generates-code-with-error.,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,this,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/1e754b557981bee66346f6239327716a5adbfb8b,ast rewrite issue,"Refactror. Extract method generates code with error.
When extracting a Java method from an expression (say) and asking IntelliJ to make it static the extra parameters are provided but the this. qualifier is not removed from the body.Here is a small class:public class MethodExtraction {
    
    public final String internalValue;
    
    MethodExtraction() {
        this.internalValue = ""This is my internal value"";
    }
    
    void aMethod() {
        String exclaim = this.internalValue + ""!"";

        System.out.println(exclaim);
    }

} If I select the expression this.internalValue + ""!"" and Refactor/Extract/Method and select the 'Declare static' box, so:Inline images 2then IntelliJ will produce this:void aMethod() {
    String exclaim = makeExclaim(internalValue);

    System.out.println(exclaim);
}

private static String makeExclaim(String internalValue) {
    return this.internalValue + ""!"";
} and highlight the this. qualifier (correctly) as an error. But IntelliJ generated this error itself.  This is rather silly, and I would rather it didn't do this.By the way, the generated callmakeExclaim(internalValue)  should really be makeExclaim(this.internalValue)  don't you think? After all, that's how I referred to the instance variable originally.
"
https://youtrack.jetbrains.com/issue/IDEA-153667/Reassing-to-existing-variable-not-removing-final-modifier,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/43e3e4f6bb630457a6f0e662dbed811420c7806f,ast rewrite issue,"Reassing to existing variable not removing final modifier
Consider such code sample:final int x = 0; 
int y =   x + 1; Extract variable and reassing it to existing variable x. This creates uncompilable code:final int x = 0;
x = x + 1;
int y = x; I assume we could remove final in such situation and it would be expected behavior as user explicitly hits reassigning to existing variable.
"
https://youtrack.jetbrains.com/issue/IDEA-83831/rename...-silently-replaces-one-method-with-another,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,exception,rename method,https://github.com/JetBrains/intellij-community/commit/255dbc2c49de2a51e25f21617b4e63ed077349e7;https://github.com/JetBrains/intellij-community/commit/00f361600ba402086c0c33a82102390e0b27d9b7,overly weak preconditions,"""rename..."" silently replaces one method with another
Source example:class RenameTest {
    static void foo1(Number n) {
        System.out.println(""1"");
    }
    static void foo2(Long i) {
        System.out.println(""2"");
    }
    public static void main(String[] args) {
        long n = 0;
        foo1(n);// look here
    }
} Try to rename method ""foo1"" to ""foo2"" via Shift+F6.After renaming:class RenameTest {
    static void foo2(Number n) {
        System.out.println(""1"");
    }
    static void foo2(Long i) {
        System.out.println(""2"");
    }
    public static void main(String[] args) {
        long n = 0;
        RenameTest.foo2(n);// look here
    }
} Thus, after renaming, method foo2(Long) was linked silently without the ""Problems Dialog"".
"
https://youtrack.jetbrains.com/issue/IDEA-152851/Extract-Method-Object-incompilable-result-in-case-of-this-and-super-and-anonymous-class-creation,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/e09b0fca1ef35698b0417dac325901c1a3aee20f,ast rewrite issue,"Extract Method Object: incompilable result in case of `this` and `super` and anonymous class creation
Dummy Java classes:EmoDaddy.javapublic class EmoDaddy {
    protected int daddyField = 1;
    protected int daddyMethod() { return daddyField; }
}  LambdaEmo.javapublic class LambdaEmo extends EmoDaddy {
    private int ownField = 2;
    private int ownMethod() { return ownField; }
    public void context() {
        queue(() -> System.out.println(ownField + ownMethod()));
        queue(() -> System.out.println(this.ownField + this.ownMethod()));
        queue(() -> System.out.println(super.daddyField + super.daddyMethod()));
    }
    public void queue(Runnable runnable) { runnable.run(); }
}  Refactor / Extract Method Object.Apply to lambdas:a. () -> System.out.println(this.ownField + this.ownMethod())b. () -> System.out.println(super.daddyField + super.daddyMethod())For ""Create inner class"" option the result is correct.For ""Create anonymous class"" option the this and super references are preserved in new created class, and the code is incompilable.IDEA 145.333, 146.433.
"
https://youtrack.jetbrains.com/issue/IDEA-149230/IDEA-is-unable-to-inline-super-class-in-method-with-generic-restriction,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,fail to refactoring,inline class,https://github.com/JetBrains/intellij-community/commit/b9b85cca9dde49fe34d25b8ee8c5dc14ced4284a,ast rewrite issue,"IDEA is unable to inline super class in method with generic restriction
import java.io.Serializable;

class Action implements Serializable {
}

class MyAction extends Action {
    <T extends Action> void m() {
    }
} Run inline on Action classExpectedclass MyAction implements Serializable {
    <T extends MyAction> void m() {
    }
} ActualNothing changed
"
https://youtrack.jetbrains.com/issue/IDEA-87654/Extract-method-fails-to-detect-input-variable-if-code-fragment-is-located-in-unreachable-else-branch,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,dead code block,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/961086a6d1dc2882c38c4b752267db41aec91816,flow analysis issue,"Extract method fails to detect input variable if code fragment is located in unreachable else branch
Affected in master, haven't tried it in the stable branchConsider the following code fragment:public class Test {

    public void test() {
        int a = 1;
        if (true) {
            System.out.println(a);
        } else {
            <selection>System.out.println(a);</selection>
        }
    }


}
 Apply extract method refactoring to the selected code fragment using all suggested values:Actual result:public class Test {

    public void test() {
        int a = 1;
        if (true) {
            System.out.println(a);
        } else {
            foo(); //bug
        }
    }

    private void foo() { //bug
        System.out.println(a);
    }


}
 Expected:public class Test {

    public void test() {
        int a = 1;
        if (true) {
            System.out.println(a);
        } else {
            foo(a);
        }
    }

    private void foo(int a) {
        System.out.println(a);
    }


}
 
"
https://youtrack.jetbrains.com/issue/IDEA-154669/Change-signature-should-remove-Override-when-refactor-only-current-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/2a9a2e65681faa7fbb2e88142f346d0a1707d9bb,ast rewrite issue,"Change signature should remove @Override when refactor only current method
Build: 146.1211Consider following code snippet:class Base {
   public void foo(int count) {}
}
class A extends Base {
    @Override
    public void foo(int count) {} // change signature
} Change signature foo method, but only from current method, not the base one. It leaves annotation @Override and makes code uncompilable.
"
https://youtrack.jetbrains.com/issue/IDEA-154628/Incorrect-constructor-...-will-become-inaccessible-...-warning-during-refactoring,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,incorrect warning message,Move class to upper level,https://github.com/JetBrains/intellij-community/commit/4c47e35b31d453f2cc92416e357ba10620cfaf55,overly strong preconditions,"Incorrect ""constructor ... will become inaccessible ..."" warning during refactoring
Steps to reproduce:1. Make packages foo and foo.bar2. Put class A into package foo:package foo;

public class A {
    protected A() {}

    public static class B extends A {
        public B() {
            super();
        }
    }
}Scala detected3. On inner class ""B"" do Refactor -> Move -> ""Move to upper level"" and select move to package ""foo.bar""Result: got warning ""constructor A.A() will become inaccessible from constructor B.B()"". If you'll press ""Continue"" - everything will be fine after refactoring, because protected constructor is accessible from subclass.IntelliJ IDEA (Minerva) IU-145.844.1Build #IU-145.844, built on April 5, 2016JRE: 1.8.0_76-release-b18 amd64JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o
"
https://youtrack.jetbrains.com/issue/IDEA-88471/Move-instance-method-can-generate-bad-code-when-moving-to-an-interface,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options,compile error,move method,https://github.com/JetBrains/intellij-community/commit/b47bf7ece188d892fc5122cbab57f4ab39bebfe5,overly weak preconditions,"""Move instance method"" can generate bad code when moving to an interface
With the following in the file MoveInstanceBug1.java:interface MyInterface {
}

class MyClass implements MyInterface {
}

public class MoveInstanceBug1 {
    private MyInterface myInterface;

    public void doSomething() {
    }
    
    public void callDoSomething() {
        doSomething();
    }
} place the caret on the ""doSomething"" method name, and press F6 (or Right Click, Refactor, Move...).In the ""Move Instance Method"" dialog: ensure that ""MyInterface myInterface"" is selected click the ""Private"" radio button for the Visibility click the Refactor buttonWe correctly get a message displayed saying:...MyInterface is an interface.  Method implementation will be added to all directly implementing classes.  Proceed?Click ""Yes"" to proceed, and we end up with the following bad code:interface MyInterface {
    private void doSomething();     // <---- On this line, ""private"" is marked in red (Modifier ""private"" not allowed here)
}

class MyClass implements MyInterface {
    public void doSomething() {
    }
}

public class MoveInstanceBug1 {
    private MyInterface myInterface;

    public void callDoSomething() {
        myInterface.doSomething();    // <---- On this line, ""doSomething"" is marked in red (doSomething() has private access in MyInterface)
    }
} There is a similar problem when selecting the ""Protected"" radio button.Here is what I think should be the correct behaviour for the Move Instance Method dialog (after pressing F6): Each instance parameter in the ""Select an instance parameter..."" list needs to determine whether it is a class or an interface. When an instance parameter is selected by the user (or by IntelliJ auto-selecting the first in the list when the dialog is shown) then: If that instance parameter is a class, show the Visibility radio buttons (as happens in the current version) Or if that instance parameter is an interface, hide the Visibility radio buttons (or grey them out and preselect Public) When the Refactor button is clicked: If the selected instance parameter is a class, proceed as in the current version Or if the selected instance parameter is an interface, show the current warning message: ""Method implementation will be added to all directly implementing classes"" and then if the user clicks Yes to proceed, generate the code as if Visibility had been set to Public.  NOTE: if the Language Level has been set to 6.0 or greater, we also need an @Override on the method in the class - see in the example below interface MyInterface {
    void doSomething();
}

class MyClass implements MyInterface {
    @Override
    public void doSomething() {
    }
}

public class MoveInstanceBug1 {
    private MyInterface myInterface;

    public void callDoSomething() {
        myInterface.doSomething();
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-88758/Dont-extract-variable-where-its-impossible,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/7de8a25c0b1b4f4434136dc1001b7718eedefaf5,overly weak preconditions,"Don't extract variable where it's impossible
Code:ArrayList<Obj> list;..(1)//(2)for(int i=0;i<list.size() && list.get(i).good();++i){(3)   list.get(i).doSomething();(4)   list.get(i).doAnother();(5)   list.get(i).done();(6)}I choose list.get(i) on 5th line and use Refactor->Extract->Variable.Actual result:I get two options extract only this occurrence or all 4 occurrences.If I choose second, it replace all occurrences to variable and put this variable to (1)-line, where i is undefined.Expected result:Replace only 3 occurrences and put definition to line between (2) and (3).
"
https://youtrack.jetbrains.com/issue/IDEA-154614/Rename-Class-refactoring-does-not-work-for-classes-with-inheriotors-with-lombok.NoArgsConstructor,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,exception,rename class,https://github.com/JetBrains/intellij-community/commit/b701c2987512728b7cc1e30a991bcb3a03d490b9,flow analysis issue,"Rename Class refactoring does not work for classes with inheriotors with @lombok.NoArgsConstructor
In version 15.0.5 (143.2332) same class can be renamed without any problem.2016-04-12 17:55:34,191 [2257681]  ERROR - ntellij.openapi.util.TextRange - IntelliJ IDEA 2016.1.1  Build #IU-145.597.3 2016-04-12 17:55:34,191 [2257681]  ERROR - ntellij.openapi.util.TextRange - JDK: 1.8.0_60 2016-04-12 17:55:34,191 [2257681]  ERROR - ntellij.openapi.util.TextRange - VM: Java HotSpot(TM) Server VM 2016-04-12 17:55:34,191 [2257681]  ERROR - ntellij.openapi.util.TextRange - Vendor: Oracle Corporation 2016-04-12 17:55:34,191 [2257681]  ERROR - ntellij.openapi.util.TextRange - OS: Windows 7 2016-04-12 17:55:34,191 [2257681]  ERROR - ntellij.openapi.util.TextRange - Last Action: NextTemplateVariable 2016-04-12 17:55:34,192 [2257682]  ERROR - m.intellij.util.ExecutorsQuery - element PsiAnnotation; startOffset -1 
java.lang.IllegalArgumentException: element PsiAnnotation; startOffset -1
 at com.intellij.usageView.UsageInfo.<init>(UsageInfo.java:56)
 at com.intellij.find.findUsages.JavaFindUsagesHelper.a(JavaFindUsagesHelper.java:624)
 at com.intellij.find.findUsages.JavaFindUsagesHelper.access$200(JavaFindUsagesHelper.java:50)
 at com.intellij.find.findUsages.JavaFindUsagesHelper$32.processInReadAction(JavaFindUsagesHelper.java:591)
 at com.intellij.find.findUsages.JavaFindUsagesHelper$32.processInReadAction(JavaFindUsagesHelper.java:588)
 at com.intellij.openapi.application.ReadActionProcessor$1.compute(ReadActionProcessor.java:31)
 at com.intellij.openapi.application.ReadActionProcessor$1.compute(ReadActionProcessor.java:28)
 at com.intellij.openapi.application.impl.ApplicationImpl.runReadAction(ApplicationImpl.java:962)
 at com.intellij.openapi.application.ReadActionProcessor.process(ReadActionProcessor.java:28)
 at com.intellij.util.UniqueResultsQuery$MyProcessor.process(UniqueResultsQuery.java:104)
 at com.intellij.openapi.application.QueryExecutorBase$1.process(QueryExecutorBase.java:52)
 at com.intellij.psi.impl.search.ConstructorReferencesSearchHelper.a(ConstructorReferencesSearchHelper.java:250)
 at com.intellij.psi.impl.search.ConstructorReferencesSearchHelper.a(ConstructorReferencesSearchHelper.java:228)
 at com.intellij.psi.impl.search.ConstructorReferencesSearchHelper.access$100(ConstructorReferencesSearchHelper.java:37)
 at com.intellij.psi.impl.search.ConstructorReferencesSearchHelper$4.process(ConstructorReferencesSearchHelper.java:126)
 at com.intellij.psi.impl.search.ConstructorReferencesSearchHelper$4.process(ConstructorReferencesSearchHelper.java:121)
 at com.intellij.util.UniqueResultsQuery$MyProcessor.process(UniqueResultsQuery.java:104)
 at com.intellij.openapi.application.QueryExecutorBase$1.process(QueryExecutorBase.java:52)
 at com.intellij.psi.impl.search.JavaClassInheritorsSearcher$3.processInReadAction(JavaClassInheritorsSearcher.java:117)
 at com.intellij.psi.impl.search.JavaClassInheritorsSearcher$3.processInReadAction(JavaClassInheritorsSearcher.java:100)
 at com.intellij.openapi.application.ReadActionProcessor$1.compute(ReadActionProcessor.java:31)
 at com.intellij.openapi.application.ReadActionProcessor$1.compute(ReadActionProcessor.java:28)
 at com.intellij.openapi.application.impl.ApplicationImpl.runReadAction(ApplicationImpl.java:962)
 at com.intellij.openapi.application.ReadActionProcessor.process(ReadActionProcessor.java:28)
 at com.intellij.util.UniqueResultsQuery$MyProcessor.process(UniqueResultsQuery.java:104)
 at com.intellij.util.containers.ContainerUtil.process(ContainerUtil.java:827)
 at com.intellij.psi.impl.search.JavaDirectInheritorsSearcher.a(JavaDirectInheritorsSearcher.java:225)
 at com.intellij.psi.impl.search.JavaDirectInheritorsSearcher.execute(JavaDirectInheritorsSearcher.java:144)
 at com.intellij.psi.impl.search.JavaDirectInheritorsSearcher.execute(JavaDirectInheritorsSearcher.java:49)
 at com.intellij.util.ExecutorsQuery.processResults(ExecutorsQuery.java:45)
 at com.intellij.util.AbstractQuery.forEach(AbstractQuery.java:75)
 at com.intellij.util.UniqueResultsQuery.process(UniqueResultsQuery.java:66)
 at com.intellij.util.UniqueResultsQuery.forEach(UniqueResultsQuery.java:56)
 at com.intellij.psi.impl.search.JavaClassInheritorsSearcher.a(JavaClassInheritorsSearcher.java:152)
 at com.intellij.psi.impl.search.JavaClassInheritorsSearcher.processQuery(JavaClassInheritorsSearcher.java:68)
 at com.intellij.psi.impl.search.JavaClassInheritorsSearcher.processQuery(JavaClassInheritorsSearcher.java:43)
 at com.intellij.openapi.application.QueryExecutorBase.execute(QueryExecutorBase.java:79)
 at com.intellij.util.ExecutorsQuery.processResults(ExecutorsQuery.java:45)
 at com.intellij.util.AbstractQuery.forEach(AbstractQuery.java:75)
 at com.intellij.util.UniqueResultsQuery.process(UniqueResultsQuery.java:66)
 at com.intellij.util.UniqueResultsQuery.forEach(UniqueResultsQuery.java:56)
 at com.intellij.psi.impl.search.ConstructorReferencesSearchHelper.processConstructorReferences(ConstructorReferencesSearchHelper.java:133)
 at com.intellij.psi.impl.search.MethodUsagesSearcher.processQuery(MethodUsagesSearcher.java:83)
 at com.intellij.psi.impl.search.MethodUsagesSearcher.processQuery(MethodUsagesSearcher.java:38)
 at com.intellij.openapi.application.QueryExecutorBase.execute(QueryExecutorBase.java:79)
 at com.intellij.util.ExecutorsQuery.processResults(ExecutorsQuery.java:45)
 at com.intellij.util.AbstractQuery.forEach(AbstractQuery.java:75)
 at com.intellij.util.MergeQuery.processSubQuery(MergeQuery.java:84)
 at com.intellij.util.MergeQuery.forEach(MergeQuery.java:56)
 at com.intellij.util.UniqueResultsQuery.process(UniqueResultsQuery.java:66)
 at com.intellij.util.UniqueResultsQuery.forEach(UniqueResultsQuery.java:56)
 at com.intellij.find.findUsages.JavaFindUsagesHelper.a(JavaFindUsagesHelper.java:588)
 at com.intellij.find.findUsages.JavaFindUsagesHelper.processElementUsages(JavaFindUsagesHelper.java:139)
 at com.intellij.codeInsight.daemon.impl.UnusedSymbolUtil.processUsages(UnusedSymbolUtil.java:265)
 at com.intellij.codeInspection.visibility.AccessCanBeTightenedInspection$MyVisitor.a(AccessCanBeTightenedInspection.java:151)
 at com.intellij.codeInspection.visibility.AccessCanBeTightenedInspection$MyVisitor.visitMethod(AccessCanBeTightenedInspection.java:100)
 at com.intellij.psi.impl.source.PsiMethodImpl.accept(PsiMethodImpl.java:294)
 at com.intellij.codeInspection.InspectionEngine.acceptElements(InspectionEngine.java:81)
 at com.intellij.codeInspection.InspectionEngine.createVisitorAndAcceptElements(InspectionEngine.java:69)
 at com.intellij.codeInsight.daemon.impl.LocalInspectionsPass.a(LocalInspectionsPass.java:294)
 at com.intellij.codeInsight.daemon.impl.LocalInspectionsPass.access$200(LocalInspectionsPass.java:73)
 at com.intellij.codeInsight.daemon.impl.LocalInspectionsPass$2.process(LocalInspectionsPass.java:261)
 at com.intellij.codeInsight.daemon.impl.LocalInspectionsPass$2.process(LocalInspectionsPass.java:256)
 at com.intellij.concurrency.ApplierCompleter.b(ApplierCompleter.java:128)
 at com.intellij.concurrency.ApplierCompleter.access$000(ApplierCompleter.java:44)
 at com.intellij.concurrency.ApplierCompleter$1.run(ApplierCompleter.java:91)
 at com.intellij.openapi.application.impl.ApplicationImpl.tryRunReadAction(ApplicationImpl.java:1178)
 at com.intellij.concurrency.ApplierCompleter$2.run(ApplierCompleter.java:100)
 at com.intellij.openapi.progress.impl.CoreProgressManager.a(CoreProgressManager.java:446)
 at com.intellij.openapi.progress.impl.CoreProgressManager.a(CoreProgressManager.java:443)
 at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:392)
 at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:54)
 at com.intellij.concurrency.ApplierCompleter.a(ApplierCompleter.java:112)
 at com.intellij.concurrency.ApplierCompleter.compute(ApplierCompleter.java:88)
 at jsr166e.CountedCompleter.exec(CountedCompleter.java:684)
 at jsr166e.ForkJoinTask.doExec(ForkJoinTask.java:260)
 at jsr166e.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:858)
 at jsr166e.ForkJoinPool.scan(ForkJoinPool.java:1687)
 at jsr166e.ForkJoinPool.runWorker(ForkJoinPool.java:1642)
 at jsr166e.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:108)
Java stack trace2016-04-12 17:55:34,192 [2257682]  ERROR - m.intellij.util.ExecutorsQuery - IntelliJ IDEA 2016.1.1  Build #IU-145.597.3 2016-04-12 17:55:34,192 [2257682]  ERROR - m.intellij.util.ExecutorsQuery - JDK: 1.8.0_60 2016-04-12 17:55:34,192 [2257682]  ERROR - m.intellij.util.ExecutorsQuery - VM: Java HotSpot(TM) Server VM 2016-04-12 17:55:34,192 [2257682]  ERROR - m.intellij.util.ExecutorsQuery - Vendor: Oracle Corporation 2016-04-12 17:55:34,193 [2257683]  ERROR - m.intellij.util.ExecutorsQuery - OS: Windows 7 2016-04-12 17:55:34,193 [2257683]  ERROR - m.intellij.util.ExecutorsQuery - Last Action: NextTemplateVariable
"
https://youtrack.jetbrains.com/issue/IDEA-150138/Refactoring-functional-interface-signatures,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,functional interface,incorrect warning message,change method signature,https://github.com/JetBrains/intellij-community/commit/b56e7e0c20e5d851154e7142daf0e38a296b77e9;https://github.com/JetBrains/intellij-community/commit/3fd8dfd38c619b257334e83e6540b4e9372ea7a6,ast rewrite issue,"Refactoring functional interface signatures
Refactoring the signature of a functional interface, specifically when changing the order of two parameters does not work correctly. Example:@FunctionalInterfaceinterface Operation<KeyT, PayloadT> {    void perform(PayloadT payload, KeyT key);}The desired functionality is to make the order of the parameters PayloadT and KeyT consistent with the order in which they are declared on the interface, using Ctrl+F6 (change signature). IntelliJ then warns that the functional expression will be corrupted, while expected is that all the implementing functional invocations would be refactored to reflect the changed parameter ordering as well.
"
https://youtrack.jetbrains.com/issue/IDEA-82043/change-signature-quick-fix-corrupts-text,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/83e19911839d219cc7e8fce3ad39cc07ecaae691,ast rewrite issue,"""change signature"" quick fix corrupts text
i have a method f(String s, Object o) {}I insert @NotNull anno into the param list to make it f(@NotNull String s, Object o){}Quick fix appears proposing me to apply change signature and if I press ok with default values, it corrupts the text making all usages look like ""f(,obj)""
"
https://youtrack.jetbrains.com/issue/IDEA-155147/move-method-breaks-method-reference-and-results-in-compile-error,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,move method,https://github.com/JetBrains/intellij-community/commit/35a27be9303c03396ad58423202f56722fbd42e7,ast rewrite issue,"'move method' breaks method reference and results in compile error
Initialpackage refactor;
import java.util.ArrayList;
import static java.util.stream.Collectors.toList;

public class MoveMethdBreaksReference {
    private static class Destination{ }

    private final Destination destination = new Destination();

    public void main(){
        new ArrayList<String>().stream().filter(this::notNull).collect(toList());
    }

    private boolean notNull(String it) {
        return it != null;
    }
} When performing 'Move instance Method' on notNull(...) to Destination I expectexpectedpackage refactor;
import java.util.ArrayList;
import static java.util.stream.Collectors.toList;

public class MoveMethdBreaksReference {
    private static class Destination{
        private boolean notNull(String it) {
            return it != null;
        }
    }

    private final Destination destination = new Destination();

    public void main(){
        new ArrayList<String>().stream().filter(destination::notNull).collect(toList());
    }
} but actually results in a compile error.Actualpackage refactor;
import java.util.ArrayList;
import static java.util.stream.Collectors.toList;

public class MoveMethdBreaksReference {
    private static class Destination{

        private boolean notNull(String it) {
            return it != null;
        }
    }

    private final Destination destination = new Destination();

    public void main(){
        new ArrayList<String>().stream().filter(MoveMethdBreaksReference.Destination::notNull).collect(toList());
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-155004/Unwrap-try-deletes-also-resources-section,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,try-with-resources,compile error,unwarp try,https://github.com/JetBrains/intellij-community/commit/38335c63874c3df035c5518d92fd91c5fd8d78f4,ast rewrite issue,"Unwrap 'try' deletes also resources section
CTRL+SHIFT+Del on try(resources) {} deletes the resource section... See the screenshots...
"
https://youtrack.jetbrains.com/issue/IDEA-151756/Pull-member-Up-refactoring-seems-work-incorrectly-for-interface-extention,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options,behavior change,pull members up,https://github.com/JetBrains/intellij-community/commit/1dc6f156cf920285b256ccd0998b1f8bccfdd0ce,ast rewrite issue,"'Pull member Up' refactoring seems work incorrectly for interface extention
Build: 144.4216Let's have such code:interface Animal {}

interface Mammal extends Animal {
    default String identifyMyself() {
        return ""Mammal"";
    }
} Suppose user wants to move declaration of identifyMyself up to Animal interface, but leave default implementation in Mammal. Then i assume user has to select this method and checkbox  'Make abstract'  as on screenshot below.But no matter if she/he selects Make abstract checkbox or not it moves default method to Animal class. So result code isinterface Animal {
    default String identifyMyself() {
        return ""Mammal"";
    }
}

interface Mammal extends Animal {
} // actually would be OK in case checkbox is unchecked but expected to beinterface Animal {
   String identifyMyself();
}

interface Mammal extends Animal {
    default String identifyMyself() {
        return ""Mammal"";
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-103174/JDK-1.8-Type-Annotations-Change-Signature-Refactoring-allows-adding-annotations-shows-them-in-preview-but-doesnt-actually-add,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,fail to refactoring,change method signature,https://github.com/JetBrains/intellij-community/commit/2805c474e359c3086557bc6c508ed07192db63bf,ast rewrite issue,"JDK 1.8: Type Annotations: Change Signature Refactoring allows adding annotations, shows them in preview, but doesn't actually add them
Build 129.24Consider an annotation and a method:@Target(ElementType.TYPE_USE)
public @interface Sample {} public String foo() { return null; } Invoke the refactoring for the method.Add @Sample to the return type, @Sample Integer p parameter and throws @Sample Exception clause.Check that everything is correctly shown in preview. Press Refactor.Result: the new parameter and the throws clause are added, but annotations are not.
"
https://youtrack.jetbrains.com/issue/IDEA-111017/Pull-Members-Up-Push-Members-Down-Refactorings-applied-to-an-interface-could-warn-about-the-interface-usages-as-anonymous,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,Pull Members Up,nan,nan,"Pull Members Up / Push Members Down Refactorings applied to an interface could warn about the interface usages as anonymous classes and lambdas
Build 130.1358Consider the following code:public interface JSam {
    void bar(String p);
}

interface JsamImpl extends JSam {
    void foo();
}

class User {
    void test() {
        JSam jSam = (String p) -> {};

        (new JSam() {
            public void bar(String p) {}
        }).bar("""");
    }
} Pushing bar down or pulling foo up shows no warning and results in invalid code.Result of Pull Up refactoring:public interface JSam {
    void bar(String p);

    void foo();
}

interface JsamImpl extends JSam {
}

class User {
    void test() {
        JSam jSam = (String p) -> {};       // error here

        (new JSam() {                       // and here
            public void bar(String p) {}
        }).bar("""");
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-151942/Problems-with-Pulling-Up-method-of-Inner-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,Pull Members Up,https://github.com/JetBrains/intellij-community/commit/0936ad00fd3e7d1d33e8fb3ff384aa6b05e9df0a,overly strong preconditions,"Problems with Pulling Up method of Inner class
Build: 144.4216There are couple problems with Pulling up method of inner class: one when it depends on variable of outside class and another when trying to make it abstract. As both problems are about warning, i put them in one case. Let me know if it's need to be divided.public class BaseInner {}

public class Outer {
    public int x = 0;
    public void foo(){};

    public class Inner extends BaseInner {
        void innerMethod() { // PULL this method UP
            System.out.println(Outer.this.x);
            Outer.this.foo();
        }
    }
} 1. When user pulls up method innerMethod() as is, it creates incompilable code as leaving references to Outer class fields and methods. Suppose there should be a warning in such situation.        System.out.println(Outer.this.x);
        Outer.this.foo(); 2. When user pulls up method innerMethod() and also sets checkbox to make it abstract, then warning below show, which seems not actual as nothing broken when user clicks 'Continue' button.
"
https://youtrack.jetbrains.com/issue/IDEA-152173/Inline-method-refactoring-allows-to-inline-instance-method-into-static-one,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,static method,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/8822f1e267fae513206e6ebcdffbc3af410a9c60,overly weak preconditions,"'Inline method' refactoring allows to inline instance method into static one
Build: 145.75Call to method of super class with construction super.xxx() could cause problems.public class A {
   void bar() {}
}

public class B extends A {
    void foo() {
        super.bar();
    }

    static void err(B b) {
        b.foo(); //inline call to foo()
    }
} Inlining call to b.foo() produces uncompilable code. Not sure if we could silently resolve such collision or have to show warning dialog.
"
https://youtrack.jetbrains.com/issue/IDEA-152175/Need-to-warn-when-Inline-and-delete-method-overridden-in-descendants,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/66248de9e43880553c97e8efaed87da7e243e891,flow analysis issue,"Need to warn when 'Inline and delete method' overridden in descendants
Build: 145.75When user inlines and removes the method which is overridden in descendants and have there @Override annotation then such changes produce uncompilable code.I think we should warn user about this situation the same as we warn user when inlined and removed method overrides some method. public class A {
    void foo() {}
}

public class B extends A {
    @Override //becomes erroneous after inlining
    void foo() {}

    void err() {
        super.foo(); //inline the method
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-152181/Inline-method-tries-to-inline-private-field,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/4f649256bc147f93a58f78af6a9e12c22780999a,overly weak preconditions,"'Inline method' tries to inline private field
Build:145.75When user tries to inline expression from superclass which contains reference to private variable it shows warning, but should it be method call of such variable no warning appears.Consider code below.public class A {
    private Integer i = 0;

    void foo() {
        i.toString();
    }
}

public class B extends A {
    void bar() {
        foo(); // inline foo
    }
} when inline foo() no warning appears as it should be and refactoring results in uncompilable code.
"
https://youtrack.jetbrains.com/issue/IDEA-152386/Change-method-signature-works-incorrectly-with-method-references-when-adding-exception,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,change method signature,https://github.com/JetBrains/intellij-community/commit/bebf4975e6c7c0899a3d738aa7b6c179dcd67266,flow analysis issue,"Change method signature works incorrectly with method references when adding exception
Build: 145.146Change method signature always suggests to convert method reference to lambda when new exception type added to the method signature:In case it's checked exception it creates uncompilable code.In case it's unchecked exception seems no need for conversion at all (similar to IDEA-152116). Furthermore immediately after such change inspection suggests to return it back to method reference.public class Action {
    public void acting(String s)  {
        System.out.println(s);
    }
}


public class Client {
    public static void consumer(String val, IFunc func) {
        func.func(val);
    }

    public static void main(String[] args) {
        Action a = new Action();
        consumer(""hello"", a::acting);
    }
} Checked exceptionAdding IOException to method acting() through  'Change signature'  refactoring, creates such code, which cannot be compiled:    public static void main(String[] args) {
        Action a = new Action();
        try {
            consumer(""hello"", (s) -> a.acting(s));
        } catch (java.io.IOException e) {
            e.printStackTrace();
        }
    } Unchecked exceptionAdding throws Error through the refactoring does unnecessary conversion to lambda.
"
https://youtrack.jetbrains.com/issue/IDEA-155518/Extract-method-leaves-fully-qualified-name,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/9b9a8d40515e86d53938b585f1570fe211989722,ast rewrite issue,"Extract method leaves fully qualified name
Before:import java.io.StringReader;

class X {
    
    Object f() {
        final StringReader reader = new StringReader(""""); // extract this line
        return reader;
    }
}Kotlin detectedInvoke Extract Method and change return type to ""Reader"" instead of ""StringReader""After:import java.io.StringReader;

class X {

    Object f() {
        final java.io.Reader reader = getStringReader();
        return reader;
    }

    private Reader getStringReader() {
        return new StringReader("""");
    }
}Kotlin detectedExpected: import statement fo java.io.Reader.
"
https://youtrack.jetbrains.com/issue/IDEA-150149/CtrlF6-Change-Class-Signature-can-generate-syntax-errors-when-adding-generic-type-arguments,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,change class signature,https://github.com/JetBrains/intellij-community/commit/4cd38d818d5f28e401cd0bb3e00751e02cec372a,flow analysis issue,"Ctrl+F6: Change Class Signature can generate syntax errors when adding generic type arguments
I use IntelliJ Ultimate 16+ EAP on Windows with Java 8.Sample code:    public final class X {
    }

    public final class Y {
        public static final Class<?> X_CLASS = X.class;
    }  Put cursor on X and strike Ctrl+F6. Add parameter, e.g., T -> Object  (see screenshot) Click button Refactor.Code after refactoring:    public final class X<T> {
    }

    public final class Y {
        public static final Class<?> X_CLASS = X<Object>.class;
                                             // ^^^^^^^^ syntax error
    } If this is intended behaviour, please kindly explain.  Else, it seems like a bug to me.
"
https://youtrack.jetbrains.com/issue/IDEA-104286/Change-Signature-Refactoring-to-functional-interface-should-affect-lambda-expressions,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,functional interface,compile error,change method interface,https://github.com/JetBrains/intellij-community/commit/ec1d4927bddec4275d9bf0ceb163a63003439a21,flow analysis issue,"Change Signature Refactoring to functional interface should affect lambda expressions
Consider the following code:Codepublic class LambdaRefactoring {

    static class Param { }

    static class Receiver {
        public void receive(LambdaInterface pInterface) {
            pInterface.lambda(new Param(), new Param());
        }
    }

    interface LambdaInterface {
        void lambda(Param param1, Param param2);
    }

    public static void main(String[] args) {
        new Receiver().receive((param1, param2) -> {
            System.out.println(""param1 = "" + param1);
            System.out.println(""param2 = "" + param2);
        });
    }
} Refactoring the receive-method signature by removing the 2nd argument leads to broken caller code in main method's lambda expression. I would have thought the interface usage could be detected and changed by the refactoring. There may be issues, if the lambda expression was stored in a variable prior to be used as a parameter. Direct parameter usage should be detected and changed, though, IMHO.I have seen a comment on the following issue explaining that correcting inconsistent lambda expressions on method signature refactorings is not always possible and therefore is not tried at all, if I understand correctly. Maybe differential treatment is possible, though...IDEABKL-6747 JDK 1.8: Change Signature Refactoring applied to a method of a functional interface could detect the interface instantiations using lambdas and method references
"
https://youtrack.jetbrains.com/issue/IDEA-155581/Push-down-refactoring-may-create-uncompilable-code-for-bounded-wildcard-generics,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,Push members down,https://github.com/JetBrains/intellij-community/commit/5965c21f4486acfe3889fde55d9e3aca4e0b131c,ast rewrite issue,"'Push down' refactoring may create uncompilable code for bounded wildcard generics
Build: 146.1669Consider following code snippet.class Parent<T> {
    void foo(List<? extends T> p) {} // push method down and keep abstract
}

class Child extends Parent {
} Push down foo method with enabled option keep abstract then it creates uncompilable code due name clash.abstract class Parent<T> {
    abstract void foo(List<? extends T> p) // push method down and keep abstract
    ;
}

class Child extends Parent {
    @Override
    void foo(List<? extends Object> p) {} // push method down and keep abstract
} 
"
https://youtrack.jetbrains.com/issue/IDEA-155578/Push-members-down-no-warning-when-move-generic-method-to-not-parametrized-super-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,Push members down,https://github.com/JetBrains/intellij-community/commit/efa0c5c53b2192fa6caf69b67efb6aa32c9f7a0e,overly weak preconditions,"'Push members down' - no warning when move generic method to not-parametrized super class
Build: 146.1669Consider code snipped below. Pushing down p and foo(T) works differently: for field p IDEA understands there is already such field. for method foo(T) it shows no warning as it should and does with common method conflict.class Parent<T> {
    T p; // push field down to 'Child' - warning - OK
    public void foo(T p) { // push method down to 'Child' - no warning - not OK
        System.out.println(""a"");
    }
}

class Child extends Parent {
    Object p;
    public void foo(Object p) {
        System.out.println(""b"");
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-155596/Push-members-down-JavaDoc-As-is-option-always-copy-comments-of-interfaces,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related;input options,comment related,Push members down,https://github.com/JetBrains/intellij-community/commit/1a70d8bcbd858b032639dd2206f01f8eb1cfe678,ast rewrite issue,"'Push members down' JavaDoc 'As is' option always copy comments of interfaces
Please consider code sample below. Invoke 'Push members down' for method foo() Select 'Keep abstract' for that method Select 'As is' or 'Move' for JavaDoc options. Click 'Refactor' button and note that JavaDoc section has been copied instead of left only in A or moved.When move class abstract method there is no such problem.interface A {
    /**
     *  push this method down to B
     */
    void foo();
}

interface B extends A {} 
"
https://youtrack.jetbrains.com/issue/IDEA-155600/Push-members-down-do-not-remove-Override-when-default-method-conflict-with-class-implementation,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,behavior change,Push members down,https://github.com/JetBrains/intellij-community/commit/c9f72daaff0e26bdfc7e740322b5e7edc756a1bb,ast rewrite issue,"'Push members down' - do not remove @Override when default method conflict with class implementation
Build: 146.1669Use code sample below: Invoke 'Push members down' refactoring for I.foo() Select 'keep abstract' and perform refactoring In 'Problems detected' dialog click 'Continue'Note that @Override annotation for C.foo() has been removed for some reason.Issues with removal of default method body address in a dedicated case IDEA-155599.interface I {
    default void foo() { // push method down
        System.out.println(""I"");
    }
}

class C implements I {
    @Override
    public void foo() { 
        System.out.println(""C"");
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-119700/Javadoc-Silently-Deleted-During-Refactoring,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,change method signature,https://github.com/JetBrains/intellij-community/commit/8a80f671c2ea7cb0206a9adf52c654aa56b59811,ast rewrite issue,"Javadoc Silently Deleted During Refactoring
Consider this example.    /**
     * @param x the first parameter
     */
    public static void f(String a) {
    } Note that the argument name is wrong in the Javadoc. Now refactor this method with Change Signature. For example add a new parameter b.  The refactored code now looks like this:    /**
     * @param b
     */
    public static void f(String a, String b) {
    } Note how the whole @param x documentation silently disappeared.
"
https://youtrack.jetbrains.com/issue/IDEA-153148/lambda-parameter-name-is-not-suggested-to-be-renamed-with-the-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,fail to refactoring,rename class,https://github.com/JetBrains/intellij-community/commit/738aa6428722c5b3c5290a209b0fa0f44475e3a2,flow analysis issue,"lambda parameter name is not suggested to be renamed with the class
class Foo {
    class Baz {}
    
    void test(Baz bar) {
        
    }

    void test1() {
        Baz bar = new Baz();
    }

    void test2() {
        List<Baz> bars = new ArrayList<>();
        bars.forEach(bar -> System.out.println(bar));
    }
} Rename Bar -> Baz, method param name, local variable and list variable are suggested to be renamed, but lambda param name - not.
"
https://youtrack.jetbrains.com/issue/IDEA-152837/Need-casting-for-inlined-variables,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline variable,https://github.com/JetBrains/intellij-community/commit/23113360f127123b37ac5f1696b64b4260ee7fc6,ast rewrite issue,"Need casting for inlined variables
Build: 146.433Consider below code sample, inlining of variables a or b on the last lines of the code creates uncompilable code.Please take into account IDEA-33666, to preserve such behavior.public class ConflictingInterfaces {
    interface A {}
    interface B {}

    class C implements A, B {}

    void print(A a) {
        System.out.println(a);
    }

    void print(B a) {
        System.out.println(a);
    }

    void test() {
        C one = new C();
        A a = one;
        B b = one;

        print(a); // inline a
        print(b); // inline b
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-152883/Non-required-cast-when-inline-this-reference-inside-local-class,Minor,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,local class,unnecessary change,inline variable,https://github.com/JetBrains/intellij-community/commit/ca2921eb6ef57f9493b91e4b2f4b8e4362446f49,ast rewrite issue,"Non required cast when inline 'this' reference inside local class
Build: 146. 433Consider next code sample:public class Outer extends BaseOuter {
    public void bar() {
        Outer foo = this;

        new Object() {
            public void run() {
                foo.baz(); // inline 'foo' variable
            }
        };
    }

    public void baz() {
    }
} Inlining foo variable inside local class creates next line of code:((Outer) Outer.this).baz(); where cast to outer is redundant, which is confirmed by inspection warning. It looks like a rare case when it's not necessary though.
"
https://youtrack.jetbrains.com/issue/IDEA-153254/Conversion-from-anonymous-class-to-lambda-could-lead-to-forward-reference-issue,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,replace with lambda,https://github.com/JetBrains/intellij-community/commit/6daac099e679ef35a859ea84938435102a35bdb2,overly weak preconditions,"Conversion from anonymous class to lambda could lead to forward reference issue
Comparing to lambda anonymous class may reference fields textually declared later. This is not recognized by inspection Anonymous type can be replaced with lambda and so may create uncompilable code.Simplified example based on IDEA code: com.intellij.openapi.ui.MasterDetailsComponentpublic class ForwardReference {
    Runnable TREE_UPDATER;

    {
        TREE_UPDATER = new Runnable() {  // convert to lambda
            @Override
            public void run() {
                 myTree.toString();
            }
        };
    }

    Object myTree;
} 
"
https://youtrack.jetbrains.com/issue/IDEA-91421/JDK-1.8-Inline-Refactoring-confusing-message-is-shown-on-attempt-to-inline-a-variable-defined-in-a-lambda-and-accessed-for,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/2c5beb00d0084603cf18123483d177fb5d05416d,flow analysis issue,"JDK 1.8: Inline Refactoring: confusing message is shown on attempt to inline a variable, defined in a lambda and accessed for writing
Build 122.335Sample to reproduce:Runnable x = () -> {
    int hello = 9;
    System.out.println(hello);
    ++hello;
    System.out.println(hello);
}; Try to inline hello. The following balloon will be shown:Cannot perform refactoring.Another variable 'hello' definition is used together with inlined one.
"
https://youtrack.jetbrains.com/issue/IDEA-90950/JDK-1.8-Inline-Refactoring-is-available-for-a-lambda-parameter-but-does-nothing,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,fail to refactoring,inline class,https://github.com/JetBrains/intellij-community/commit/42a97044c5d3f953fab726d73c30c87d7a9714f5,overly weak preconditions,"JDK 1.8: Inline Refactoring is available for a lambda parameter, but does nothing
Build 122.277Get a functional interfacepublic interface I {
    int m(ArrayList p);
} and a lambdaI i = <caret>p -> 0;Kotlin detectedPut the caret to the specified position.Open Refactor menu. See that Inline menu item is available.Press Ctrl+Alt+N. Nothing happens.We could show the same balloon which is shown on attempt to inline a parameter of a method in an anonymous class:Inline parameter is not supported when method is a part of inheritance hierarchy.
"
https://youtrack.jetbrains.com/issue/IDEA-98290/Refactor-Extract-Method-Object-invalid-resulting-code-for-extracting-from-static-method-with-processing-duplicates,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,input options;static method,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/e47dc7accbdc9e4edb717a0962c5264402834469,Incorrect Type Resolving,"Refactor / Extract Method Object: invalid resulting code for extracting from static method with processing duplicates
Provide code with static method like:class Bag {
    Integer x;
    Integer y;
}

public class Simple {
    public static void method() {
        Bag b = new Bag();
        b.x = 1 + 2;
        b.x = 1 + 2;
    }
}  Select 'b' token in any 'b.x' expression.Refactor / Extract Method Object. Provide class name in the dialog. Ok.Get Process Duplicates question dialog, agree,First, meet exception from IDEA-98288.Second, the resulting code is invalid. That's the subject of this issue:public class Simple {
    public static void method() {
        Bag b = new Bag();
        new Extract(b).new Extract().invoke().x = 1 + 2;
        new Extract(b).new Extract().invoke().x = 1 + 2;
    }

    private static class Extract {
        private Bag b;

        public Extract(Bag b) {
            this.b = b;
        }

        public static Bag invoke() {
            return b;
        }
    }
}  123.102.
"
https://youtrack.jetbrains.com/issue/IDEA-91061/JDK-1.8-Inline-Refactoring-doesnt-allow-to-inline-local-variables-to-lambdas,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,fail to refactoring,inline variable,https://github.com/JetBrains/intellij-community/commit/7a15a26cf2fb6ce2acf36033423dac2d3d764dae,flow analysis issue,"JDK 1.8: Inline Refactoring doesn't allow to inline local variables to lambdas
Build 122.290Sample to reproduce:void asd() {
    final String p = ""aa"";
    Runnable r = () -> System.out.println(p);
    System.out.println(p);
} Invoke the refactoring from the variable p definition. Result:void asd() {
    final String p;                    // declaration is not removed
    Runnable r = () -> System.out.println(p);    // usage is not inlined
    System.out.println(""aa"");
} Undo. Now invoke the refactoring from the usage in the lambda.Cannot perform refactoring. Cannot find a single definition to inline balloon is shown.
"
https://youtrack.jetbrains.com/issue/IDEA-91065/JDK-1.8-Wrap-Method-Return-Value-Refactoring-produced-invalid-code-if-return-value-is-a-lambda-with-return-statement,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,Wrap Method Return Value,https://github.com/JetBrains/intellij-community/commit/a06512b331af2bfb2cf8cd27967c79465ede8470,ast rewrite issue,"JDK 1.8: Wrap Method Return Value Refactoring produced invalid code if return value is a lambda with return statement
Build 122.290Sample to reproduce:Callable<String> helloCollable(String name) {
    return () -> {
        return ""Hello"" + "", "" + name;
    };
}Kotlin detectedSelect the lambda and apply the refactoring to it. Result:public class Wrapper {
    private final Callable<String> value;

    public Wrapper(Callable<String> value) {
        this.value = value;
    }

    public Callable<String> getValue() {
        return value;
    }
}Kotlin detectedWrapper helloCollable(String name) {
    return new Wrapper(() -> {
        return new Wrapper(""Hello"" + "", "" + name);
    });
}Kotlin detectedExpected result:Wrapper helloCollable(String name) {
    return new Wrapper(() -> {
        return ""Hello"" + "", "" + name;
    });
}Kotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-90879/JDK-1.8-Inline-Refactoring-should-handle-lambdas-properly,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,behavior change,inline variable,https://github.com/JetBrains/intellij-community/commit/25456a1938d6b7f7b639a94079a890443f62f3de,ast rewrite issue,"JDK 1.8: Inline Refactoring should handle lambdas properly
Build 122.264Consider the following code:FileFilter java = f -> f.getName().endsWith("".java"");
java.getClass();Kotlin detectedInline java is allowed and produces the following code:f -> f.getName().endsWith("".java"").getClass();Kotlin detectedThe refactoring either should not be allowed for such cases or should convert lambdas to anonymous classes and then inline.
"
https://youtrack.jetbrains.com/issue/IDEA-91371/JDK-1.8-Inline-Refactoring-doesnt-allow-to-inline-a-variable-declared-in-a-lambda,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,incorrect warning message,inline variable,https://github.com/JetBrains/intellij-community/commit/2bdd12295500ecf9eecc032e10c3750546f0e7b5;https://github.com/JetBrains/intellij-community/commit/9ddff21a9c31fb97af352845228bf1fed1fe9a75,flow analysis issue,"JDK 1.8: Inline Refactoring doesn't allow to inline a variable declared in a lambda
Build 122.327Sample to reproduce:Runnable x = () -> {
    String hello = ""hello"";
    System.out.println(hello);
};Kotlin detectedOn attempt to inline hello from definition the following balloon is shown:Cannot perform refactoring. Variable hello has no initializer.On attempt to inline from the usage:Cannot perform refactoring. Cannot find a single definition to inline.
"
https://youtrack.jetbrains.com/issue/IDEA-91122/JDK-1.8-Extract-Variable-Refactoring-applied-to-one-line-expression-lambda-code-that-references-lambda-parameters-adds-new,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,extract variable,https://github.com/JetBrains/intellij-community/commit/614b14316bbd432af050994e1a95bd3398f6f6b7;https://github.com/JetBrains/intellij-community/commit/a8ea5d4deb6b4a0879cce947b738d18464aede8d,ast rewrite issue,"JDK 1.8: Extract Variable Refactoring applied to one-line-expression lambda code that references lambda parameters adds new variable to outer scope
Build 122.299Sample to reproduce:public void foo() {
    FileFilter java = f -> f.getName().endsWith("".java"");
}Kotlin detectedExtract a variable from f.getName().endsWith("".java"").Result:public void foo() {
    final boolean b = f.getName().endsWith("".java"");    // f is not resolved
    FileFilter java = f -> b;
} Expected result should probably look like this:public void foo() {
    FileFilter java = f -> {
        final boolean b = f.getName().endsWith("".java"");
        return b;
    };
}Kotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-91126/JDK-1.8-Inline-a-void-method-to-an-one-line-expression-lambda-inlines-the-method-to-wrong-place,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,inline method,https://github.com/JetBrains/intellij-community/commit/51aa69e8da501827caae8382348e08ac62dd1548,ast rewrite issue,"JDK 1.8: Inline a void method to an one-line-expression lambda inlines the method to wrong place
Build 122.299Sample to reproduce:public class Sample {
    public void foo() {
        Runnable r = () -> bar();
    }

    private void bar() {
        System.out.println(""hello"");
    }
} Apply Inline Refactoring to bar(). Result:public class Sample {
    public void foo() {
        System.out.println(""hello"");
        Runnable r = () -> bar();
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-91150/JDK-1.8-Inline-Field-Refactoring-applied-to-a-lambda-field-doesnt-insert-cast,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,lambda,compile error,inline field,https://github.com/JetBrains/intellij-community/commit/9f014974eb636c466bab91c8822ef5a820126e5d,ast rewrite issue,"JDK 1.8: Inline Field Refactoring applied to a lambda field doesn't insert cast
Build 122.299Sample to reproduce:class Test {
    Runnable r = () -> {};
    void foo() {
        r.run();
    }
}Kotlin detectedAfter inlining r:class Test {
    void foo() {
        () -> {}.run();
    }
}Kotlin detected
"
https://youtrack.jetbrains.com/issue/IDEA-151440/No-Move-Members-refactoring-warning-when-move-will-hide-existing-member,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,behavior change,move method,https://github.com/JetBrains/intellij-community/commit/bf226f58ab2945a932c85000d9c5351c9fc37869,overly weak preconditions,"No Move Members refactoring warning when move will hide existing member
The Move Members refactoring does not warn when moving method important() or field 'truth' from class 'Three' to class 'Two' in the following code. This alters the behaviour of the code in the Two() constructor.class One {
    static boolean truth = true;
    static void important() {
        System.out.println(1);
    }
}
class Two extends One {
    Two() {
        important();
        System.out.println(truth);
    }
}
class Three {
    static boolean truth = false;
    static void important() {
        System.out.println(2);
    }
} When trying to move to class 'One' a warning is correctly provided. The refactoring should check in super classes also.
"
https://youtrack.jetbrains.com/issue/IDEA-91679/JDK-1.8-Pull-Members-Up-Refactoring-incorrectly-pulls-default-methods,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,Pull Members Up,https://github.com/JetBrains/intellij-community/commit/908de0d6a29002f566cf859796e91f3193b18063;https://github.com/JetBrains/intellij-community/commit/b12e3b2b7e5e3807be506d4406ecd7dad194963c,ast rewrite issue,"JDK 1.8: Pull Members Up Refactoring incorrectly pulls default methods
Build 122.362Sample to reproduce:interface Aaa {}

interface Bbb extends Aaa {
    void foo() default {
        System.out.println(""Bbb"");
    }
} Pull method foo() Up results with the following invalid code:interface Aaa {
    void foo() default;
}

interface Bbb extends Aaa {
    @Override
    void foo() default {
        System.out.println(""Bbb"");
    }
} 
"
https://youtrack.jetbrains.com/issue/IDEA-78519/move-method-refactoring-introduces-error-for-overloaded-methods,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,overloaded method,behavior change,move method,https://github.com/JetBrains/intellij-community/commit/f9af2b2245832bac8e85716466ded7ed597c53fa,ast rewrite issue,"move method refactoring introduces error for overloaded methods
In the following code, method m is overloaded, B and C are empty classes. When you move m(B) to C, the code in C is correct but the code in A is incorrect (see below).===============original code===============public class A {    public void m (B b){        System.out.println(this);    }    public void show(B b){        m(b);    }    public void m (C c){        System.out.println(this);    }}============================================result in B after moving m(B) to B (correct)============================================public void m(A a){        System.out.println(a);    }=======================result in A (incorrect)=======================public void show(B b){        b.m();    }=====================exprected result in A=====================public void show(B b){        b.m(this);    }
"
https://youtrack.jetbrains.com/issue/IDEA-86806/Errors-in-inlining-abstract-base-class,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,inline class,https://github.com/JetBrains/intellij-community/commit/d836edf6c52f4b01985cfa8cdfa079bff952e59e;https://github.com/JetBrains/intellij-community/commit/f33811b72d94e1aa570d4eb698eab2625011440a,ast rewrite issue,"Errors in inlining abstract base class
Given this base class:    private static abstract class BaseTask<T, S extends BaseTask<T, S>> extends RecursiveAction {        public final int depth;        public final ParallelStream<T> coll;        protected BaseTask(int depth, ParallelStream<T> coll) {            this.depth = depth;            this.coll = coll;        }        public abstract void seq();        public void combine(S left, S right) { }        public abstract S makeTask(int depth, ParallelStream<T> coll);        @Override        protected void compute() {        }    }and this subclass:    private static class ForEachTask<T> extends BaseTask<T, ForEachTask<T>> {        private static final long serialVersionUID = 1L;        private final Block<? super T> block;        ForEachTask(int depth, ParallelStream<T> coll, Block<? super T> block) {            super(depth, coll);            this.block = block;        }        public void seq() {        }        public ForEachTask<T> makeTask(int depth, ParallelStream<T> coll) {            return new ForEachTask<>(depth, coll, block);        }    }If I position cursor on BaseTask<T, ForEachTask<T>> and do the ""inline"" refactor, I get two errors: - The abstract class definition of makeTask() from the base class is not folded into the concrete implementation in ForEachTask, so I get errors related to the (a) method being abstract in a concrete class, (b) declared twice, and (c) not implemented. - (more serious) The constructor is not inlined properly.  Instead, all I get is:        ForEachTask(int depth, ParallelStream<T> coll, Block<? super T> block) {            toInline(depth, coll);            this.block = block;        }The ""toInline"" method looks like a placeholder for a remaining piece of the implementation?
"
https://youtrack.jetbrains.com/issue/IDEA-147503/Extract-variable-is-paranoid-when-it-comes-to-array-indices,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,unnecessary change,extract variable,https://github.com/JetBrains/intellij-community/commit/8405c1983286f6b7f4b72fb5b620a31071dc5e01,ast rewrite issue,"Extract variable is paranoid when it comes to array indices
Originalvoid f(int[] A, int i) {
    int temp = A[i + 1];
} Menu > Refactor > Extract > Variable...Actualvoid f(int[] A, int i) {
    int i1 = i + 1;
    int temp = A[(i1)]; // parens
} Expectedvoid f(int[] A, int i) {
    int i1 = i + 1;
    int temp = A[i1]; // no parens
} Any other occurrence that I've tested works as expected, e.g. int j = i + 1;.
"
https://youtrack.jetbrains.com/issue/IDEA-77194/Create-constructor-matching-super-generates-invalid-code,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,nan,compile error,Create constructor matching super,https://github.com/JetBrains/intellij-community/commit/f63576f8784a6941b549846afc51783c5d23c871,ast rewrite issue,"""Create constructor matching super"" generates invalid code
Enter the following in a Java file:class D extends java.sql.DateWait for the red underline to appearSelect ""Create constructor matching super""Select the first constructorThis is what you get:class D extends Date    public D(int year, int month, int day) {      super(year, month, day);    }IDEA doesn't insert the brackets round the class body
"
https://youtrack.jetbrains.com/issue/IDEA-97777/Extract-method-on-overloaded-methods-with-objects-in-same-hierarchy,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,overloaded methods,compile error,extract method,https://github.com/JetBrains/intellij-community/commit/a1096fae350856f2b62c54996cd378c90b2cfe1c,Incorrect Type Resolving,"Extract method on overloaded methods with objects in same hierarchy
For: public void myTest(List list, String s1, String s2) {         }  public void myTest(Collection list, String s1, String s2) {        } public void usage() {       List list = new ArrayList();        String aa = ""AA"";        String bb = ""bb"";        myTest(list, aa, bb);        Collection col = new ArrayList();        myTest(col, aa, bb);}When select last myTest invocation and apply ""Extract Method"" idea propose""IDEA has detected 1 code fragments in this file that can be replaced with a call to extracted method. Would you like to review and replace them?"" and if confirm replace first myTest invokation which is a different method.
"
https://youtrack.jetbrains.com/issue/IDEA-125995/Type-migration-should-accurate-change-definition-of-interface-class-method-with-generics,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,java generics,compile error,Type migration,https://github.com/JetBrains/intellij-community/commit/88204d4e1eaf5e0c28e843d0fd3806a0330d43ab,ast rewrite issue,"Type migration should accurate change definition of interface/class/method with generics
Initial code    public static void test() {
        Number n = new Interface<Number, Void>() {
            @Override
            public Number invoke(Void v) { // TODO: change <T> from Number to Integer. Cursor in the word Number of the line
                return Integer.valueOf(10);
            }
        }.invoke(null);
    }

    public static interface Interface<T, V> {
        T invoke(V v);
    } Put cursor on word Number (see comment in code)Run 'Type migration' and change Number to Integer.Expected:     public static void test() {
        Integer n = new Interface<Integer, Void>() {
            @Override
            public Integer invoke(Void v) {
                return Integer.valueOf(10);
            }
        }.invoke(null);
    }

    public static interface Interface<T, V> {
        T invoke(V v);
    } Got:
    public static void test() {
        Number n = new Interface<Number, Void>() {
            @Override
            public Integer invoke(Void v) {
                return Integer.valueOf(10);
            }
        }.invoke(null);
    }

    public static interface Interface<T, V> {
        Integer invoke(V v);
    } Interface declaration is completelly broken.
"
https://youtrack.jetbrains.com/issue/IDEA-90186/Severe-bug-with-Refactor-Migrate,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,annotation,compile error,Type migration,https://github.com/JetBrains/intellij-community/commit/2883d0ad379df8f8c6446f3d3b20dc0541f0e12d;https://github.com/JetBrains/intellij-community/commit/a87a832ccf6b49af60cb284cf3df1ac52984e569,ast rewrite issue,"Severe bug with Refactor -> Migrate
We tried to use    Refactor -> Migrate to move from    org.jetbrains.annotations.KS-KIM KS-KIM/@NotNullto   javax.annotation.KS-KIM KS-KIM/@NonnullSee migration map in the screenshot.The migration thoroughly messed up our annotations!It seems it randomly replaced any of the org.jetbrains annotations with either @Nonnull or javax.annotation.Nullable.In a test project if I migrate this class:package com.acme;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class Foo {

    @NotNull
    private String text;
    
    @Nullable
    private Integer value;

    public Foo(@NotNull String text, @Nullable Integer value) {
        this.text = text;
        this.value = value;
    }

    @NotNull
    public String getText() {
        return text;
    }

    public void setText(@NotNull String text) {
        this.text = text;
    }

    @Nullable
    public Integer getValue() {
        return value;
    }

    public void setValue(@Nullable Integer value) {
        this.value = value;
    }
}Kotlin detectedI end up withpackage com.acme;

import javax.annotation.Nullable;

public class Foo {

    @Nullable
    private String text;

    @Nullable
    private Integer value;

    public Foo(@Nullable String text, @Nullable Integer value) {
        this.text = text;
        this.value = value;
    }

    @Nullable
    public String getText() {
        return text;
    }

    public void setText(@Nullable String text) {
        this.text = text;
    }

    @Nullable
    public Integer getValue() {
        return value;
    }

    public void setValue(@Nullable Integer value) {
        this.value = value;
    }
}Kotlin detectedWhat the heck?Please make this feature work again in current IDEA builds - or else remove it completely!(It could use other improvements, too, for example code completion does not work in the ""Old name""/""New name"" fields when I create/edit a migration map.)Maybe it would be a good idea to add a migration map for org.jetbrains.annotations to javax.annotation by default and promote it in a Tip of the Day and maybe a blog article.
"
https://youtrack.jetbrains.com/issue/IDEA-79743/Extract-method-produces-redundant-cast,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,type cast,unnecessary change,extract method,https://github.com/JetBrains/intellij-community/commit/7d870ed6035e7055b8971f463d7c32184a08b636,ast rewrite issue,"Extract method produces redundant cast
If one of variables used through cast, IDEA generates redundant cast after method extraction.Steps to reproduce:            int a = 1;
            System.out.println("""" + (Object)a);
        } Select second line and Ctrl-Alt-M (Extract method), type method name and press OK.The code after refactoring will look like this:            int a = 1;
            test(a);
        }

        private void test(Object a) {
            System.out.println("""" + (Object)a);
        }
 As you can see, cast a to Object is redundant. Also note it's also reproducible with other classes than java.lang.Object and primitive types.
"
https://youtrack.jetbrains.com/issue/IDEA-81106/Generate-delegated-method-with-default-parameter-extracts-all-the-line-comments-from-the-original-method,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,comment related,comment related,Generate delegated method with default parameter,https://github.com/JetBrains/intellij-community/commit/b13cd651dc5f53da2ecc90bfdc25282e828124e4,ast rewrite issue,"'Generate delegated method with default parameter' extracts all the line comments from the original method
From this method:    @Override
    @NotNull
    public ConstraintSystemSolution solve(boolean dontFailOnNotEnoughInfo) {
        Solution solution = new Solution();
        // At this point we only have type values, no bounds added for them, no values computed for unknown types

        // After the parameters are inferred we will make sure the initial constraints are satisfied
        PriorityQueue<SubtypingConstraint> constraintsToEnsureAfterInference = new PriorityQueue<SubtypingConstraint>(constraintQueue);

        // Expand and solve constraints
        while (!constraintQueue.isEmpty()) {
            SubtypingConstraint constraint = constraintQueue.poll();

            // Apply constraint
            TypeValue lower = getTypeValueFor(constraint.getSubtype());
            TypeValue upper = getTypeValueFor(constraint.getSupertype());
            boolean success = expandSubtypingConstraint(lower, upper);
            if (!success) {
                solution.registerError(constraint.getErrorMessage());
//                break;
            }

            // (???) Propagate info

            // Any unknowns left?
            if (unsolvedUnknowns.isEmpty()) break;
        }


        // effective bounds for each node
//        Set<TypeValue> visited = Sets.newHashSet();
//        for (TypeValue unknownType : unknownTypes.values()) {
//            transitiveClosure(unknownType, visited);
//        }

        assert constraintQueue.isEmpty() || unsolvedUnknowns.isEmpty() : constraintQueue + "" "" + unsolvedUnknowns;

        for (TypeValue unknown : Sets.newLinkedHashSet(unsolvedUnknowns)) {
            if (!computeValueFor(unknown) && !dontFailOnNotEnoughInfo) {
                listener.error(""Not enough data to compute value for "", unknown);
                solution.registerError(""Not enough data to compute value for "" + unknown + "". Please, specify type arguments explicitly"");
            }
        }

        // Logging
        for (TypeValue unknownType : unknownTypes.values()) {
            listener.constraintsForUnknown(unknownType.getTypeParameterDescriptor(), unknownType);
        }
        for (TypeValue knownType : knownTypes.values()) {
            listener.constraintsForKnownType(knownType.getType(), knownType);
        }

        // Now, let's check the rest of the constraints and re-check the initial ones

        // Add constraints for the declared bounds for parameters
        // Maybe these bounds could reconcile some resolution earlier? Then, move them up
        for (Map.Entry<TypeParameterDescriptor, TypeValue> entry : Sets.newHashSet(unknownTypes.entrySet())) {
            TypeParameterDescriptor typeParameterDescriptor = entry.getKey();
            TypeValue unknown = entry.getValue();
            for (JetType upperBound : typeParameterDescriptor.getUpperBounds()) {
                constraintsToEnsureAfterInference.add(PARAMETER_BOUND.assertSubtyping(unknown.getOriginalType(), getTypeValueFor(upperBound).getOriginalType()));
//                unknown.addUpperBound(new TypeValue(upperBound));
            }
            for (JetType lowerBound : typeParameterDescriptor.getLowerBounds()) {
                constraintsToEnsureAfterInference.add(PARAMETER_BOUND.assertSubtyping(getTypeValueFor(lowerBound).getOriginalType(), unknown.getOriginalType()));
//                unknown.addLowerBound(new TypeValue(lowerBound));
            }
        }


        // Find inconsistencies

        // Check that all bounds are respected by solutions:
        // we have set some of them from equality constraints with known types
        // and thus the bounds may be violated if some of the constraints conflict


        for (SubtypingConstraint constraint : constraintsToEnsureAfterInference) {
            JetType substitutedSubtype = solution.getSubstitutor().substitute(constraint.getSubtype(), Variance.INVARIANT); // TODO
            if (substitutedSubtype == null) continue;
            JetType substitutedSupertype = solution.getSubstitutor().substitute(constraint.getSupertype(), Variance.INVARIANT); // TODO
            if (substitutedSupertype == null) continue;

            if (!typeChecker.isSubtypeOf(substitutedSubtype, substitutedSupertype)) {
                solution.registerError(constraint.getErrorMessage());
                listener.error(""Constraint violation: "", substitutedSubtype, "" :< "", substitutedSupertype, "" message: "", constraint.getErrorMessage());
            }
        }

        listener.done(solution, unknownTypes.keySet());

        return solution;
    } I get this one:    @Override
    @NotNull
    public ConstraintSystemSolution solve() {
        // At this point we only have type values, no bounds added for them, no values computed for unknown types

        // After the parameters are inferred we will make sure the initial constraints are satisfied

        // Expand and solve constraints


        // effective bounds for each node
//        Set<TypeValue> visited = Sets.newHashSet();
//        for (TypeValue unknownType : unknownTypes.values()) {
//            transitiveClosure(unknownType, visited);
//        }

        // Logging

        // Now, let's check the rest of the constraints and re-check the initial ones

        // Add constraints for the declared bounds for parameters
        // Maybe these bounds could reconcile some resolution earlier? Then, move them up


        // Find inconsistencies

        // Check that all bounds are respected by solutions:
        // we have set some of them from equality constraints with known types
        // and thus the bounds may be violated if some of the constraints conflict


        return solve();
    } 
"
https://youtrack.jetbrains.com/issue/IDEA-83353/When-move-refactoring-is-invoked-for-constant-initialized-in-static-initializer-it-breaks-compilation,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,static initializer,compile error,move field,https://github.com/JetBrains/intellij-community/commit/3d8ba2a63961ef471722ad6fa742d0ad9f4c57fc,overly weak preconditions,"When move refactoring is invoked for constant initialized in static initializer, it breaks compilation
Before:Class1.javapublic class Class1 {
    public final static String INITIALIZED_LATER;

    static {
        INITIALIZED_LATER = ""value"";
    }
} Class2.javapublic class Class2 {
} After:Class1.javapublic class Class1 {

    static {
        Class2.INITIALIZED_LATER = ""value"";
    }
} Class2.javapublic class Class2 {
    public final static String INITIALIZED_LATER;
} 
"
https://youtrack.jetbrains.com/issue/IDEA-354122,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,static initializer,compile error,move field,https://github.com/JetBrains/intellij-community/commit/3d8ba2a63961ef471722ad6fa742d0ad9f4c57fc,overly weak preconditions,"Extract Method refactoring produces refactored program contains syntax error
Steps to reproduce #


For the input program below, select the statement I have commented.


Refactor -> Extract Method, select the class Local as destination, then press Enter.


You can see the refactored program contains syntax error (as shown in the Actual result (faulty result)).


This happens because IntelliJ IDEA does not handle the usage of the parameter for the method ""void foo(int value)"" very well. For the extracted static method ""private static void extracted()"", the non-static parameter 'value' cannot be referenced from a static context.

Input program:
I have simplified the program to show the case.
public class A {
    void foo(int value) {
        class Local {
            void bar() {
                Runnable runnable = () -> {
                    System.out.println(value);// extract method on this statement
                };
            }
        }
    }
}

JavaExpected result (correct result):
public class A {
    void foo(int value) {
        class Local {
            void bar() {
                Runnable runnable = () -> {
                    extracted(value);
                };
            }

			private void extracted(int value) {
				System.out.println(value);
			}
        }
    }
}

Kotlin detectedActual result (faulty result):
public class A {
    void foo(int value) {
        class Local {
            void bar() {
                Runnable runnable = () -> {
                    extracted();
                };
            }

            private static void extracted() {
                System.out.println(value);// this line contains syntax error
            }
        }
    }
}

 
Environment #
OS version:
Windows 10, 64-bit Operating System, x64-based processor

IDE version (you can check via About dialog in the Help or App menu):
IntelliJ IDEA 2024.1.1 (Ultimate Edition) Build #IU-241.15989.150, built on April 29, 2024 Runtime version: 17.0.10+1-b1207.14 amd64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o

JDK version:
Oracle OpenJDK 17.0.8
"
https://youtrack.jetbrains.com/issue/IDEA-354116,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,static initializer,compile error,move field,https://github.com/JetBrains/intellij-community/commit/3d8ba2a63961ef471722ad6fa742d0ad9f4c57fc,overly weak preconditions,"Make Static refactoring erroneously qualifies calls inside the anonymous inheritor of the outer class
Steps to reproduce #


For the input program given below, run the input program, the output is ""Counter: 15""


Choose the method ""toBeRefactored()"", Refactor -> Make Static, click Refactor


Run the refactored program again, the output becomes ""Counter: 5""


I think this happens because the IntelliJ IDEA does not interpret a method call within an anonymous class inside the refactored method very well. As I comment on the Actual result (faulty result), the method invocation for the ""toCall()"" should not be performed on the added input parameter (i.e., Foo foo) of the refactored method. Current refactoring in the IDEA would silently change the behavior of the input program.


Input program:
I have simplified the program to show the case.
public class Foo {

    private int counter;

    public Foo(int initialCounter) {
        this.counter = initialCounter;
    }

    void toBeRefactored() {// make static refactoring on this method
        new Foo(counter + 10) {
            void toImplement() {
                toCall();
            }
        }.toImplement();
    }

    void toCall() {
        System.out.println(""Counter: "" + counter);
    }

    public static void main(String[] args) {
        Foo foo = new Foo(5);
        foo.toBeRefactored();
    }
}

 
Expected result (correct result):
public class Foo {

    private int counter;

    public Foo(int initialCounter) {
        this.counter = initialCounter;
    }

    static void toBeRefactored(Foo foo) {
        new Foo(foo.counter + 10) {
            void toImplement() {
                toCall();
            }
        }.toImplement();
    }

    void toCall() {
        System.out.println(""Counter: "" + counter);
    }

    public static void main(String[] args) {
        Foo foo = new Foo(5);
        Foo.toBeRefactored(foo);
    }
}

 Actual result (faulty result):
public class Foo {

    private int counter;

    public Foo(int initialCounter) {
        this.counter = initialCounter;
    }

    static void toBeRefactored(final Foo foo) {
        new Foo(foo.counter + 10) {
            void toImplement() {
                foo.toCall();// this line of refactored code is wrong
            }
        }.toImplement();
    }

    void toCall() {
        System.out.println(""Counter: "" + counter);
    }

    public static void main(String[] args) {
        Foo foo = new Foo(5);
        Foo.toBeRefactored(foo);
    }
}

 Environment #
OS version:
Windows 10, 64-bit Operating System, x64-based processor

IDE version (you can check via About dialog in the Help or App menu):
IntelliJ IDEA 2024.1.1 (Ultimate Edition) Build #IU-241.15989.150, built on April 29, 2024 Runtime version: 17.0.10+1-b1207.14 amd64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o

JDK version:
Oracle OpenJDK 17.0.8
"
https://youtrack.jetbrains.com/issue/IDEA-354039,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,static initializer,compile error,move field,https://github.com/JetBrains/intellij-community/commit/3d8ba2a63961ef471722ad6fa742d0ad9f4c57fc,overly weak preconditions,"Introduce Parameter refactoring changes the behavior of my program
Steps to reproduce #


Run the input program, the output is following:
aaa
aaa

 

Put the cursor at f() of ""a.f();"" in static void m(A a).


Right click, Refactor -> Introduce Parameter.


Choose ""Replace all 2 occurances"", then press Enter.


Run the refactored program, the output becomes to :
aaa

 

It is very obvious that the ""Introduce Parameter"" refactoring changes the behavior of my program, which is not what I want.
I have attached a short video in the attachment, hopefully it would make things more clear.

Input program:
I have simplified my program for better illustration. The input program is following:
public class A {
    int f() {
        System.out.println(""aaa"");
        return 0;
    }

    static void m(A a) {
        a.f();
        a.f();
    }

    public static void main(String[] args) {
        A a1 = new A();
        m(a1);
    }
}

Java
Actual result (faulty result):
public class A {
    int f() {
        System.out.println(""aaa"");
        return 0;
    }

    static void m(int f) {
    }

    public static void main(String[] args) {
        A a1 = new A();
        m(a1.f());
    }
}

Java
Environment #
OS version:
Windows 10, 64-bit Operating System, x64-based processor

IDE version (you can check via About dialog in the Help or App menu):
IntelliJ IDEA 2024.1.1 (Ultimate Edition) Build #IU-241.15989.150, built on April 29, 2024 Runtime version: 17.0.10+1-b1207.14 amd64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o

JDK version:
Oracle OpenJDK 17.0.8

Additional information #
The steps to reproduce the issue is attached in the short video.
"
https://youtrack.jetbrains.com/issue/IDEA-354040,Normal,Bug,Fixed,Java. Refactorings,10 Feb 2023,1,static initializer,compile error,move field,https://github.com/JetBrains/intellij-community/commit/3d8ba2a63961ef471722ad6fa742d0ad9f4c57fc,overly weak preconditions,"Change Signature refactoring fail to perform the change as shown in the preview
Steps to reproduce #


The input program includes one self-defined annotation and a class as shown in the input program.


Put cursor at method foo() in the class A, right click, Refactor -> Change Signature.


Click the Exception tab, then click the + to add, input the exception as following:
@Sample Exception

Ruby detected

The preview is shown in the UI, I have attached a screenshot in the attachment to show the preview, the preview is:
public String foo() throws @Sample Exception

 

Click Refactor, the refactored method is:
public String foo() throws Exception { return null; }

 The refactored program is not align with the preview, and not perform the change I want. Besides, there is no warning message, error message, or exception.


Input program:
I have simplified my program for better illustration. The input program is following:
First create an Annotation named Sample.
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

@Target(ElementType.TYPE_USE)
public @interface Sample {
}

JavaThen create the following code.
public class A {
    public String foo() { return null; }
}

 Expected result (correct result):
public class A {
    public String foo() throws @Sample Exception { return null; }
}

 Actual result (faulty result):
public class A {
    public String foo() throws Exception { return null; }
}

 
Environment #
OS version:
Windows 10, 64-bit Operating System, x64-based processor

IDE version (you can check via About dialog in the Help or App menu):
IntelliJ IDEA 2024.1.1 (Ultimate Edition) Build #IU-241.15989.150, built on April 29, 2024 Runtime version: 17.0.10+1-b1207.14 amd64 VM: OpenJDK 64-Bit Server VM by JetBrains s.r.o

JDK version:
Oracle OpenJDK 17.0.8
"
