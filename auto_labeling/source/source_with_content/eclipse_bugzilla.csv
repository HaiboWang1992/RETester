html_url,id_number,importance,product,component,assignee,status,resolution,summary,changeddate,symptom,has_patch,has_input_program,input_program_property,refactoring_type,root_cause,content_text
https://bugs.eclipse.org/bugs/show_bug.cgi?id=573643,573643,P3,JDT,UI,jdt-ui-inbox,RESO,FIXE,Over-enthusiastic refactor constructor argument to local variable,2023/6/8,behavior change,1,1,super constructor,extract local variable,overly weak preconditions,"Bug 573643 - Over-enthusiastic refactor constructor argument to local variable
Ed Willink 2021-05-19 10:35:56 EDT
In the following:

package bug;

import java.io.File;

public class MyFile extends File
{
	private String l;

	public MyFile(String parent, String child) {
		super(parent, child.toLowerCase());
		l = child.toLowerCase();
	}

}

selecting the second child.toLowerCase() and then Refactor->Extract Local Variable results in a failure popup reporting the consequences of refactoring the constructor argument.

Refactoring should ignore the constructor so that the result is an error free
	
	public MyFile(String parent, String child) {
		super(parent, child.toLowerCase());
		String lowerCase = child.toLowerCase();
		l = lowerCase;
	}
Sravan Kumar Lakkimsetti 2021-05-20 00:08:33 EDT
There is an option in the refactor popup ""Replace all occurrences of selected expression with reference to the local variable"", if this is checked(default behavior) you can see the behavior described in comment 0.

If unchecked the refactoring works as expected.
Ed Willink 2021-05-20 05:11:15 EDT
Yes, but in my original case the constructor body had multiple instances that I wanted to share, but of course I didn't need the refactoring to corrupt the super constructor argument.

In this case, the search for common sub-expressions should be aware of the control path rule that the super-constructor arguments are not path of the search tree.

(More generally, there needs to awareness of control to avoid hoisting a CSE above the definition point of one of its argument. Different detailed bug but possibly the same generic algorithmic flaw.)
Eclipse Genie 2023-05-26 06:18:03 EDT
This bug hasn't had any activity in quite some time. Maybe the problem got resolved, was a duplicate of something else, or became less pressing for some reason - or maybe it's still relevant but just hasn't been looked at yet.

If you have further information on the current state of the bug, please add it. The information can be, for example, that the problem still occurs, that you still want the feature, that more information is needed, or that the bug is (for whatever reason) no longer relevant.

--
The automated Eclipse Genie.
Jeff Johnston 2023-05-26 14:38:44 EDT
Fixed by: https://github.com/eclipse-jdt/eclipse.jdt.ui/pull/598
Jeff Johnston 2023-06-08 20:40:37 EDT
(In reply to Jeff Johnston from comment #4)
> Fixed by: https://github.com/eclipse-jdt/eclipse.jdt.ui/pull/598
Above closed and new PR created.

Fixed by: https://github.com/eclipse-jdt/eclipse.jdt.ui/pull/624
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=475186,475186,P3,JDT,Core,markus.kell.r,CLOS,FIXE,[search] for declarations finds overloaded method => wrong Rename refactoring,2022/4/13,behavior change,1,1,overloaded method,rename method,Incorrect Type Resolving,"Bug 475186 - [search] for declarations finds overloaded method => wrong Rename refactoring
Markus Keller 2015-08-17 12:19:59 EDT
master

- Have these two classes:

package jface;
public abstract class ViewerFilter {
	public abstract boolean selekt(String viewer, Object parentElement);
}

package jdt;
public abstract class AbstractInformationControl {
	protected class NamePatternFilter extends jface.ViewerFilter {
		void foo() {
			selekt("""", new Object());
		}
		
		@Override
		public boolean selekt(String viewer, Object parentElement) {
			return selekt(viewer, new Integer(1));
		}
		
		// rename this method:
		public boolean selekt(String viewer, Integer parentPath) {
			return false;
		}
	}
}


- try to use Refactor > Rename to rename the indicated method
=> expected: only the invocation in NamePatternFilter#selekt(String, Object) should be renamed.
=> was: more occurrences of identifier ""selekt"" are updated, including the method declaration ViewerFilter.selekt(String, Object), which should not be touched.

I can't reproduce the problem when I move the nested class NamePatternFilter into a top-level class.
And when I move the two top-level types into the same package, all ""selekt"" identifiers are renamed.


At the end of org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder2#findAllDeclarations(IProgressMonitor, WorkingCopyOwner), we call the SearchEngine with a pattern that should never find the homonym in ViewerFilter.

Looks like the bug is in MethodLocator#newDeclarationMatch(...).
Eclipse Genie 2015-08-17 12:25:58 EDT
New Gerrit change created: https://git.eclipse.org/r/53912
Markus Keller 2015-08-17 12:51:58 EDT
When running RunModelTests locally, I get one failure in org.eclipse.jdt.core.tests.model.JavaSearchBugsTests2.testBug395348(). However, that test just passed by chance, and not because of a correct implementation.

If you change the test slightly, then it also fails in master without my proposed fix (because it just assumes all homonyms in the supertype should match, even if they're not actually overridden by the search target):

	""public class X {\n""+
	""   static void f() {\n"" +
	""       new Y<Integer, C2>() {\n""+
	""           public int compare(C2 o1) {\n"" +
	""               return 0;\n"" +
	""           }\n"" +
	""       };\n""+
	""   }\n"" +
	""}\n"" +
	""abstract class Y<S extends Number, T> {\n"" +
	""  public abstract int compare(T o1);\n"" +
	""  public void compare(S shouldNotMatch) {}\n"" +
	""}\n"" +
	""class C2 {}\n""

The fix for bug 395348 was just about suppressing the NPE, not about fixing the actual problem.
Manoj N Palat 2018-05-16 01:38:17 EDT
Bulk move out of 4.8
Eclipse Genie 2020-05-19 03:46:12 EDT
This bug hasn't had any activity in quite some time. Maybe the problem got resolved, was a duplicate of something else, or became less pressing for some reason - or maybe it's still relevant but just hasn't been looked at yet. As such, we're closing this bug.

If you have further information on the current state of the bug, please add it and reopen this bug. The information can be, for example, that the problem still occurs, that you still want the feature, that more information is needed, or that the bug is (for whatever reason) no longer relevant.

--
The automated Eclipse Genie.
Andrey Loskutov 2022-04-13 12:09:10 EDT
Can't reproduce in  4.24 M1
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566879,566879,P3,JDT,UI,jjohnstn,VERI,FIXE,[15] refactoring pattern instanceof with Use SuperType option produces incorrect code,2022/1/5,compile error,1,1,instanceof,Use supertype wherever possible,Incorrect Type Resolving,"Bug 566879 - [15] refactoring pattern instanceof with Use SuperType option produces incorrect code
Manoj N Palat 2020-09-11 01:30:32 EDT
Given:

class X {
	
	private void foo(Object o) {
		if (o instanceof X x) {
			System.out.println(x.toString());
			x.foo(null);
		}

	}
}

Select X -> use context menu for Refactor->Use supertype wherever possible
gives:

class X {
	
	private void foo(Object o) {
		if (o instanceof Object x) {
			System.out.println(x.toString());
			x.foo(null); // error
		}

	}
}

error - incorrect code because x.foo() not applicable if x object?
Is this analysis happening in ui? OR is there any requirement for an api / api change from jdt.core?
Manoj N Palat 2020-09-11 01:31:38 EDT
Using Y build: 
Version: 2020-09 (4.17)
Build id: Y20200909-1200
Eclipse Genie 2021-11-12 15:28:41 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/187685
Eclipse Genie 2021-12-03 16:00:49 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/187685 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=089f70359797d008a18cf6101123b09ebed0e7bb
Jeff Johnston 2021-12-03 16:01:20 EST
Released for 4.23 M1
Jeff Johnston 2022-01-05 14:25:25 EST
Verified for 4.23 M1 using I20220105-0600 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566881,566881,P3,JDT,UI,jdt-ui-inbox,CLOS,FIXE,[15] refactor patterninstanceof for extracting a method gives wrong code,2021/11/9,compile error,0,1,instanceof,extract method,nan,"Bug 566881 - [15] refactor patterninstanceof for extracting a method gives wrong code
Manoj N Palat 2020-09-11 02:26:13 EDT
Given:

class X {
	private void foo(Object o) {
		if (o instanceof X x) { // select the entire o instanceof X x
			System.out.println(x.toString());
			x.foo(null);
		}

	}
} 

select the entire o instanceof X x and Refactor->Extract Method 
gives:

class X {
	private void foo(Object o) {
		if (extracted(o)) { // select the entire o instanceof X x
			System.out.println(x.toString());
			x.foo(null);
		}

	}

	private boolean extracted(Object o) {
		return o instanceof X x;
	}
} 

clearly an error at the method call extracted(o)

Y build

Version: 2020-09 (4.17)
Build id: Y20200909-1200
Jeff Johnston 2021-11-09 17:59:48 EST
This no longer occurs.  The Extract Method menu item is not offered for the Pattern instanceof.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=575718,575718,P3,JDT,Core,Vikas.Chandra,RESO,FIXE,[17][switch pattern][selection] Refactor operation on a Guarded pattern case variable reports an error in error log.,2021/9/7,exception,1,1,instanceof,-,selection parsing issue,"Bug 575718 - [17][switch pattern][selection] Refactor operation on a Guarded pattern case variable reports an error in error log.
Kalyan Prasad Tatavarthi 2021-08-31 06:30:47 EDT
In the below code

public static int bar(Object o) {
		return switch (o) {
		   case String c1 && (o instanceof String c3 && c3.length() > 0) -> 0;
		   default -> 0;
		};
	}

Select c1 right click and select Refactor > no operations appear here due to a crash reported 

as below

java.lang.ClassCastException: class org.eclipse.jdt.internal.compiler.ast.LocalDeclaration cannot be cast to class org.eclipse.jdt.internal.compiler.ast.Pattern (org.eclipse.jdt.internal.compiler.ast.LocalDeclaration and org.eclipse.jdt.internal.compiler.ast.Pattern are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @73f7f8be)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeGuardedPattern(Parser.java:10817)
	at org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:7494)
	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13039)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:2060)
	at org.eclipse.jdt.internal.codeassist.impl.AssistParser.parseBlockStatements(AssistParser.java:1900)
	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:349)
	at org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.java:312)
	at org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.java:1080)
	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:389)
	at org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.java:382)
	at org.eclipse.jdt.internal.ui.actions.SelectionConverter.codeResolve(SelectionConverter.java:270)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaTextSelection.resolveElementAtOffset(JavaTextSelection.java:102)


Expected: Various operations such as Rename etc should be available here.
Kalyan Prasad Tatavarthi 2021-08-31 06:32:38 EDT
(In reply to Kalyan Prasad Tatavarthi from comment #0)
> In the below code
> 
> public static int bar(Object o) {
> 		return switch (o) {
> 		   case String c1 && (o instanceof String c3 && c3.length() > 0) -> 0;
> 		   default -> 0;
> 		};
> 	}
> 
> Select c1 right click and select Refactor > no operations appear here due to
> a crash reported 
> 
> as below
> 
> java.lang.ClassCastException: class
> org.eclipse.jdt.internal.compiler.ast.LocalDeclaration cannot be cast to
> class org.eclipse.jdt.internal.compiler.ast.Pattern
> (org.eclipse.jdt.internal.compiler.ast.LocalDeclaration and
> org.eclipse.jdt.internal.compiler.ast.Pattern are in unnamed module of
> loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @73f7f8be)
> 	at
> org.eclipse.jdt.internal.compiler.parser.Parser.consumeGuardedPattern(Parser.
> java:10817)
> 	at
> org.eclipse.jdt.internal.compiler.parser.Parser.consumeRule(Parser.java:7494)
> 	at org.eclipse.jdt.internal.compiler.parser.Parser.parse(Parser.java:13039)
> 	at
> org.eclipse.jdt.internal.codeassist.impl.AssistParser.
> parseBlockStatements(AssistParser.java:2060)
> 	at
> org.eclipse.jdt.internal.codeassist.impl.AssistParser.
> parseBlockStatements(AssistParser.java:1900)
> 	at
> org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.
> java:349)
> 	at
> org.eclipse.jdt.internal.codeassist.impl.Engine.parseBlockStatements(Engine.
> java:312)
> 	at
> org.eclipse.jdt.internal.codeassist.SelectionEngine.select(SelectionEngine.
> java:1080)
> 	at org.eclipse.jdt.internal.core.Openable.codeSelect(Openable.java:167)
> 	at
> org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.
> java:389)
> 	at
> org.eclipse.jdt.internal.core.CompilationUnit.codeSelect(CompilationUnit.
> java:382)
> 	at
> org.eclipse.jdt.internal.ui.actions.SelectionConverter.
> codeResolve(SelectionConverter.java:270)
> 	at
> org.eclipse.jdt.internal.ui.javaeditor.JavaTextSelection.
> resolveElementAtOffset(JavaTextSelection.java:102)
> 
> 
> Expected: Various operations such as Rename etc should be available here.

This is an error reported in ErrorLog and not a crash as suggested before.
Manoj N Palat 2021-08-31 06:39:04 EDT
Issue reproduced; thanks @Kalyan.
@Vikas: This is pointing to Assist/Selection Parser issue - Could you please take a look? Assigning to you for further investigation
Eclipse Genie 2021-09-01 02:26:50 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/184828
Vikas Chandra 2021-09-01 06:59:56 EDT
I have skipped CCE in Selection Parser for now. This workarounds for most ( if not all) scenarios. Will keep this bug open to investigate further to find root cause.
Eclipse Genie 2021-09-01 07:00:28 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/184828 was merged to [BETA_JAVA17].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=92aa16ef9bf5b079b00bf067b5aa386dc61abd9d
Kalyan Prasad Tatavarthi 2021-09-01 07:40:34 EDT
This scenario is as a result of the code in SelectionParser.consumeInstanceOfExpressionWithName()

Here the second type pattern in the ASTStack is overwritten with the local variable.
Eclipse Genie 2021-09-01 08:33:24 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/184851
Jay Arthanareeswaran 2021-09-02 02:21:25 EDT
(In reply to Eclipse Genie from comment #7)
> New Gerrit change created:
> https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/184851

This doesn't work when we use the same variable name, for e.g.:

case String c1 && (o instanceof String c1 && c1.length() > 0) -> 0;

Yes, this code has an error but it still shouldn't throw a CCE.

IMO, it would be better if the solution filters out local declarations based on source range rather than names. Other points:

* I find the addOnAst to be unnecessary. We could have simply moved the pushOnAstStack() call to the innermost IF that checks the name equality or source range, whichever we decide.
* The code that follows the ""instanceof SelectionOnLocalName"" can be nested inside the IF. That way we could simply avoid the null check of name1.
Vikas Chandra 2021-09-04 03:54:25 EDT
(In reply to Jay Arthanareeswaran from comment #8)
> (In reply to Eclipse Genie from comment #7)
> > New Gerrit change created:
> > https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/184851
> 
> This doesn't work when we use the same variable name, for e.g.:
> 
> case String c1 && (o instanceof String c1 && c1.length() > 0) -> 0;
> 
> Yes, this code has an error but it still shouldn't throw a CCE.
> 
> IMO, it would be better if the solution filters out local declarations based
> on source range rather than names. Other points:
> 
> * I find the addOnAst to be unnecessary. We could have simply moved the
> pushOnAstStack() call to the innermost IF that checks the name equality or
> source range, whichever we decide.
> * The code that follows the ""instanceof SelectionOnLocalName"" can be nested
> inside the IF. That way we could simply avoid the null check of name1.

Thanks Jay. I have now modified the code to filter out local declarations based on source range. Also I have removed addOnAst.
Eclipse Genie 2021-09-07 02:06:25 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/184851 was merged to [BETA_JAVA17].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=57fbcbfb9e416b750e0a2397a52a1f41055706c7
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=573884,573884,P3,JDT,UI,jjohnstn,VERI,FIXE,"[refactoring] ""Extract superclass"" produces compile errors",2021/8/17,compile error,1,1,super constructor,extract superclass,ast rewrite issue,"Bug 573884 - [refactoring] ""Extract superclass"" produces compile errors
Juergen Baier 2021-06-01 08:34:01 EDT
The ""Extract Superclass"" refactoring does not seem to work correctly.


If I have

public class MyClass {

	private final String a;
	private final String b;

	public MyClass(String a, String b) {
		this.a = a;
		this.b = b;
	}

	public String getA() {
		return a;
	}

	public String getB() {
		return b;
	}

}

and I want to extract a superclass ""MySuperclass"" and I choose to extract all members and all methods then I get

public class MyClass extends MySuperclass {

	public MyClass(String a, String b) {
		this.a = a;
		this.b = b;
	}

}
public class MySuperclass {

	protected final String a;
	protected final String b;

	public MySuperclass() {
		super();
	}

	public String getA() {
		return a;
	}

	public String getB() {
		return b;
	}

}

with compile errors in both classes. I would have expected

public class ExtractSuperclass extends MySuperclass {

	public ExtractSuperclass(String a, String b) {
		super(a, b);
	}

}
public class MySuperclass {

	protected final String a;
	protected final String b;

	public MySuperclass(String a, String b) {
		super();
		this.a = a:
		this.b = b;
	}

	public String getA() {
		return a;
	}

	public String getB() {
		return b;
	}

}

I was wondering why such a simple case fails. Maybe I'm missing something?
Vikas Chandra 2021-06-02 05:00:59 EDT
Moving to jdt.ui for initial investigation
Eclipse Genie 2021-07-20 21:40:20 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/183208
Eclipse Genie 2021-07-23 15:21:28 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/183208 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=d594121490e7ece91f116c049ee586f7720074bd
Jeff Johnston 2021-07-23 18:56:50 EDT
Released for 4.21 M2
Eclipse Genie 2021-08-10 16:23:21 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/183870
Eclipse Genie 2021-08-10 18:07:49 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/183870 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=35594ece07370cc4bc400f7c1001ba531ad9a708
Juergen Baier 2021-08-11 01:43:23 EDT
Thanks for the fix :-)
Eclipse Genie 2021-08-16 16:50:45 EDT
New Gerrit change created: https://git.eclipse.org/r/c/www.eclipse.org/eclipse/news/+/184103
Eclipse Genie 2021-08-16 16:50:47 EDT
Gerrit change https://git.eclipse.org/r/c/www.eclipse.org/eclipse/news/+/184103 was merged to [master].
Commit: http://git.eclipse.org/c/www.eclipse.org/eclipse/news.git/commit/?id=72d14cf6e52ed2220b46e2a534a52e7da9096488
Jeff Johnston 2021-08-17 14:40:03 EDT
Verified for 4.21 M3 using I20210817-0600 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=574736,574736,P3,JDT,UI,sarika.sinha,RESO,FIXE,[17] Refactor rename of local variable used in Pattern Matching for switch results in error,2021/8/12,exception,1,1,switch case,rename variable,selection parsing issue,"Bug 574736 - [17] Refactor rename of local variable used in Pattern Matching for switch results in error
Vikas Chandra 2021-07-08 08:35:01 EDT
Created attachment 286757 [details]
Problem shown in the image

public static void main(String[] args) {

foo(Integer.valueOf(5));
foo(new Object());
}
private static void foo(Object o) {
 int local=0;
 switch (o) {
	case Integer i     : System.out.println(""Integer:"" + i);
	case String /*here*/str && local>0    : System.out.println(""String:"" + str + str);
	default       : System.out.println(""Object"" + o);
 	}
}
}



Try renaming  local to local2. You can see an error message and refactor-> rename is unsuccessful. See image
Kalyan Prasad Tatavarthi 2021-08-12 03:39:50 EDT
fixed as a result of fix for bug 573941
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=559681,559681,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[14] Refactor rename is not working for component of a record.,2021/6/15,compile error,1,1,record,rename field,Incorrect Type Resolving,"Bug 559681 - [14] Refactor rename is not working for component of a record.
Vikas Chandra 2020-01-30 00:20:58 EST
Refactor rename is not working for component of a record.
Eclipse Genie 2020-02-20 05:51:47 EST
New Gerrit change created: https://git.eclipse.org/r/158029
Eclipse Genie 2020-02-20 05:51:59 EST
New Gerrit change created: https://git.eclipse.org/r/158030
Kalyan Prasad Tatavarthi 2020-02-20 06:09:30 EST
With the below two patches, one in jdt core and one in jdt ui. I have tried rename of Record Component on below code

Create a Record Circle with the below Code
public record Circle(long radius) implements Shape{
	/**
	 * create unit radius circle
	 */
	public Circle {		
		this.radius= radius;
	}
	public void Circle2(long radius) {
	}
	@Override
	public long area() {
		// TODO Auto-generated method stub
		return ((22*radius()*radius())/7);
	}
}

Create an Interface Shape wit the below code
interface Shape {

}
Kalyan Prasad Tatavarthi 2020-02-20 06:15:01 EST
With the below two patches, one in jdt core and one in jdt ui. I have tried
rename of Record Component on below code

Create a Record Circle with the below Code
public record Circle(long radius) implements Shape{
	/**
	 * create unit radius circle
	 */
	public Circle {		
		this.radius= radius;
	}
 	public void Circle2(long radius) {
 	}
 	@Override
 	public long area() {
 		// TODO Auto-generated method stub
 		return ((22*radius()*radius())/7);
 	}
}
 
Create an Interface Shape wit the below code

public interface Shape {

    public long area(); 
}

Now select radius record component in first line ""
public record Circle(long radius) implements Shape{""

and press Shift+Alt+R (refactor > rename) . All the references are highlighted. Now rename and press enter. the accessor methods in the function area donot get renamed.

This is because org.eclipse.jdt.internal.corext.refactoring.rename.RenameFieldProcessor.getReferences does not get accessor references.This depends on Jdt Core search.
Vikas Chandra 2020-02-21 06:23:54 EST
>>org.eclipse.jdt.internal.corext.refactoring.rename.RenameFieldProcessor.getRefer>>nces does not get accessor references.This depends on Jdt Core search.

Created API for 2 patterns that can be used to search field and accessor methods. ( from either field or accessor method)

See WIP here -> https://git.eclipse.org/r/158074

Sample usage below-  However you need to check that you are doing this for a field of a record only.

RefactoringSearchEngine.search(SearchPattern.createFieldOrAccessorMethodORPattern(fField), createRefactoringScope(),
				new CuCollectingSearchRequestor(binaryRefs), pm, status);

For method, it can be modified to ( but only for accessorMethod of record)
private SearchPattern createAccessorMethodPattern() {
		StringBuilder stringPattern= new StringBuilder(getNewElementName()).append('(');
		int paramCount= getMethod().getNumberOfParameters();
		for (int i= 0; i < paramCount; i++) {
			if (i > 0)
				stringPattern.append(',');
			stringPattern.append('*');
		}
		stringPattern.append(')');
		return SearchPattern.createAcccessorMethodOrFieldORPattern(stringPattern.toString());
	}



And if the result is rejecting elements that are not IMethod, that needs to be fixed too.
Eclipse Genie 2020-02-25 00:43:33 EST
Gerrit change https://git.eclipse.org/r/158029 was merged to [BETA_JAVA14].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=fc369a2f5999be035d8b3bf583ddd0e3d7a1d78e
Eclipse Genie 2020-03-04 04:00:51 EST
Gerrit change https://git.eclipse.org/r/158030 was merged to [BETA_JAVA14].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=7ace3456976cb4d31ea34b44af5574fe3ce4abd4
Vikas Chandra 2020-03-17 11:23:22 EDT
verified on

Version: 2020-03 (4.15)
Build id: Y20200317-0225
Stephan Herrmann 2021-06-08 10:32:32 EDT
One test file here has a syntax error, which I believe is not intended?

class B(){
...
}

When running these tests against Object Teams, it actually fails saying:

ERROR: 'TestProject1622755955074/src/p/B.java' has syntax errors. Content of that file will not be updated.

In my case this is reported from this stack:
	Checks.excludeCompilationUnits(SearchResultGroup[], RefactoringStatus) line: 606	
	RenameFieldProcessor.analyzeAffectedCompilationUnits() line: 695	
	RenameFieldProcessor.doCheckFinalConditions(IProgressMonitor, CheckConditionsContext) line: 543	
	RenameFieldProcessor(JavaRenameProcessor).checkFinalConditions(IProgressMonitor, CheckConditionsContext) line: 51	
	RenameRefactoring(ProcessorBasedRefactoring).checkFinalConditions(IProgressMonitor) line: 226	
	RenameRefactoring(Refactoring).checkAllConditions(IProgressMonitor) line: 165	
	CheckConditionsOperation.run(IProgressMonitor) line: 82	
	CreateChangeOperation.run(IProgressMonitor) line: 122	
	PerformChangeOperation.run(IProgressMonitor) line: 210	
	Workspace.run(ICoreRunnable, ISchedulingRule, int, IProgressMonitor) line: 2313	
	Workspace.run(IWorkspaceRunnable, IProgressMonitor) line: 2333	
	RenameRecordElementsTests(GenericRefactoringTest).executePerformOperation(PerformChangeOperation, IWorkspace) line: 367	
	RenameRecordElementsTests(GenericRefactoringTest).performRefactoring(Refactoring, boolean) line: 345	
	RenameRecordElementsTests(GenericRefactoringTest).performRefactoring(Refactoring) line: 290	
	RenameRecordElementsTests.renameRecordCompactConstructor(String, String, boolean, boolean, boolean) line: 149	
	RenameRecordElementsTests.testRenameRecordCompactConstructorImplicitAccessor() line: 339	


In the original context this is not detected, because only A.java is contained in the search scope of RenameFieldProcessor.getReferences(IProgressMonitor, RefactoringStatus). I don't know, whether or not the limited scope is OK. All I can see is that only the wider scope triggers the error.


In a sibling test case the same thing has been fixed via bug 573644 :)
Eclipse Genie 2021-06-09 02:54:55 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/181682
Eclipse Genie 2021-06-09 05:39:30 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/181682 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=b1202b8d9e8699da06605be04ca114b533bb5442
Stephan Herrmann 2021-06-09 07:57:43 EDT
(In reply to Eclipse Genie from comment #11)
> Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/181682 was
> merged to [master].
> Commit:
> http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/
> ?id=b1202b8d9e8699da06605be04ca114b533bb5442

thanks! :)
Eclipse Genie 2021-06-14 04:14:42 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/181905
Eclipse Genie 2021-06-14 04:19:09 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/181905 was merged to [BETA_JAVA17].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=654ab86020db1a9b08cc620d7ce8fd7a4dc1f3df
Eclipse Genie 2021-06-15 03:47:17 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/181965
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=572100,572100,P3,JDT,Core,Vikas.Chandra,VERI,FIXE,[refactoring][search] [record] Move Type to a New File ... throws a ClassCastException,2021/6/2,exception,1,1,record,Move member type to new File,Incorrect Type Resolving,"Bug 572100 - [refactoring][search] [record] Move Type to a New File ... throws a ClassCastException
Rémi Forax 2021-03-19 06:49:29 EDT
Version: 2021-03 (4.19)
Build id: I20210303-1800

Use the code below and try to do a refactor Move type to a new File on ""Layout"",
it generates a CCE.
It seems due to the interface Layout being implemented by record.

----

package com.github.forax.tomahawk.schema;

import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;

import static java.util.Collections.unmodifiableMap;
import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.joining;
import static java.util.stream.Collectors.toMap;

public interface Schema {
  interface Layout /*permits Layout.PrimitiveLayout, Layout.ListLayout, Layout.StructLayout*/ {
    default boolean isPrimitive() {
      return this instanceof PrimitiveLayout;
    }
    default boolean isList() {
      return this instanceof ListLayout;
    }
    default boolean isStruct() {
      return this instanceof StructLayout;
    }
    boolean nullable();
    default Map<String, Layout> fields() {
      return Map.of();
    }
    default Layout field(String name) {
      throw new IllegalArgumentException(""unknown field "" + name);
    }
    default Layout element() {
      throw new IllegalArgumentException(""no element"");
    }

    static PrimitiveLayout u1(boolean nullable) {
      return new PrimitiveLayout(nullable, boolean.class);
    }
    static PrimitiveLayout byte8(boolean nullable) {
      return new PrimitiveLayout(nullable, byte.class);
    }
    static PrimitiveLayout short16(boolean nullable) {
      return new PrimitiveLayout(nullable, short.class);
    }
    static PrimitiveLayout char16(boolean nullable) {
      return new PrimitiveLayout(nullable, char.class);
    }
    static PrimitiveLayout int32(boolean nullable) {
      return new PrimitiveLayout(nullable, int.class);
    }
    static PrimitiveLayout float32(boolean nullable) {
      return new PrimitiveLayout(nullable, float.class);
    }
    static PrimitiveLayout double64(boolean nullable) {
      return new PrimitiveLayout(nullable, double.class);
    }
    static PrimitiveLayout long64(boolean nullable) {
      return new PrimitiveLayout(nullable, long.class);
    }

    static ListLayout list(boolean nullable, Layout layout) {
      return new ListLayout(nullable, layout);
    }
    static ListLayout string(boolean nullable) {
      return list(true, char16(nullable));
    }

    static Field field(String name, Layout layout) {
      return new Field(name, layout);
    }
    static StructLayout struct(boolean nullable, Field... fields) {
      return new StructLayout(nullable, Arrays.stream(fields).collect(toMap(Field::name, Field::layout, (_1, _2) -> null, LinkedHashMap::new)));
    }

    private static String toString(String space, Layout layout) {
      if (layout instanceof PrimitiveLayout primitiveLayout) {
        return primitiveLayout.toString();
      }
      if (layout instanceof ListLayout listLayout) {
        if (listLayout.element instanceof PrimitiveLayout elementLayout && elementLayout.type == char.class) {
          return ""string("" + elementLayout.nullable + "")"";
        }
        return ""list("" + listLayout.nullable + "", "" + toString(space, listLayout.element);
      }
      if (layout instanceof StructLayout structLayout) {
        if (structLayout.fields.isEmpty()) {
          return ""struct("" + structLayout.nullable + "")"";
        }
        var newSpace = space + ""   "";
        return structLayout.fields.entrySet().stream()
            .map(e -> newSpace + ""field(\"""" + e.getKey() + ""\"", "" + toString(newSpace, e.getValue()) + "")"")
            .collect(joining("",\n"", ""struct("" + structLayout.nullable + "",\n"", ""\n"" + space + "")""));
      }
      throw new AssertionError();
    }

    record PrimitiveLayout(boolean nullable, Class<?> type) implements Layout {
      public PrimitiveLayout {
        requireNonNull(type);
        if (!type.isPrimitive()) {
          throw new IllegalArgumentException(""only primitive types are allowed"");
        }
      }

      @Override
      public String toString() {
        var name = switch(type.getName()) {
          case ""boolean"" -> ""u1"";
          case ""byte"" -> ""byte8"";
          case ""short"" -> ""short16"";
          case ""char"" -> ""char16"";
          case ""int"" -> ""int32"";
          case ""float"" -> ""float32"";
          case ""long"" -> ""long64"";
          case ""double"" -> ""double64"";
          default -> throw new AssertionError();
        };
        return name + ""("" + nullable + "")"";
      }
    }
    record ListLayout(boolean nullable, Layout element) implements Layout {
      public ListLayout {
        requireNonNull(element);
      }

      @Override
      public String toString() {
        return Layout.toString("""", this);
      }
    }
    record StructLayout(boolean nullable, Map<String, Layout> fields) implements Layout {
      public StructLayout {
        fields = new LinkedHashMap<>(fields);
      }
      
      @Override
      public Layout field(String name) {
        var layout = fields.get(name);
        if (layout == null) {
          throw new IllegalArgumentException(""unknown field "" + name);
        }
        return layout;
      }

      @Override
      public Map<String, Layout> fields() {
        return unmodifiableMap(fields);
      }

      @Override
      public String toString() {
        return Layout.toString("""", this);
      }
    }
    record Field(String name, Layout layout) {
      public Field {
        requireNonNull(name);
        requireNonNull(layout);
      }

      @Override
      public String toString() {
        return ""field("" + name + "", "" + layout + "")"";
      }
    }
  }
}

---

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:397)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:662)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:504)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.getStartingPage(RefactoringWizard.java:476)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.createContents(RefactoringWizardDialog2.java:611)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:181)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:41)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:381)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:173)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5831)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1427)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:5092)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4570)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
Caused by: java.lang.ClassCastException: class org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding cannot be cast to class org.eclipse.jdt.internal.compiler.lookup.FieldBinding (org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding and org.eclipse.jdt.internal.compiler.lookup.FieldBinding are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @2b3abeeb)
	at org.eclipse.jdt.internal.core.search.matching.FieldLocator.matchReportReference(FieldLocator.java:182)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2622)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:3279)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:3291)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:3291)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2843)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:2018)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1336)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1373)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1515)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:115)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchDeclarations(BasicSearchEngine.java:2241)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchDeclarationsOfAccessedFields(BasicSearchEngine.java:2294)
	at org.eclipse.jdt.core.search.SearchEngine.searchDeclarationsOfAccessedFields(SearchEngine.java:1477)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.searchReferencedFields(RefactoringSearchEngine2.java:524)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:737)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:811)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:731)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:86)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:122)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Root exception:
java.lang.ClassCastException: class org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding cannot be cast to class org.eclipse.jdt.internal.compiler.lookup.FieldBinding (org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding and org.eclipse.jdt.internal.compiler.lookup.FieldBinding are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @2b3abeeb)
	at org.eclipse.jdt.internal.core.search.matching.FieldLocator.matchReportReference(FieldLocator.java:182)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2622)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:3279)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:3291)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:3291)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2843)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:2018)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1336)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1373)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1515)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:115)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchDeclarations(BasicSearchEngine.java:2241)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchDeclarationsOfAccessedFields(BasicSearchEngine.java:2294)
	at org.eclipse.jdt.core.search.SearchEngine.searchDeclarationsOfAccessedFields(SearchEngine.java:1477)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.searchReferencedFields(RefactoringSearchEngine2.java:524)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:737)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:811)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:731)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:86)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:122)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Manoj N Palat 2021-03-19 08:56:09 EDT
@vikas: Could you please take a look at this? thanks!
Eclipse Genie 2021-03-20 07:32:27 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/178139
Vikas Chandra 2021-03-21 03:54:02 EDT
smallest subset to recreate

public interface MainInterface {
  interface inter1  {
    record record1(Class<?> type) implements inter1 {
      public record1 {
        if (!type.isPrimitive()) {
        }
      }
    }
  }
}



Right click on inter1 and Move type to a new File 


CCE without the patch
Works as expected ( without any compilation error) post the patch.
Relevant test case added.
Eclipse Genie 2021-03-23 04:27:00 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/178139 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=78de0d2d64a735454171b079f5f80ed8fb740cc5
Manoj N Palat 2021-04-07 03:21:30 EDT
@Vikas: while verifying for 4.20 M1, I see that there are 5 errors once you use the original test case mentioned in Description and follow the steps described by Rémi.
for eg:
""The import com.github.forax.tomahawk.schema.Schema.Layout cannot be resolved""  - this is coming from Layout.java after refactoring.

This looks like its an issue with jdt.ui/refactoring - so you may want to recheck this and raise a bug with the right component. However, I see that the CCE is gone both for the original testcase and the reduced one
Vikas Chandra 2021-04-07 04:17:04 EDT
(In reply to Manoj Palat from comment #5)
> @Vikas: while verifying for 4.20 M1, I see that there are 5 errors once you
> use the original test case mentioned in Description and follow the steps
> described by Rémi.
> for eg:
> ""The import com.github.forax.tomahawk.schema.Schema.Layout cannot be
> resolved""  - this is coming from Layout.java after refactoring.
> 
> This looks like its an issue with jdt.ui/refactoring - so you may want to
> recheck this and raise a bug with the right component. However, I see that
> the CCE is gone both for the original testcase and the reduced one

Control-Shift-O fixes it but I will raise a bug nevertheless.
Vikas Chandra 2021-04-07 04:19:46 EDT
Opened https://bugs.eclipse.org/bugs/show_bug.cgi?id=572639
Manoj N Palat 2021-04-07 05:30:28 EDT
(In reply to Vikas Chandra from comment #7)
> Opened https://bugs.eclipse.org/bugs/show_bug.cgi?id=572639

ok. I have added a reduced test case to bug 572639 to reproduce the issue.
and have added Rémi in CC since this is part of his original code issue.

Moving this bug to verified for 4.20 M1 for the fixing of CCE.
Luke Hutchison 2021-05-30 05:11:34 EDT
I see a (probably related?) exception thrown with a simpler testcase:

    public class X {
        public static record Y(int y) { }
    }

Put the cursor after 'Y' and try ""Refactor > Move type to new file"" => the following exception is thrown. Can someone please verify if this is fixed, or whether I should open a separate bug for this?:



!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2021-05-30 03:09:17.337
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:397)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:662)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:504)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.getStartingPage(RefactoringWizard.java:476)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.createContents(RefactoringWizardDialog2.java:611)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:181)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:41)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:381)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:173)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5831)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1427)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:5092)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4570)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
Caused by: java.lang.NullPointerException: Cannot invoke ""org.eclipse.jdt.core.dom.VariableDeclarationFragment.getParent()"" because ""fragment"" is null
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.rewriteVisibility(MemberVisibilityAdjustor.java:170)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.rewriteVisibility(MemberVisibilityAdjustor.java:200)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.rewriteVisibility(MemberVisibilityAdjustor.java:1059)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:840)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:731)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:86)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:122)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Root exception:
java.lang.NullPointerException: Cannot invoke ""org.eclipse.jdt.core.dom.VariableDeclarationFragment.getParent()"" because ""fragment"" is null
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.rewriteVisibility(MemberVisibilityAdjustor.java:170)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.rewriteVisibility(MemberVisibilityAdjustor.java:200)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.rewriteVisibility(MemberVisibilityAdjustor.java:1059)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:840)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:731)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:86)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:122)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Vikas Chandra 2021-05-30 05:26:08 EDT
(In reply to Luke Hutchison from comment #9)
> I see a (probably related?) exception thrown with a simpler testcase:
> 
>     public class X {
>         public static record Y(int y) { }
>     }
> 
> Put the cursor after 'Y' and try ""Refactor > Move type to new file"" => the
> following exception is thrown. Can someone please verify if this is fixed,
> or whether I should open a separate bug for this?:
> 
> 
> 
> !ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2021-05-30 03:09:17.337
> !MESSAGE Internal Error
> !STACK 0
> java.lang.reflect.InvocationTargetException
> 	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:397)
> 	at
> org.eclipse.ui.internal.WorkbenchWindow.lambda$7(WorkbenchWindow.java:2345)
> 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
> 	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2343)
> 	at
> org.eclipse.ltk.ui.refactoring.RefactoringWizard.
> createChange(RefactoringWizard.java:662)
> 	at
> org.eclipse.ltk.ui.refactoring.RefactoringWizard.
> computeUserInputSuccessorPage(RefactoringWizard.java:504)
> 	at
> org.eclipse.ltk.ui.refactoring.RefactoringWizard.
> getStartingPage(RefactoringWizard.java:476)
> 	at
> org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.
> createContents(RefactoringWizardDialog2.java:611)
> 	at org.eclipse.jface.window.Window.create(Window.java:431)
> 	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
> 	at
> org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.
> lambda$0(RefactoringWizardOpenOperation.java:181)
> 	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
> 	at
> org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.
> run(RefactoringWizardOpenOperation.java:209)
> 	at
> org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.
> run(RefactoringWizardOpenOperation.java:126)
> 	at
> org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.
> activate(RefactoringStarter.java:41)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.
> startMoveInnerRefactoring(RefactoringExecutionStarter.java:381)
> 	at
> org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.
> run(ConvertNestedToTopAction.java:173)
> 	at
> org.eclipse.jdt.ui.actions.SelectionDispatchAction.
> dispatchRun(SelectionDispatchAction.java:278)
> 	at
> org.eclipse.jdt.ui.actions.SelectionDispatchAction.
> run(SelectionDispatchAction.java:252)
> 	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
> 	at
> org.eclipse.jface.action.ActionContributionItem.
> handleWidgetSelection(ActionContributionItem.java:580)
> 	at
> org.eclipse.jface.action.ActionContributionItem.
> lambda$4(ActionContributionItem.java:414)
> 	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
> 	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5831)
> 	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1427)
> 	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:5092)
> 	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4570)
> 	at
> org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.
> run(PartRenderingEngine.java:1157)
> 	at
> org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
> 	at
> org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.
> run(PartRenderingEngine.java:1046)
> 	at
> org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.
> java:155)
> 	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
> 	at
> org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
> 	at
> org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
> 	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
> 	at
> org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.
> java:152)
> 	at
> org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:
> 203)
> 	at
> org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.
> runApplication(EclipseAppLauncher.java:134)
> 	at
> org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.
> start(EclipseAppLauncher.java:104)
> 	at
> org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
> 	at
> org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
> 	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native
> Method)
> 	at
> java.base/jdk.internal.reflect.NativeMethodAccessorImpl.
> invoke(NativeMethodAccessorImpl.java:64)
> 	at
> java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.
> invoke(DelegatingMethodAccessorImpl.java:43)
> 	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
> 	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
> 	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
> 	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
> 	at org.eclipse.equinox.launcher.Main.main(Main.java:1434)
> Caused by: java.lang.NullPointerException: Cannot invoke
> ""org.eclipse.jdt.core.dom.VariableDeclarationFragment.getParent()"" because
> ""fragment"" is null
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.
> rewriteVisibility(MemberVisibilityAdjustor.java:170)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.
> rewriteVisibility(MemberVisibilityAdjustor.java:200)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MemberVisibilityAdjustor.rewriteVisibility(MemberVisibilityAdjustor.java:
> 1059)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:
> 840)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.
> java:731)
> 	at
> org.eclipse.ltk.core.refactoring.CheckConditionsOperation.
> run(CheckConditionsOperation.java:86)
> 	at
> org.eclipse.ltk.core.refactoring.CreateChangeOperation.
> run(CreateChangeOperation.java:122)
> 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
> 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
> 	at
> org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.
> run(WorkbenchRunnableAdapter.java:89)
> 	at
> org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.
> java:122)
> Root exception:
> java.lang.NullPointerException: Cannot invoke
> ""org.eclipse.jdt.core.dom.VariableDeclarationFragment.getParent()"" because
> ""fragment"" is null
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.
> rewriteVisibility(MemberVisibilityAdjustor.java:170)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MemberVisibilityAdjustor$IncomingMemberVisibilityAdjustment.
> rewriteVisibility(MemberVisibilityAdjustor.java:200)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MemberVisibilityAdjustor.rewriteVisibility(MemberVisibilityAdjustor.java:
> 1059)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:
> 840)
> 	at
> org.eclipse.jdt.internal.corext.refactoring.structure.
> MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.
> java:731)
> 	at
> org.eclipse.ltk.core.refactoring.CheckConditionsOperation.
> run(CheckConditionsOperation.java:86)
> 	at
> org.eclipse.ltk.core.refactoring.CreateChangeOperation.
> run(CreateChangeOperation.java:122)
> 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
> 	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
> 	at
> org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.
> run(WorkbenchRunnableAdapter.java:89)
> 	at
> org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.
> java:122)

Works fine on Version: 2021-06 (4.20)
Build id: I20210526-2310
Vikas Chandra 2021-05-30 05:27:30 EDT
Hi LUke, Can you try with I20210526-2310?
Luke Hutchison 2021-05-30 05:45:11 EDT
I spent a bit of time trying to replicate with I20210526-2310. I can't seem to switch on preview features for that Eclipse build, and without that enabled, records don't work.

I have a Java 15 JDK build selected as the JDK/JRE in Preferences, and JDK 15 is selected for the Java level in project preferences, but the setting ""Enable preview features"" is grayed-out, and additionally in the grayed-out text it says ""Enable preview features for Java 16"", rather than ""... for Java 15"", which is the selected language level.

So I assume I need to have Java 16 installed to even enable preview features in this build of Eclipse, even though for JDK-15, records are still a preview feature?

If someone has this build already working, it would be great if they could please try out my small testcase.
Vikas Chandra 2021-05-30 06:26:58 EDT
(In reply to Luke Hutchison from comment #12)
> I spent a bit of time trying to replicate with I20210526-2310. I can't seem
> to switch on preview features for that Eclipse build, and without that
> enabled, records don't work.
> 
> I have a Java 15 JDK build selected as the JDK/JRE in Preferences, and JDK
> 15 is selected for the Java level in project preferences, but the setting
> ""Enable preview features"" is grayed-out, and additionally in the grayed-out
> text it says ""Enable preview features for Java 16"", rather than ""... for
> Java 15"", which is the selected language level.
> 
> So I assume I need to have Java 16 installed to even enable preview features
> in this build of Eclipse, even though for JDK-15, records are still a
> preview feature?
> 
> If someone has this build already working, it would be great if they could
> please try out my small testcase.

I changed the compliance to Java 16 but then move to a new file option disappears. I am not sure if this is the correct workflow.
Vikas Chandra 2021-05-30 06:27:54 EDT
@Kalyan, can you please comment on comment#12
Jay Arthanareeswaran 2021-05-31 01:40:10 EDT
(In reply to Luke Hutchison from comment #12)
> I spent a bit of time trying to replicate with I20210526-2310. I can't seem
> to switch on preview features for that Eclipse build, and without that
> enabled, records don't work.
> 
> I have a Java 15 JDK build selected as the JDK/JRE in Preferences, and JDK
> 15 is selected for the Java level in project preferences, but the setting
> ""Enable preview features"" is grayed-out, and additionally in the grayed-out
> text it says ""Enable preview features for Java 16"", rather than ""... for
> Java 15"", which is the selected language level.
> 
> So I assume I need to have Java 16 installed to even enable preview features
> in this build of Eclipse, even though for JDK-15, records are still a
> preview feature?
> 
> If someone has this build already working, it would be great if they could
> please try out my small testcase.

Regardless of the JDK available in the workspace, Eclipse only supports preview features on/for the latest supported Java version. When I say latest supported Java version, it is for that particular Eclipse build. For instance, Java 16 is the latest supported version and preview will only be allowed at that level (16). Whereas builds from our BETA_JAVA17 branch, preview will be supported only at compliance level 17.
Luke Hutchison 2021-05-31 15:58:02 EDT
OK, I installed JDK 16 and tested with I20210526-2310. I don't see ""Move type to new file"", there is only ""Move..."", which (as far as I can tell) can only move an inner (nested) class from one containing class to another containing class.
Vikas Chandra 2021-06-01 02:33:02 EDT
Created attachment 286491 [details]
I can see ""Move Type to a new file""
Vikas Chandra 2021-06-01 02:34:10 EDT
(In reply to Luke Hutchison from comment #16)
> OK, I installed JDK 16 and tested with I20210526-2310. I don't see ""Move
> type to new file"", there is only ""Move..."", which (as far as I can tell) can
> only move an inner (nested) class from one containing class to another
> containing class.

Try to launch eclipse in a new workspace with JDK 16 and then try out the scenario.
Luke Hutchison 2021-06-01 19:25:11 EDT
I still don't see the ""Move type to new file"" option. I launched I20210526-2310 using

    JAVA_HOME=/usr/java/jdk-16.0.1 /opt/eclipse/eclipse

Then I added JDK-16 as the default JRE, set project compliance to JDK-16, and enabled preview features for JDK-16. The menu option is not there.

This round-trip here in the comments, particularly with so many people CC'd on this bug report, is very inefficient. Can somebody who already has this a working copy of a recent build of Eclipse please try reproducing the exception, using the example I provided in comment #9?

Thank you!
Kalyan Prasad Tatavarthi 2021-06-02 03:52:28 EDT
Created attachment 286502 [details]
Demo of ""Move type to new file"" option

I have used the 4.20 RC1 release for this demo.
https://download.eclipse.org/eclipse/downloads/drops4/S-4.20RC1-202105262310/

Using this demo I am clearly able to move the record Y to a new file using the ""Move type to new file"" option.

Also I am using java 16 JRE for the project. As Records are standard feature in Java 16, preview features need not be enabled for using Records.

Unless we have a reproducible scenario for the issue you are facing, it is difficult to resolve the issue.

Can you please try in a new workspace. Also to further assist in debugging the issue, can you attach a zip of the sample project in which you are facing the problem.
Kalyan Prasad Tatavarthi 2021-06-02 04:20:40 EDT
Created attachment 286506 [details]
Demo of ""Move type to new file"" option

I have used the 4.20 RC1 release for this demo.
https://download.eclipse.org/eclipse/downloads/drops4/S-4.20RC1-202105262310/

Using this demo I am clearly able to move the record Y to a new file using the ""Move type to new file"" option.

Also I am using java 16 JRE for the project. As Records are standard feature in Java 16, preview features need not be enabled for using Records.

Unless we have a reproducible scenario for the issue you are facing, it is difficult to resolve the issue.

Can you please try in a new workspace. Also to further assist in debugging the issue, can you attach a zip of the sample project in which you are facing the problem.
Luke Hutchison 2021-06-02 06:26:15 EDT
I created a new workspace, and I can confirm that the ""Refactor > Move Type to New File"" option reappears. I can also confirm that this option works, and no longer throws an exception.

I don't know why this menu option is not showing in the old workspace (Vikas also couldn't see the option in his workspace). The old workspace was from an existing JDK-15 project that I was working in, which I upgraded to JDK-16 as requested in the earlier comments. (i.e. the new workspace I just created has this menu option, but the old one does not have this option with the I20210526-2310 build).

Anyway, thanks for confirming that the exception I was seeing is fixed in recent builds.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=573624,573624,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[record] refactor rename to an existing method is allowed resulting in compilation failure,2021/5/26,compile error,1,1,record,rename method,overly weak preconditions,"Bug 573624 - [record] refactor rename to an existing method is allowed resulting in compilation failure
Manoj N Palat 2021-05-19 02:30:22 EDT
Same test from bug 573452, but different rename:

public record R(int comp) {
	
	private void method1() {

	}
	private void method() {
		int a = comp;
		this.comp() ;  //refactor comp to method1

	}
  
}

results in 

public record R(int method1) {
	
	private void method1() { //Error : The accessor method must be declared public

	}
	private void method() {
		int a = method1;
		this.method1() ;  //refactor comp to method1

	}
  
}

This should not be allowed in the first place / the user should be given a choice
Eclipse Genie 2021-05-21 04:09:10 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/180848
Eclipse Genie 2021-05-21 14:27:22 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/180848 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=5ad9caea219066239f1b68dd42e26992c6570882
Sarika Sinha 2021-05-21 14:27:56 EDT
+1 for RC1.
Kalyan Prasad Tatavarthi 2021-05-26 16:01:38 EDT
Verified in the build I20210526-0600
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=572639,572639,P3,JDT,UI,kalyan_prasad,VERI,FIXE,The import XYZ cannot be resolved after Refactor ->Move to a new file.,2021/5/17,compile error,1,1,record,Move member type to new File,ast rewrite issue,"Bug 572639 - The import XYZ cannot be resolved after Refactor ->Move to a new file.
Vikas Chandra 2021-04-07 04:19:17 EDT
Steps - https://bugs.eclipse.org/bugs/show_bug.cgi?id=572100#c0

Post the CCE fix, we get 4 unresolved import errors post this operation.
Manoj N Palat 2021-04-07 05:27:31 EDT
A reduced test case to reproduce the issue:

package com.github.forax.tomahawk.schema;

public interface Schema {
	// To see the error
	// select Layout -> right click to get context menu, Refactor -> Move Type to a New File
	// an extra import com.github.forax.tomahawk.schema.Schema.Layout.PrimitiveLayout; is in Layout.java
  interface Layout {
    default boolean isPrimitive() {
      return this instanceof PrimitiveLayout;
    }
    record PrimitiveLayout() implements Layout { }
  }
}
Eclipse Genie 2021-04-19 06:26:15 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/179502
Eclipse Genie 2021-04-20 12:42:20 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/179502 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=9d1f279fd13355fc4a32147df26253e75b4173f8
Eclipse Genie 2021-04-23 01:12:08 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/179710
Eclipse Genie 2021-04-23 03:47:52 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/179710 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=38272e7b2695410afef760b86024904053c444a0
Kalyan Prasad Tatavarthi 2021-05-17 02:32:21 EDT
Verified in the build I20210516-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=546819,546819,P3,JDT,UI,jjohnstn,VERI,FIXE,Refactor method with varargs might remove the varargs parameter,2021/5/4,compile error,1,1,varargs,change method signature,Incorrect Type Resolving,"Bug 546819 - Refactor method with varargs might remove the varargs parameter
Juergen Baier 2019-04-29 07:28:31 EDT
Adding new method parameters to methods with varargs leads to unexpected results.


Consider the following class:


    public class RefactorWithVarArgsBug {

	public static void main(String[] args) {
		RefactorWithVarArgsBug o = new RefactorWithVarArgsBug(true);
	}

	public RefactorWithVarArgsBug(boolean a, String... strings) {

	}
   }

If I change the code to

    public class RefactorWithVarArgsBug {

	public static void main(String[] args) {
		RefactorWithVarArgsBug o = new RefactorWithVarArgsBug(42, true);
	}

	public RefactorWithVarArgsBug(boolean a, String... strings) {

	}
    }

and choose ""Change constructor"" the result will be:

    public class RefactorWithVarArgsBug {

	public static void main(String[] args) {
		RefactorWithVarArgsBug o = new RefactorWithVarArgsBug(42, true);
	}

	public RefactorWithVarArgsBug(int i, boolean a) {

	}
    }

=> The varargs parameter ""strings"" has been removed.

Note that the quickfix correctly says that it will do so (""Change constructor 'RefactorWithVarArgsBug(boolean, String...)' to 'RefactorWithVarArgsBug(int, boolean)'"", so the careful reader would not be surprised.

Nevertheless, I think the correct result should be:


    public class RefactorWithVarArgsBug {

	public static void main(String[] args) {
		RefactorWithVarArgsBug o = new RefactorWithVarArgsBug(42, true);
	}

	public RefactorWithVarArgsBug(int i, boolean a, String... strings) {

	}
    }
Jeff Johnston 2020-12-03 15:07:15 EST
I agree that changing the constructor to remove the varargs is not correct as any code that accesses the parameter will be wrong.

It is better to offer the addition of a new parameter as you have suggested.  I have a patch will be posted shortly.
Eclipse Genie 2020-12-03 15:15:34 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/173332
Eclipse Genie 2021-01-08 14:57:28 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/173332 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=5a164e8ab37e8bf4cfeac9613820bdfa02847ecd
Jeff Johnston 2021-01-08 14:58:39 EST
Released for 4.19M2
Jeff Johnston 2021-02-16 15:01:43 EST
Verified for 4.19M3 using I20210216-0600 build
Juergen Baier 2021-05-04 10:24:52 EDT
I just did a similar refactoring with Eclipse 4.19 ... everything works fine now. Thanks for fixing this bug :-)
Jeff Johnston 2021-05-04 15:14:13 EDT
(In reply to Juergen Baier from comment #6)
> I just did a similar refactoring with Eclipse 4.19 ... everything works fine
> now. Thanks for fixing this bug :-)

You're welcome.  Thanks for reporting it.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=570587,570587,P3,JDT,UI,carsten.hammer,VERI,FIXE,Unnecessary loss of performance in refactoring,2021/4/6,bad performance,1,1,toString(),-,others,"Bug 570587 - Unnecessary loss of performance in refactoring
Carsten Hammer 2021-01-23 04:29:46 EST
For Bug 436581 there has been an Assert statement added to help in case of an issue.
Unfortunately because of  Bug 570583 the performance penalty for this use case is higher than it should.

Until https://git.eclipse.org/r/c/equinox/rt.equinox.bundles/+/175187 is merged we should change the code to only call toString() if really needed.

So the code that currently looks like this:

Assert.isTrue(fCUnit.isWorkingCopy(), fCUnit.toString());

should be changed to

Assert.isTrue(fCUnit.isWorkingCopy(), !fCUnit.isWorkingCopy()?fCUnit.toString():""""); //$NON-NLS-1$

or

Assert.isTrue(fCUnit.isWorkingCopy(), fCUnit.isWorkingCopy()?"""":fCUnit.toString()); //$NON-NLS-1$

whatever you prefer.
Jeff Johnston 2021-03-18 17:39:01 EDT
The following was extracted from the git log message and placed here instead:

You can log the time spent on this (Microseconds per call) using the
following code:
   
long start = System.nanoTime();
Assert.isTrue(fCUnit.isWorkingCopy(), fCUnit.toString());
long end = System.nanoTime();
long diff = end - start;
long convert = TimeUnit.MICROSECONDS.convert(diff,TimeUnit.NANOSECONDS);
if (convert > 10) // Just interested in slow calls
    System.out.println(""### "" + convert);  //$NON-NLS-1$
Eclipse Genie 2021-03-18 21:13:38 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/175244 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=0fa439b2ed9e74421fb8bf3f2c23be2dad2d10cf
Jeff Johnston 2021-03-18 21:13:54 EDT
Released for 4.20M1
Jeff Johnston 2021-04-06 14:44:11 EDT
Verified for 4.20M1 using I20210406-0600 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566944,566944,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[15] record Compact Constructor - Refactor -> Introduce Parameter Object gives NPE/ unhandled loop event exception,2021/2/17,exception,1,1,record,Introduce Parameter Object,overly weak preconditions,"Bug 566944 - [15] record Compact Constructor - Refactor -> Introduce Parameter Object gives NPE/ unhandled loop event exception
Manoj N Palat 2020-09-14 06:04:44 EDT
Given:

@SuppressWarnings(""preview"")
record R(int i) {
	R {
		System.out.println(""Compact Constructor"");
	}
}

java.lang.NullPointerException
	at org.eclipse.jdt.internal.corext.refactoring.ParameterInfo.setOldBinding(ParameterInfo.java:216)
	at org.eclipse.jdt.internal.corext.refactoring.structure.IntroduceParameterObjectProcessor.checkInitialConditions(IntroduceParameterObjectProcessor.java:456)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startIntroduceParameterObject(RefactoringExecutionStarter.java:500)
	at org.eclipse.jdt.internal.ui.actions.IntroduceParameterObjectAction.run(IntroduceParameterObjectAction.java:146)
	at org.eclipse.jdt.internal.ui.actions.IntroduceParameterObjectAction.run(IntroduceParameterObjectAction.java:120)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:225)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:223)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:579)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:413)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4385)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1512)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1535)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1520)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1324)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3789)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Manoj N Palat 2020-09-15 02:37:11 EDT
mentioning that the compact contructor R should be selected to get this error
Noopur Gupta 2021-01-18 06:15:12 EST
Kalyan, can you please take a look at it for M3?
Eclipse Genie 2021-01-22 02:04:22 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/175197
Eclipse Genie 2021-01-22 03:28:27 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/175197 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=de3a08ee1db35d3f63cfc1d145d5f308f147cf00
Eclipse Genie 2021-02-03 06:16:39 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/175705
Eclipse Genie 2021-02-03 06:17:21 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/175705 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=dd92dc193f5d76210d33a8b65a2b790b724c93e5
Kalyan Prasad Tatavarthi 2021-02-17 02:53:43 EST
Verified in the build I20210216-2020
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=567975,567975,P3,JDT,Core,jjohnstn,VERI,FIXE,AssertionFailedException thrown by org.eclipse.ltk.ui.refactoring,2021/2/16,exception,1,1,default method,inline method,ast rewrite issue,"Bug 567975 - AssertionFailedException thrown by org.eclipse.ltk.ui.refactoring
Hamid Nazari 2020-10-18 12:39:00 EDT
Created attachment 284506 [details]
Exported error log from eclipse

I'm trying to inline a ""default"" method on one of my interfaces and I get assertion failure error.
I've attached the exported log record.

I've check with eclipse 4.17 and the issue is still there.
Issue is seen both on Oracle JVM 14.0.2 and 15
Noopur Gupta 2020-10-19 03:23:22 EDT
Please provide a sample code to reproduce this issue.
Hamid Nazari 2020-10-20 05:51:26 EDT
Created attachment 284517 [details]
Sample code to produce the issue

The codebase I'm running this refactor against is huge (1.7 MLOC, 390+ OSGi bundles with more than 1600 matches for target method!)

I see refactor progress through my classes but I can't pinpoint where it hits the wall. All I could do was to localize the issue by closing some of the guessed faulty projects. After closing about 100 of my projects, the refactor succeeded.

I can relate this to Java14 Switch Expression or something like that. The code I've attached does exactly reproduce the mentioned assertion exception, but if you try to inline ""IFilter.test(String, int)"" it gives ""Document does not match the AST"" error which I think is the source of the behavior I see in macro scale. 
I've attached the log for the new error, too, to help identify the issue.
Hamid Nazari 2020-10-20 05:52:15 EDT
Created attachment 284518 [details]
Exported log for new AST error
Eclipse Genie 2021-01-26 15:56:58 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/175387
Eclipse Genie 2021-01-27 16:15:25 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.core/+/175387 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=babeca48101828a5e0f0b65ec684699efb4bc8e5
Jeff Johnston 2021-01-27 16:16:20 EST
Released for 4.19M2
Sarika Sinha 2021-02-16 05:06:36 EST
I20210215-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=570245,570245,P3,JDT,UI,jdt-ui-inbox,RESO,FIXE,[16] No option to refactor rename local enums,2021/1/22,not available,1,1,enum,rename enum,selection parsing issue,"Bug 570245 - [16] No option to refactor rename local enums
Vikas Chandra 2021-01-11 07:13:09 EST
public class X2 { 
	public static void main(String[] args) {
     enum Y1 { 
		
		BLEU,
		BLANC,
		ROUGE;
		
		public static void main(String[] args) {
			for(Y1 y: Y1.values()) {
				System.out.print(y);
			}
		}
		
	  }
	  Y1.main(args);
	}
}

I want to refactor rename Y1 to Y2 but it is not possible.
Also selecting Y1's declaration doesn't select the other references.
Vikas Chandra 2021-01-11 07:16:34 EST
may be related to Bug 570246
Kalyan Prasad Tatavarthi 2021-01-22 06:27:50 EST
Fixed as a result of fix for bug 570248
Noopur Gupta 2021-01-22 07:42:42 EST
*** This bug has been marked as a duplicate of bug 570248 ***
Kalyan Prasad Tatavarthi 2021-01-22 10:10:31 EST
Removing the duplicate because this is a JDT UI scenario that needs to be verified. The bug 570248 is jdt core bug.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566851,566851,P3,JDT,UI,noopur_gupta,RESO,FIXE,[15] record - Refactor -> Extract Interface not adding implements,2021/1/13,compile error,1,1,record,extract interface,ast rewrite issue,"Bug 566851 - [15] record - Refactor -> Extract Interface not adding implements
Manoj N Palat 2020-09-10 06:44:28 EDT
Expected result: record R() implements I
But no change

record R() {// select R and Refactor->Extract Interface
	private void foo(Object o) {
		if (o instanceof R) {
			System.out.println(""hello"");
		}
	}

}

Using Y build - 
Version: 2020-09 (4.17)
Build id: Y20200909-1200

Bonus Issue:

class X {// select X and use Extract Interface
	public static void main(String[] args) {
		R r = null;
	}
	private void foo(Object o) {
		X x = null;
		if (o instanceof X) { // this does not change 
			System.out.println(""hello"");
		}
	}
}

For the class X it works normally, but if the checkbox for instanceof is ticked, still the X in ""o instanceof X)"" does not change - not related to records but just mentioning as found.
Manoj N Palat 2020-09-10 06:50:27 EDT
Let me clarify, interface is getting created but it does not create ""record R() implements I""
Noopur Gupta 2020-12-09 07:01:47 EST
(In reply to Manoj Palat from comment #0)
> For the class X it works normally, but if the checkbox for instanceof is
> ticked, still the X in ""o instanceof X)"" does not change - not related to
> records but just mentioning as found.

The checkbox is for the usage after instanceof check. It will work if your code is the following:

if (o instanceof X) {
	System.out.println(((X)o).toString()); // Here, X will be replaced with I
}
Eclipse Genie 2021-01-12 06:02:23 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/174691
Eclipse Genie 2021-01-13 01:46:35 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/174691 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=f6acc30d17cdf3691713aad6d741921688019bdb
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566945,566945,P3,JDT,UI,noopur_gupta,VERI,FIXE,[15] record Compact Constructor - Refactor -> Introduce Factory gives InvocationTargetException due to IAE,2021/1/6,exception,0,1,nan,introduce factory,nan,"Bug 566945 - [15]  record Compact Constructor - Refactor -> Introduce Factory gives InvocationTargetException due to IAE
Manoj N Palat 2020-09-14 06:11:25 EDT
Given:


@SuppressWarnings(""preview"")
record R(int i) {
	R {
		System.out.println(""Compact Constructor"");
	}
}


Select the R, the compact constructor, Refactor->Introduce Factory... gives the following exception:

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:397)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:324)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:662)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:504)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:77)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:113)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.nextOrPreviewPressed(RefactoringWizardDialog2.java:493)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$2(RefactoringWizardDialog2.java:490)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:693)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4385)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1512)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1535)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1520)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1324)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3789)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:190)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:41)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startIntroduceFactoryRefactoring(RefactoringExecutionStarter.java:350)
	at org.eclipse.jdt.ui.actions.IntroduceFactoryAction.run(IntroduceFactoryAction.java:144)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:225)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:223)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:579)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:413)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4385)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1512)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1535)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1520)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1324)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3789)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:2698)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceFactoryRefactoring.createFactoryMethodSignature(IntroduceFactoryRefactoring.java:737)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceFactoryRefactoring.createFactoryMethod(IntroduceFactoryRefactoring.java:618)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceFactoryRefactoring.createFactoryChange(IntroduceFactoryRefactoring.java:1129)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceFactoryRefactoring.addAllChangesFor(IntroduceFactoryRefactoring.java:938)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceFactoryRefactoring.createChange(IntroduceFactoryRefactoring.java:1188)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:125)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)


IAE exception occurs in dom.ast, but the line at which the exception occurs says that the parameter passed is null which is unexpected.
Noopur Gupta 2020-12-09 06:32:25 EST
I don't see this issue with the latest code. Looks like it got fixed with the other bugs in 4.18. Please reopen if you can still reproduce it.
Noopur Gupta 2021-01-06 04:51:33 EST
Verified in I20210104-1800.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566866,566866,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[15] record - refactor - change method signature - unresolved int,2020/11/24,incorrect warning message,1,1,record,change method signature,overly strong preconditions,"Bug 566866 - [15] record - refactor - change method signature - unresolved int
Manoj N Palat 2020-09-10 11:19:02 EDT
Given:

record R() {
	public int foo() {
		return 0;
	}
}


select foo, Refactor -> Change Method Signature, change method name to bar,

an error message comes : ""could not resolve type int""

continue renames correctly, but the error is unwarranted.

The same operation, if R was a class, works.

Ybuild
Version: 2020-09 (4.17)
Build id: Y20200909-1200
Eclipse Genie 2020-11-03 02:32:01 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/171656
Eclipse Genie 2020-11-04 02:27:02 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/171656 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=473732f524bc249284bde05e5b1000c5ad3a876e
Kalyan Prasad Tatavarthi 2020-11-18 01:16:05 EST
Verified in the build I20201117-1800
Kalyan Prasad Tatavarthi 2020-11-18 06:39:57 EST
Reopening this bug as this is not yet fixed for internal records.

For the code below

record C() {
    record R() {
	public int foo() {
		return 0;
	}
    }
}

we get the same error.
Eclipse Genie 2020-11-18 06:57:53 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/172427
Noopur Gupta 2020-11-19 01:42:57 EST
Please add a test case in the Gerrit patch for this scenario.
Eclipse Genie 2020-11-20 04:01:35 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/172427 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=212dd1de750ce15c1abcefc85785a516261a8001
Kalyan Prasad Tatavarthi 2020-11-24 00:15:07 EST
Verified in the build I20201123-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566943,566943,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[15] record canonical constructor - Refactor -> Introduce Factory decreases visibility - error,2020/11/24,compile error,1,1,record,introduce factory,overly weak preconditions,"Bug 566943 - [15] record canonical constructor - Refactor -> Introduce Factory decreases visibility - error
Manoj N Palat 2020-09-14 05:49:46 EDT
Given:

@SuppressWarnings(""preview"")
public record X(int i) {
	public X(int i) { // select X
		this.i = i;
	}
}

Select X in the canonical constructor, do Refactor -> Introduce Factory, give some name ""createX""  the default here, and then ok:

@SuppressWarnings(""preview"")
public record X(int i) {
	public static X createX(int i) {
		return new X(i);
	}

	private X(int i) { //visibility  Error here
		this.i = i;
	}
}

Error here: Cannot reduce the visibility of a canonical constructor X from that of the record
Eclipse Genie 2020-11-20 05:05:47 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/172556
Noopur Gupta 2020-11-20 05:17:26 EST
FIx looks good. +1 for RC1.
Eclipse Genie 2020-11-20 07:14:46 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/172556 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=b09d4f56148a1c94e4f74a26f9dae0c513e45ca3
Kalyan Prasad Tatavarthi 2020-11-24 00:12:52 EST
Verified in the build I20201123-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=568987,568987,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[15] record compact constructor - Refactor -> Introduce Factory causes NPE,2020/11/24,exception,1,1,record,introduce factory,overly weak preconditions,"Bug 568987 - [15] record compact constructor - Refactor -> Introduce Factory causes NPE
Kalyan Prasad Tatavarthi 2020-11-20 05:59:39 EST
Given:

@SuppressWarnings(""preview"")
public record X(int i) {
	public X { // select X
		this.i = i;
	}
}

Select X in the compact constructor, do Refactor -> Introduce Factory, give some name ""createX""  the default here, and then ok:

An NPE is reported in Error Log.
Eclipse Genie 2020-11-20 07:37:02 EST
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/172569
Noopur Gupta 2020-11-20 16:30:54 EST
+1 for RC1.
Eclipse Genie 2020-11-20 16:30:58 EST
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/172569 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=390c2e3e443b5738252dd615820e356c37644ea9
Kalyan Prasad Tatavarthi 2020-11-24 00:11:22 EST
Verified in the build I20201123-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=567438,567438,P3,JDT,UI,fabrice.tiercelin,VERI,FIXE,Refactor is broken for method parameters,2020/11/21,exception,1,1,-,change method signature,overly strong preconditions,"Bug 567438 - Refactor is broken for method parameters
Kalyan Prasad Tatavarthi 2020-09-29 08:02:26 EDT
In the below code 

public class Cls1 {
	
	public static void main(String[] args) {
		System.out.println(args);
				
	}

}

select args and Right Click Refactor > ""<no refactoring available>""

Refactoring options should be available.

Error Logs report the below error

java.lang.ClassCastException: class org.eclipse.jdt.core.dom.SingleVariableDeclaration cannot be cast to class org.eclipse.jdt.core.dom.VariableDeclarationFragment (org.eclipse.jdt.core.dom.SingleVariableDeclaration and org.eclipse.jdt.core.dom.VariableDeclarationFragment are in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @596eda44)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaTextSelection.resolveInVariableInitializer(JavaTextSelection.java:209)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringAvailabilityTester.isExtractMethodAvailable(RefactoringAvailabilityTester.java:373)
	at org.eclipse.jdt.ui.actions.ExtractMethodAction.selectionChanged(ExtractMethodAction.java:79)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchSelectionChanged(SelectionDispatchAction.java:264)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.update(SelectionDispatchAction.java:166)
	at org.eclipse.jdt.ui.actions.RefactorActionGroup.refactorMenuShown(RefactorActionGroup.java:643)
Kalyan Prasad Tatavarthi 2020-09-29 08:05:05 EDT
This is caused as a result of fix for bug 566791
Noopur Gupta 2020-09-29 08:08:02 EDT
(In reply to Kalyan Prasad Tatavarthi from comment #1)
> This is caused as a result of fix for bug 566791

Reverting the commit causing this regression: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/168923
Eclipse Genie 2020-09-29 08:33:34 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170017
Fabrice Tiercelin 2020-09-29 08:35:28 EDT
OK, I see the mistake. I have created a gerrit that fix the mistake. There is no ticket to create for the cleanup as the bug is due to manual change.
Noopur Gupta 2020-09-29 08:45:14 EDT
(In reply to Fabrice Tiercelin from comment #4)
> OK, I see the mistake. I have created a gerrit that fix the mistake. There
> is no ticket to create for the cleanup as the bug is due to manual change.

Can you check all other changes in that commit and verify that there isn't anything else that needs a fix?
Noopur Gupta 2020-09-29 08:47:30 EDT
(In reply to Eclipse Genie from comment #3)
> New Gerrit change created:
> https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170017

Looks like the revert is having conflicts. Fabrice, please take a look and revert the patch if comment #5 needs time.
Fabrice Tiercelin 2020-09-29 08:52:59 EDT
OK
Fabrice Tiercelin 2020-09-29 09:53:14 EDT
I have reviewed all the changes I have made on this gerrit other than the buggy case. I only noticed a code that could have been better cleaned (node == null is duplicated):
https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/169033/16/org.eclipse.jdt.core.manipulation/core+extension/org/eclipse/jdt/internal/corext/refactoring/structure/ASTNodeSearchUtil.java

So I see no other problem.
Eclipse Genie 2020-09-30 03:07:49 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170017 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=9968e5186009eb3b935f52bd8c0f04975a36b2be
Noopur Gupta 2020-09-30 03:11:56 EDT
(In reply to Fabrice Tiercelin from comment #8)
> I have reviewed all the changes I have made on this gerrit other than the
> buggy case. I only noticed a code that could have been better cleaned (node
> == null is duplicated):
> https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/169033/16/org.eclipse.jdt.core.manipulation/core+extension/org/eclipse/jdt/internal/corext/refactoring/structure/ASTNodeSearchUtil.java

Please change that with the next clean up patch if required.

> So I see no other problem.

Thanks, I have released the fix for this problem and abandoned the revert patch.
Fabrice Tiercelin 2020-11-21 06:56:34 EST
Verified for 4.18M3 using I20201116-1800 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566982,566982,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[15] record - Compact Constructor Refactor -> Move to class - gives error . Move Operation should not be allowed for Constructors,2020/10/7,compile error,1,1,record,move method,overly weak preconditions,"Bug 566982 - [15] record - Compact Constructor Refactor -> Move to class - gives error . Move Operation should not be allowed for Constructors
Manoj N Palat 2020-09-15 02:53:12 EDT
@SuppressWarnings(""preview"")
record R(int i) {
	R {
		System.out.println(""Compact Constructor"");
	}
}

class X {
}

Select R , ""R"" of compact constructor and Refactor -> Move to X

output is:


@SuppressWarnings(""preview"")
record R(int i) {
}

class X {

	R {
		System.out.println(""Compact Constructor"");
	}
}

This is not expected as it gives syntax error.
Not sure what the contract of this feature is, but I would expect that this operation should not be permitted at all in the first place on a compact constructor.
Eclipse Genie 2020-10-05 03:16:36 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170304
Eclipse Genie 2020-10-05 04:52:48 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170304 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=cd85f417d0f06ba035c5846856aee1ceff8a3ab8
Kalyan Prasad Tatavarthi 2020-10-07 02:23:29 EDT
Verified in the build I20201006-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=566939,566939,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[15] refactor move record component gives Internal Error,2020/10/7,exception,1,1,record,move class,overly weak preconditions,"Bug 566939 - [15] refactor move record component gives Internal Error
Manoj N Palat 2020-09-14 05:07:48 EDT
Given:


@SuppressWarnings(""preview"")
record R(int i) {
}

public class X {
}


select ""i"", choose Refactor -> Move and then select X, shows Unexpected Exception Occurred in message box;
The Error log says Internal Error.

Stacktrace from error log:


java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:397)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:324)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:662)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:504)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:77)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:113)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.nextOrPreviewPressed(RefactoringWizardDialog2.java:493)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$2(RefactoringWizardDialog2.java:490)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:693)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4385)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1512)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1535)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1520)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1324)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3789)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.lambda$0(RefactoringWizardOpenOperation.java:190)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:209)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:126)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:41)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveRefactoring(RefactoringExecutionStarter.java:399)
	at org.eclipse.jdt.internal.ui.refactoring.reorg.ReorgMoveAction.run(ReorgMoveAction.java:116)
	at org.eclipse.jdt.ui.actions.MoveAction.tryReorgMove(MoveAction.java:257)
	at org.eclipse.jdt.ui.actions.MoveAction.run(MoveAction.java:168)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:225)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:223)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:579)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:413)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4385)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1512)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1535)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1520)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1324)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4172)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3789)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:153)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1465)
Eclipse Genie 2020-10-05 02:01:38 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170294
Eclipse Genie 2020-10-05 03:01:23 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/170294 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=b2ea56aa12dc09b5f95ec858203e734ab23c9d41
Kalyan Prasad Tatavarthi 2020-10-07 02:19:57 EDT
Verified in build I20201006-1800
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=377288,377288,P3,JDT,UI,kenneth,VERI,FIXE,"[extract local] Refactor > Extract Local variable creates bad resulting code, and doesn't extract the variable",2020/8/19,compile error,1,1,switch case,extract local variable,ast rewrite issue,"Bug 377288 - [extract local] Refactor > Extract Local variable creates bad resulting code, and doesn't extract the variable
Lukas Eder 2012-04-20 09:58:46 EDT
Build Identifier: Build Identifier: Version: Indigo Release Build id: 20110615-0604

I cannot correctly extract case literals from a switch statement as local variables.

This is somewhat similar to the bug I've just entered here:
https://bugs.eclipse.org/bugs/show_bug.cgi?id=373196

Reproducible: Always

Steps to Reproduce:
Steps to Reproduce:
1. Create this class:

------------------------------------
public class Test {
    public void x(int i) {
        switch (i) {
            case 0:
            case 1:
        }
    }
}
------------------------------------

2. Select 1 from the case literals
3. Choose Refactor > Extract Local variable from the context menu
4. Choose any options and click OK
5. A variable is created, but the original is not replaced. The variable is placed at the wrong place in my opinion

------------------------------------
public class Test {
    public void x(int i) {
        // j should be placed here
        switch (i) {
            case 0:
                int j = 1; // ... instead of here
            case 1:
        }
    }
}
------------------------------------

In step 2. when choosing 0 instead of 1, things get worse. The outcome is this:


------------------------------------
public class Test {
    public void x(int i) {
        switch (i) {
            int j = 0; // this doesn't compile
            case 0:
            case 1:
        }
    }
}

------------------------------------
Markus Keller 2012-04-27 10:55:08 EDT
We should disable the refactoring in this situation. A case literal cannot be a variable, so the refactoring is not applicable.
Eclipse Genie 2020-07-15 20:33:33 EDT
This bug hasn't had any activity in quite some time. Maybe the problem got resolved, was a duplicate of something else, or became less pressing for some reason - or maybe it's still relevant but just hasn't been looked at yet.

If you have further information on the current state of the bug, please add it. The information can be, for example, that the problem still occurs, that you still want the feature, that more information is needed, or that the bug is (for whatever reason) no longer relevant.

--
The automated Eclipse Genie.
Eclipse Genie 2020-07-24 13:58:40 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/166813
Eclipse Genie 2020-08-04 18:36:27 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/166813 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=007d96bfa6adcb8760852596a851a9ad522e769d
Noopur Gupta 2020-08-17 03:46:57 EDT
Anything pending here for 4.17 M3?
Kenneth Styrberg 2020-08-17 10:22:09 EDT
I don't think so. I'm waiting for M3 to do solved bug testing.
Roland Grunberg 2020-08-17 10:53:59 EDT
Setting to RESOLVED (FIXED)
Roland Grunberg 2020-08-19 16:02:08 EDT
Verified for 4.17 M3 using I20200818-0900 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=72380,72380,P3,JDT,UI,kenneth,VERI,FIXE,[generalize type] introduces duplicate methods in presence of overloading [refactoring],2020/8/19,compile error,1,1,overloaded method,generalize type,overly weak preconditions,"Bug 72380 - [generalize type] introduces duplicate methods in presence of overloading [refactoring]
Friedrich Steimann 2004-08-21 01:50:34 EDT
Version: 3.1.0
Build id: 200408070010

I guess this is a known issue, but nevertheless ...

public class A {
	public void m(C c) {c.n();}
}

public class B extends A {
	public void m(C c) {}
	public void m(I c) {}
}

public class C implements I {
	public void n() {};
}

public interface I {
	public abstract void n();
}

generalizing type of c in A.m(C c) offers I, which makes B.m(I c) duplicate.

See attached.

-- Friedrich
Friedrich Steimann 2004-08-21 01:51:32 EDT
Created attachment 14104 [details]
sample project reproducing the bug
Dirk Baeumer 2004-08-23 04:36:37 EDT
Frank, can you please comment.
Frank Tip 2004-08-28 13:42:09 EDT
Confirmed. The failure to correctly deal with overloaded methods is indeed
a known issue. I can create a fix for it, but it will be >1 month before
I have time.

The solution is basically to generate additional constraints for parameters
and return types of methods that are overloaded if the signatures of these
methods refer to the class from which we're extracting the interface.

Dirk: we should perhaps defer fixing this problem until Markus is done
with the overhaul of the type constraints infrastructure. What do you 
think?

  -Frank
Dirk Baeumer 2004-08-30 06:41:41 EDT
As long as the fix doesn't depend on the new infrastrucuture or new features 
there I would not introduce an unnecessary dependencies between them. So if 
not I would opt to fix it.
Dirk Baeumer 2005-05-25 09:27:35 EDT
Deferring post 3.1
Eclipse Genie 2020-06-15 14:56:07 EDT
This bug hasn't had any activity in quite some time. Maybe the problem got resolved, was a duplicate of something else, or became less pressing for some reason - or maybe it's still relevant but just hasn't been looked at yet.

If you have further information on the current state of the bug, please add it. The information can be, for example, that the problem still occurs, that you still want the feature, that more information is needed, or that the bug is (for whatever reason) no longer relevant.

--
The automated Eclipse Genie.
Eclipse Genie 2020-07-06 02:53:57 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/165862
Eclipse Genie 2020-07-31 17:02:20 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/165862 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=0c492a7e053a1776db4485d5542f78d6179c552e
Noopur Gupta 2020-08-17 03:45:39 EDT
Anything pending here for 4.17 M3?
Kenneth Styrberg 2020-08-17 10:21:19 EDT
I don't think so. I'm waiting for M3 to do more testing on solved bugs.
Roland Grunberg 2020-08-17 10:53:34 EDT
Setting to RESOLVED (FIXED)
Roland Grunberg 2020-08-19 14:26:24 EDT
Verified for 4.17 M3 using I20200818-0900 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=394728,394728,P3,JDT,UI,kenneth,VERI,FIXE,"[push down] Push Down refactoring does not remove @Override, which leads to compilation error",2020/8/19,compile error,1,1,annotation,push down method,ast rewrite issue,"Bug 394728 - [push down] Push Down refactoring does not remove @Override, which leads to compilation error
Milos Gligoric 2012-11-20 21:07:04 EST
Steps to reproduce:
1. Invoke ""Push Down"" on (first method) ""m"" in code below
2. The resulting file does not compile (""... must override ..."")

class PushDownBug1 {

    static abstract class C {
        // Invoke ""Push Down..."" on ""m""
        abstract void m();
    }

    static final C F = new C() {
        @Override
        void m() {
        }
    };
}

(Thanks to Anirudh Balagopal for helping with the bug report.)
Martin Mathew 2012-12-17 23:56:37 EST
Issue is reproducible using I20121210-0800. The refactoring results in compiler error.
Eclipse Genie 2020-06-05 15:25:20 EDT
This bug hasn't had any activity in quite some time. Maybe the problem got resolved, was a duplicate of something else, or became less pressing for some reason - or maybe it's still relevant but just hasn't been looked at yet.

If you have further information on the current state of the bug, please add it. The information can be, for example, that the problem still occurs, that you still want the feature, that more information is needed, or that the bug is (for whatever reason) no longer relevant.

--
The automated Eclipse Genie.
Eclipse Genie 2020-07-15 15:18:02 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/166360
Eclipse Genie 2020-07-23 10:19:34 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/166360 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=c67a9266871bc70afd7c923180da5e67797a91f2
Roland Grunberg 2020-08-19 14:11:55 EDT
Verified for 4.17 M3 using I20200818-0900 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=564329,564329,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[14] An attempt to Refactor/Rename causes NullPointerException,2020/7/28,exception,1,1,-,rename field,Incorrect Type Resolving,"Bug 564329 - [14] An attempt to Refactor/Rename causes NullPointerException
Tomisław Kityński 2020-06-16 06:03:40 EDT
When Refactor/Rename is triggered on instance field (either via key shortcut or via menu) there is no apparent effect. In `.metadata/.log` NPE appears as follows:
```
!ENTRY org.eclipse.ui 4 0 2020-06-16 12:00:22.987
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder.getAssociatedRecordComponentNode(LinkedNodeFinder.java:68)
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder$BindingFinder.visit(LinkedNodeFinder.java:334)
        at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:198)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
        at org.eclipse.jdt.core.dom.FieldAccess.accept0(FieldAccess.java:187)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
        at org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:128)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
        at org.eclipse.jdt.core.dom.Block.accept0(Block.java:128)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
        at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:698)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
        at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:447)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
        at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:258)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder.findByBinding(LinkedNodeFinder.java:145)
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder.findByNode(LinkedNodeFinder.java:165)
        at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.start(RenameLinkedMode.java:234)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:240)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.doRun(RenameJavaElementAction.java:174)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:153)
        at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:121)
        at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
        at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
        at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:579)
        at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:413)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
        at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5685)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1423)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4953)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4446)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
        at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
        at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
        at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
        at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:564)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1420)
```

Seems similar to #44927 or #322300, but the stacktrace is different.
Kalyan Prasad Tatavarthi 2020-06-16 08:46:07 EDT
Please provide steps to reproduce this issue. If possible please provide a sample code for the same.Moving to JDT UI as this appears to be a JDT UI issue.
Tomisław Kityński 2020-06-18 08:31:06 EDT
""Magically"" it's working again (meanwhile the system was rebooted). Anyway it was enough to:

1) Move cursor to desired object (i.e. instance field, local variable, parameter variable, possibly others too). 

2) Press Alt+Shift+R to activate refactor-rename (the one that works inline by marking all instances of selected item in the source text) OR to select from the context menu Refactor/Rename option.

3) And that's it — nothing visible happened. Not even markers were applied to selected item's occurrences. Just like nothing happened. Except of course for the exception in log file.

This happened also previously in M3 as also now in RC1. It didn't really matter what Java source file was opened, simple, complex, or whatever — in every file I checked (like 20 or so), it just didn't work.

I have OpenJDK 14.0.1 and the preview features were enabled (that's mainly the reason I tried newest Eclipse, actually) — IDK if this is even relevant.

Ha! Just checked again on the source that was not working (in other project in the same workspace) and it doesn't work! But when I switch to project I'm working on currently — renaming works.

There's also something new in the log, look:
```
!ENTRY org.eclipse.e4.ui.workbench 4 0 2020-06-18 14:21:54.092
!MESSAGE Execution exception for: ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
                Rename the selected element,
                Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
                org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79e20b07,
                ,,true),null) in 
        context chain: WorkbenchContext -> TrimmedWindowImpl (IDEWindow) Context -> PerspectiveImpl (org.eclipse.jst.j2ee.J2EEPerspective) Context -> PartImpl (org.eclipse.e4.ui.compatibility.editor)  removeOnHide org.eclipse.jdt.ui.CompilationUnitEditorContext
!STACK 0
org.eclipse.core.commands.ExecutionException: While executing the action, an exception occurred
        at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:126)
        at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
        at jdk.internal.reflect.GeneratedMethodAccessor51.invoke(Unknown Source)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:564)
        at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
        at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
        at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
        at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
        at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
        at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
        at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
        at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
        at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
        at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
        at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
        at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
        at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
        at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
        at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1846)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1422)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1449)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1432)
        at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1473)
        at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:837)
        at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:3933)
        at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:855)
        at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2257)
        at org.eclipse.swt.widgets.Control.windowProc(Control.java:6659)
        at org.eclipse.swt.widgets.Display.windowProc(Display.java:5919)
        at org.eclipse.swt.internal.gtk.GTK.gtk_main_do_event(Native Method)
        at org.eclipse.swt.widgets.Display.eventProc(Display.java:1486)
        at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(Native Method)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4444)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
        at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
        at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
        at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
        at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
        at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
        at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
        at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
        at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
        at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.base/java.lang.reflect.Method.invoke(Method.java:564)
        at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
        at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
        at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
        at org.eclipse.equinox.launcher.Main.main(Main.java:1420)
Caused by: java.lang.NullPointerException
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder.getAssociatedRecordComponentNode(LinkedNodeFinder.java:68)
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder$BindingFinder.visit(LinkedNodeFinder.java:334)
        at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:198)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
        at org.eclipse.jdt.core.dom.FieldAccess.accept0(FieldAccess.java:187)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
        at org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:128)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
        at org.eclipse.jdt.core.dom.Block.accept0(Block.java:128)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:3019)
        at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:698)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
        at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:447)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:3042)
        at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:258)
        at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2971)
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder.findByBinding(LinkedNodeFinder.java:145)
        at org.eclipse.jdt.internal.corext.dom.LinkedNodeFinder.findByNode(LinkedNodeFinder.java:165)
        at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameLinkedMode.start(RenameLinkedMode.java:234)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:240)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.doRun(RenameJavaElementAction.java:174)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:153)
        at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:121)
        at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
        at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:252)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
        at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
        ... 56 more
```

That is whole source file I was working on:
```
package eowl.music.xml.simple;

import java.util.*;

import eowl.music.*;

/**	<p>.</p>

	@author Tomisław Kityński
	@copyright 2019 by Electric Owl, Co.
*/
public class SimpleMeasure {

	Key key;
	Meter nominalMeter;
	Meter actualMeter;
//	Boolean isComplete;
	Byte filling;	// -1 underfill, 0 regular, 1 overfill
	MeasureType type;
	
	int divisions;

	/**	<p>Measure number as per parser counter.</p> */
	int number;
	
	/**	<p>Measure number as in MusicXML.</p> */
	int mxlNumber;
	
	Long length;
	Long position;
	
	int multipleRest;
	int pageNo;
	int lineNo;
	int width;	// in tenths
//	int staves;

	//-	Note, that staffLines.length == number of staves
	/**	<p>Number of lines in each staff, where
		first staff starts at index 0.</p> */
	int[] staffLines;
	
	// https://usermanuals.musicxml.com/MusicXML/Content/EL-MusicXML-staff-layout.htm
	
	/**	<p>Distances (in tenths) to previous staff, where first staff starts
		at index 0, but 1st staff's distance is always invalid/ignored.</p> */
	int[] staffDistances;
	
	public int smLeft = -1;
	public int smRight = -1;
	public int stDistance = -1;
	public int stTopDistance = -1;
	
	public boolean repeatStart;
	public boolean repeatEnd;
	public boolean endingStart;
	public boolean endingEnd;
	
//	@Deprecated(forRemoval=true)
//	Long lastClusterPosition;

	TreeMap<Long, Set<SimpleNote>> clusterMap;
	Map<Integer, List<SimpleNote>> voiceMap;
	
	public SimpleMeasure(int divisions) {
		this.divisions = divisions;
		this.clusterMap = new TreeMap<>();
		this.voiceMap = new HashMap<>();
		this.length = null;
		this.position = null;
//		this.lastClusterPosition = null;
	}

	public int getSystemMarginLeft() {
		return this.smLeft;
	}
	
	public int getSystemMarginRight() {
		return this.smRight;
	}
	
	public int getSystemTopDistance() {
		return this.stTopDistance;
	}
	
	public int getSystemDistance() {
		return this.stDistance;
	}
	
	public int getMultipleRest() {
		return this.multipleRest;
	}
	
	public int getPageNo() {
		return this.pageNo;
	}
	
	public int getLineNo() {
		return this.lineNo;
	}
	
	public int getWidth() {
		return this.width;
	}
	
	public int getNumber() {
		return this.number;
	}

	public void setNumber(int number) {
		this.number = number;
	}
	
	public int getMxlNumber() {
		return this.mxlNumber;
	}

	public void setMxlNumber(int number) {
		this.mxlNumber = number;
	}
	
	public Key getKey() {
		return this.key;
	}

	public void setKey(Key key) {
		this.key = key;
	}

	public Meter getNominalMeter() {
		return this.nominalMeter;
	}

	public void setNominalMeter(Meter meter) {
		this.nominalMeter = meter;
	}
	
	public Meter getActualMeter() {
		if (this.actualMeter == null) {
			this.actualMeter = this.resolveActualMeter();
		}
		return this.actualMeter;
	}

	public int getDivisions() {
		return this.divisions;
	}

	public int getStaves() {
		return this.staffLines.length;
	}
	
	public int staffLinesAt(int staffIx) {
		return this.staffLines[staffIx];
	}
	
	public int fieldsAt(int staffIx) {
		return this.staffLinesAt(staffIx) - 1;
	}
	
	public int staffDistance(int staffIx) {
		return this.staffDistances[staffIx];
	}
	
	public MeasureType type() {
		return this.type;
	}
	
//	@Deprecated(forRemoval=true)
//	public long lastClusterPosition() {
//		return this.lastClusterPosition != null
//			? this.lastClusterPosition
//			: (this.lastClusterPosition = this.clusterMap.keySet().stream()
//				.max(comparing(Long::valueOf)).orElse(0L));
//	}
	
	public long position() {
		return this.position != null ? this.position : (this.position = 0L);
	}
	
	public long length() {
		return this.length != null
			? this.length
			: (this.length = this.voiceMap.values().parallelStream()
				.mapToLong(v -> v.stream()
					.mapToLong(n -> n.isChord ? 0 : n.duration).sum()
				).max().orElse(0));
	}
	
	public boolean isComplete() {
		if (this.filling == null) {
			var divsPerNote = this.getDivisions() * 4;
			var meterDur = this.getNominalMeter().duration();
			var meterLen = Math.round(meterDur * divsPerNote);
			this.filling = signum(this.length() - meterLen);
		}
		return this.filling == 0;
	}
	
	private final static byte signum(long value) {
		return (byte)(value > 0 ? 1 : value < 0 ? -1 : 0);
	}
	
	public boolean isIncomplete() {
		return !this.isComplete() && this.filling < 0;
	}
	
	public boolean isOvercomplete() {
		return !this.isComplete() && this.filling > 0;
	}
	
	public void add(SimpleNote note) {
		this.filling = null;
		this.actualMeter = null;
		if (this.position == null || this.position > note.position) {
			this.position = note.position;
		}
//		if (this.lastClusterPosition == null
//				|| this.lastClusterPosition < note.position) {
//			this.lastClusterPosition = note.position;
//		}
		var cluster = this.clusterMap.get(note.position);
		if (cluster == null) {
			cluster = new TreeSet<>((n1, n2) -> {
				//-	Order notes in block by 1) voice, 2) pitch, 3) duration
				return n1.voiceNo != n2.voiceNo
					? n1.voiceNo - n2.voiceNo
					: n1.pitch != null
							&& n2.pitch != null
							&& n1.pitch != n2.pitch
						? n1.pitch.ordinal() - n2.pitch.ordinal()
						: (int)(n1.duration - n2.duration); 
			});
			this.clusterMap.put(note.position, cluster);
		}
		cluster.add(note);
		var voice = this.voiceMap.get(note.voiceNo);
		if (voice == null) {
			voice = new ArrayList<>();
			this.voiceMap.put(note.voiceNo, voice);
		}
		voice.add(note);
	}
	
	public TreeMap<Long, Set<SimpleNote>> clusterMap() {
		return this.clusterMap;
	}
	
	private Meter resolveActualMeter() {
		final short nomDen = this.nominalMeter.getDenominator();
		final int beatLen = this.divisions * 4 / nomDen;
		final short actNum = (short)(this.length() / beatLen);
		return actNum != this.nominalMeter.getNumerator()
				? this.nominalMeter.withNumerator(actNum)
				: this.nominalMeter;
	}
}

```

where I selected `stTopDistance` instance field (by selecting I mean placing cursor in the middle of the word) and pressed Alt+Shift+R.
Carsten Hammer 2020-06-22 23:51:51 EDT
https://git.eclipse.org/r/#/c/158030/ Seems to be the responsible for the latter.
Wdyt?
Eclipse Genie 2020-06-23 02:50:16 EDT
New Gerrit change created: https://git.eclipse.org/r/165334
Eclipse Genie 2020-06-23 04:11:46 EDT
Gerrit change https://git.eclipse.org/r/165334 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=9c61965d84d687b942dc09b3bd6b804f2ecf29a6
Noopur Gupta 2020-06-29 03:11:18 EDT
*** Bug 564696 has been marked as a duplicate of this bug. ***
Kalyan Prasad Tatavarthi 2020-07-07 07:13:56 EDT
Verified in the build  I20200706-2300
Kalyan Prasad Tatavarthi 2020-07-28 06:07:29 EDT
*** Bug 565458 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=564684,564684,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[refactoring] Move Type to New File fails if the type is a record,2020/7/7,exception,1,1,record,Move member Type to New File,ast rewrite issue,"Bug 564684 - [refactoring] Move Type to New File fails if the type is a record
Clovis Seragiotto 2020-06-26 08:47:01 EDT
public record Foo(Foo.Bar bar) {
    public record Bar(int i) {}
}

Trying to move the type Bar to a new file (with refactor/Move Type to New File) throws an exception: ""An unexpected exception occurred while performing the refactoring"".
Manoj N Palat 2020-06-29 08:33:52 EDT
Getting an exception:

java.lang.IllegalArgumentException: node has no modifiers: org.eclipse.jdt.core.dom.RecordDeclaration
	at org.eclipse.jdt.internal.corext.dom.ModifierRewrite.evaluateListRewrite(ModifierRewrite.java:89)
	at org.eclipse.jdt.internal.corext.dom.ModifierRewrite.<init>(ModifierRewrite.java:62)
	at org.eclipse.jdt.internal.corext.dom.ModifierRewrite.create(ModifierRewrite.java:58)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createCompilationUnitRewrite(MoveInnerToTopRefactoring.java:929)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:836)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:731)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:86)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:122)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:210)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:89)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)

Moving to JDT.UI for further analysis
Eclipse Genie 2020-06-29 10:46:06 EDT
New Gerrit change created: https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/165566
Eclipse Genie 2020-06-29 12:13:47 EDT
Gerrit change https://git.eclipse.org/r/c/jdt/eclipse.jdt.ui/+/165566 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=a2b5e55566dae05a95328bae0209bb6f1ad966c3
Kalyan Prasad Tatavarthi 2020-07-02 23:03:44 EDT
*** Bug 564867 has been marked as a duplicate of this bug. ***
Kalyan Prasad Tatavarthi 2020-07-07 08:32:18 EDT
Verified in build  I20200706-2300
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=539429,539429,P3,JDT,UI,jjohnstn,VERI,FIXE,[1.8] Auto-refactor to lambda is too greedy when FunctionalInterface is recursive and leads to errors,2020/5/19,behavior change,1,1,lambda,Convert anonymous to lambda expression,ast rewrite issue,"Bug 539429 - [1.8] Auto-refactor to lambda is too greedy when FunctionalInterface is recursive and leads to errors
Mickael Istria 2018-09-25 08:49:16 EDT
If auto-refactor to lambda is turned on, then code like

  Function<Integer, Integer> fact = new Function<Integer, Integer>() {
    // Super important comment

    public Integer apply(Integer n) {
      return n == 0? 1 : n * fact(n-1);
    }
  }

is turned into

  Function<Integer, Integer> fact = n -> n == 0? 1 : n * fact(n-1);

This cause 2 issues:
1. a code error is reported: fact is not initialized. So the refactoring results in something that is not equivalent to the original
2. The super important comments are wiped out.

The auto-refactor to lambda should refine the conditions under which it should be performed.
Mickael Istria 2018-09-25 08:52:32 EDT
a workaround is to add something like

  @Override
  public String toString() {
    return super.toString();
  }

in the body of the nested class.
Noopur Gupta 2018-09-25 10:40:22 EDT
(In reply to Mickael Istria from comment #0)
> If auto-refactor to lambda is turned on, then code like
> 
>   Function<Integer, Integer> fact = new Function<Integer, Integer>() {
>     // Super important comment
> 
>     public Integer apply(Integer n) {
>       return n == 0? 1 : n * fact(n-1);
>     }
>   }
> 
> is turned into
> 
>   Function<Integer, Integer> fact = n -> n == 0? 1 : n * fact(n-1);
> 
> This cause 2 issues:
> 1. a code error is reported: fact is not initialized. So the refactoring
> results in something that is not equivalent to the original
Can you please specify the full example snippet without errors and do you see the same result after applying the ""Convert to lambda expression"" quick assist also? I did not get any new error after applying the quick assist on the given snippet.

> 2. The super important comments are wiped out.
That's bug 424266.
Eclipse Genie 2020-04-23 20:52:52 EDT
New Gerrit change created: https://git.eclipse.org/r/161459
Eclipse Genie 2020-05-13 13:05:24 EDT
Gerrit change https://git.eclipse.org/r/161459 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=51b0b2ca4ada003b9a99b3abd583e8c0fbdbd491
Jeff Johnston 2020-05-13 14:19:23 EDT
Released for 4.16M3
Fabrice Tiercelin 2020-05-19 13:33:53 EDT
Verified for 4.16M3 using I20200518-2220 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=486175,486175,P3,JDT,UI,jjohnstn,VERI,FIXE,Refactoring: Move method between packages misses some imports,2020/4/7,compile error,1,1,-,move method,ast rewrite issue,"Bug 486175 - Refactoring: Move method between packages misses some imports
Anna Eilertsen 2016-01-20 09:30:38 EST
Created attachment 259274 [details]
code from description example

Given two classes, A and B, in separate packages, and two methods in A, where one is an instance method and one is static, if the instance method invokes the static one without the A. qualifier, moving the instance method to B will result in missing imports. 

Example code:

package a;
import b.B;
class A{
    public B b = new B();
    static void staticMethod(){}
    void moveMe(){b.m(); staticMethod();}
}

package b;
class B{
    void m(){}
}

Move method on moveMe yields 

package a;
import b.B;
class A{
    public B b = new B();
    static void staticMethod(){}
}

package b;
class B{
    void m(){}
    void moveMe(){m(); A.staticMethod();}
}

My impression from debugging is that the imports are added in checkFinalConditions(IProgressMonitor m) in ProcessorBasedRefactoring (extended by MoveRefactoring), while the qualifier A. is added at the time the refactoring actually is executed, so there were no explicit references to A in B at the time checkFinalConditions were called.
Eclipse Genie 2020-03-26 17:42:43 EDT
New Gerrit change created: https://git.eclipse.org/r/160071
Eclipse Genie 2020-03-28 18:39:59 EDT
Gerrit change https://git.eclipse.org/r/160071 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=e10380214d7eb846c9c1ba21f7e100502e71db79
Jeff Johnston 2020-03-28 18:40:24 EDT
Released for 4.16M1
Jeff Johnston 2020-04-07 11:36:07 EDT
Verified for 4.16M1 using I20200407-0120 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=62854,62854,P3,JDT,Core,jerome_lanneluc,VERI,FIXE,refactoring does not trigger reconcile,2020/2/25,compile error,0,1,nan,pull up field,incorrect implementation,"Bug 62854 - refactoring does not trigger reconcile
Tom Hofmann 2004-05-19 05:10:30 EDT
I20040519 M9 test pass

1. Have these two classes:

========== Super.java ==========
public class Super {
}

========== Sub.java ============
public class Sub extends Super {
    private int b;
    
    public int getA() {
        return a;
    }
    
    public int getB() {
        return b;
    }
}
=================================

2.a) choose Refactoring->Pull Up, select the field b
3.a) observe: the correct refactoring
4.a) choose Refactor->Undo Pull Up
5.a) observe: refactoring is correctly undone
6.a) observe: Sub.java is not correctly reconciled:
     - outline does not show field b, only a
     - choosing ""pull up"" again ony offers field a to be pulled up, not b

2.b) choose Refactoring->Pull Up, select the field a this time
3.b) observe: the CUs are correctly refactored
4.b) observe: compile error in Sub.getA(), saying that a cannot be resolved

In both cases, modifying the cu and thus triggering a reconcile fixes the
problem. Not sure on what side the problem is.
Dirk Baeumer 2004-05-19 12:22:58 EDT
The Java reconciler is triggered correctly. It produces the following delta:

org.eclipse.jdt.core.ElementChangedEvent[source=[Working copy] Sub.java[*]: 
{CHILDREN | FINE GRAINED}
	Sub[*]: {CHILDREN | FINE GRAINED}
		b[+]: {}]

Where as the working copy is:

[Working copy] Sub.java [in <default> [in <project root> [in Test]]]
  class Sub
    int a
    int b
    int getA()
    int getB()

The stack looks as follows:

Thread [org.eclipse.jdt.internal.ui.text.JavaReconciler] (Suspended 
(breakpoint at line 75 in PackageExplorerContentProvider))
	PackageExplorerContentProvider.elementChanged(ElementChangedEvent) 
line: 75
	DeltaProcessor$2.run() line: 1469
	InternalPlatform.run(ISafeRunnable) line: 607
	Platform.run(ISafeRunnable) line: 668
	DeltaProcessor.notifyListeners(IJavaElementDelta, int, 
IElementChangedListener[], int[], int) line: 1464
	DeltaProcessor.fireReconcileDelta(IElementChangedListener[], int[], 
int) line: 1331
	DeltaProcessor.fire(IJavaElementDelta, int) line: 1289
	ReconcileWorkingCopyOperation(JavaModelOperation).run
(IProgressMonitor) line: 720
	ReconcileWorkingCopyOperation(JavaModelOperation).runOperation
(IProgressMonitor) line: 739
	CompilationUnit.reconcile(int, boolean, WorkingCopyOwner, 
IProgressMonitor) line: 1097
	JavaReconcilingStrategy.reconcile() line: 88
	JavaReconcilingStrategy.reconcile(IRegion) line: 129
	JavaCompositeReconcilingStrategy
(CompositeReconcilingStrategy).reconcile(IRegion) line: 86
	JavaCompositeReconcilingStrategy.reconcile(IRegion) line: 96
	JavaReconciler(MonoReconciler).process(DirtyRegion) line: 76
	AbstractReconciler$BackgroundThread.run() line: 200

Moving to JDT/Text.
Dirk Baeumer 2004-05-19 12:42:32 EDT
Strangly this only happens the first time when you do the refactoring after 
you have entered the source code. Here is what I did:

- started target workspace
- create Super in default package of Test project
- copied the code from above
- create Sub in default package
- copied code from above
- fixed missing field a by entering a second field
  private int a; 
  before field b;

- selected b in outline. Performed Pull-Up
- Executed Refactor Undo.
Dirk Baeumer 2004-05-19 12:44:43 EDT
Created attachment 10852 [details]
Attaching the Java model delta
Dirk Baeumer 2004-05-19 12:45:59 EDT
The Java Model delta is missing a delta for the addition of the variable b in 
Sub.java.

Unclear if the reconciler has not been triggered or if the Java Model didn't 
produce the delta.
Dirk Baeumer 2004-05-19 12:59:16 EDT
Moving to JDT/Text to check if the reconciler gets triggered.
Dirk Baeumer 2004-05-21 07:11:48 EDT
Further findings:

- refactoring saves the file after changing it so the delta computation 
  should not rely on the reconciler.

- the undo works without any problems if no working copies exists on Super
  and sub. The package explorer updates correctly then.

- the problem doesn't occur always. So it seems to be a timing issue. But when
  ever it happens the delta sent out by Java Model doesn't contain the addition
  of field b to type Sub.

- it is best reproducable (on my maschine) when the package explorer has focus
  when the refactoring undo operation is executed.
Dirk Baeumer 2004-05-21 10:21:10 EDT
*** Bug 62836 has been marked as a duplicate of this bug. ***
Dani Megert 2004-05-21 10:25:55 EDT
Our findings are as follows:
1) the delta seems to be wrong in most cases (missing addition or removal for Sub)
2) there are two paths which trigger two different deltas
a) reconciler thread calls cu.reconcile when the document changes
     ==> fine grained delta
b) main thread commits changes to ResourceTextFileBuffer which causes a resource
delta to be sent which causes J Core to send a delta

We assume that the two triggers from different threads confuse the Java model
and as a result a wrong delta gets sent.
Dani Megert 2004-05-24 03:56:29 EDT
*** Bug 63515 has been marked as a duplicate of this bug. ***
Jerome Lanneluc 2004-05-25 07:15:18 EDT
DocumentAdapter.fireBufferChanged(BufferChangedEvent) is not called for the 
Sub.java working copy. As a consequence we think that the content of the 
buffer is the same and we don't fire a delta.

Moving to JDT/Text to investigate why this is not fired.
Jerome Lanneluc 2004-05-25 07:34:14 EDT
*** Bug 63799 has been marked as a duplicate of this bug. ***
Dani Megert 2004-05-26 06:47:34 EDT
important strange detail for the test case: folding must be disabled
Tom Hofmann 2004-05-26 12:24:42 EDT
I just debugged a case where
DocumentAdapter.fireBufferChanged(BufferChangedEvent)  was called for Sub.java
(twice, because of some formatting) and the outline was still not updated.
Tom Hofmann 2004-05-26 13:42:05 EDT
I found the following:

- comment 10 is correct: the document change does not make it to the adapter
- reason for that: the DocumentAdapter is closed from the reconciler thread and
then reopened
- if the document change hits right into that gap, the change is not propagated
to jdt core.

Following a stack trace into DocumentAdapter.close:

Thread [org.eclipse.jdt.internal.ui.text.JavaReconciler] (Suspended (breakpoint
at line 237 in DocumentAdapter))
	DocumentAdapter.close() line: 237
	CompilationUnit(Openable).closeBuffer() line: 93
	ImportContainer(JavaElement).openWhenClosed(Object, IProgressMonitor) line: 583
	ImportContainer(JavaElement).getElementInfo(IProgressMonitor) line: 310
	ImportContainer(JavaElement).getElementInfo() line: 296
	ImportContainer(JavaElement).exists() line: 163
	CompilationUnit.getImports() line: 683
	SourceTypeElementInfo.getImports() line: 126
	SourceTypeConverter.convert(ISourceType[], CompilationResult) line: 109
	SourceTypeConverter.buildCompilationUnit(ISourceType[], int, ProblemReporter,
CompilationResult) line: 83
	CompilationUnitProblemFinder.accept(ISourceType[], PackageBinding) line: 100
	LookupEnvironment.askForType(PackageBinding, char[]) line: 107
	PackageBinding.getTypeOrPackage(char[]) line: 170
	CompilationUnitScope(Scope).getTypeOrPackage(char[], int) line: 1448
	ClassScope.findSupertype(TypeReference) line: 815
	ClassScope.connectSuperclass() line: 607
	ClassScope.connectTypeHierarchy() line: 700
	CompilationUnitScope.connectTypeHierarchy() line: 242
	LookupEnvironment.completeTypeBindings() line: 171
	CompilationUnitProblemFinder(Compiler).resolve(CompilationUnitDeclaration,
ICompilationUnit, boolean, boolean, boolean) line: 550
	CompilationUnitProblemFinder.process(CompilationUnitDeclaration,
ICompilationUnit, char[], Parser, WorkingCopyOwner, IProblemRequestor,
IProblemFactory, boolean, IProgressMonitor) line: 176
	CompilationUnit.buildStructure(OpenableElementInfo, IProgressMonitor, Map,
IResource) line: 145
	CompilationUnit(Openable).generateInfos(Object, HashMap, IProgressMonitor)
line: 183
	CompilationUnit(JavaElement).openWhenClosed(Object, IProgressMonitor) line: 573
	CompilationUnit.makeConsistent(boolean, int, IProgressMonitor) line: 970
	ReconcileWorkingCopyOperation.executeOperation() line: 58
	ReconcileWorkingCopyOperation(JavaModelOperation).run(IProgressMonitor) line: 700
	ReconcileWorkingCopyOperation(JavaModelOperation).runOperation(IProgressMonitor)
line: 739
	CompilationUnit.reconcile(int, boolean, WorkingCopyOwner, IProgressMonitor)
line: 1097
	JavaReconcilingStrategy.reconcile() line: 88
	JavaReconcilingStrategy.reconcile(IRegion) line: 129
	JavaCompositeReconcilingStrategy(CompositeReconcilingStrategy).reconcile(IRegion)
line: 86
	JavaCompositeReconcilingStrategy.reconcile(IRegion) line: 96
	JavaReconciler(MonoReconciler).process(DirtyRegion) line: 76
	AbstractReconciler$BackgroundThread.run() line: 200
Tom Hofmann 2004-05-26 13:44:23 EDT
moving to jdt core for comments.
Dirk Baeumer 2004-05-26 13:48:58 EDT
*** Bug 63326 has been marked as a duplicate of this bug. ***
Jerome Lanneluc 2004-05-26 14:05:40 EDT
JavaElement.getElementInfo(IProgressMonitor) should not try to open the 
element if its openable parent is open.
Jerome Lanneluc 2004-05-27 07:16:27 EDT
Actually problem was in JavaElement#openWhenClosed() that would close the 
buffer of an openable that was not the element's openable. This happened when 
reconciling the Sub.java cu: in the process of computing problems, Super.java 
was being asks if its import container existed. This caused the buffer for 
Sub.java to be closed.

Changed JavaElement#openWhenClosed() to close only the buffer of the element's 
openable. Added regression test ReconcilerTests#testBufferOpenAfterReconcile()
Dani Megert 2004-05-28 11:13:59 EDT
*** Bug 64481 has been marked as a duplicate of this bug. ***
Olivier Thomann 2004-05-28 15:32:44 EDT
Verified in 200405281200
Kai-Uwe Maetzel 2004-06-03 08:38:13 EDT
*** Bug 37870 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=525917,525917,P3,JDT,UI,jjohnstn,VERI,FIXE,[quick fix] Join variable declaration implements wrong refactoring,2020/1/7,behavior change,1,1,joint variable declaration,Join variable declaration,ast rewrite issue,"Bug 525917 - [quick fix] Join variable declaration implements wrong refactoring
Lukas Eder 2017-10-12 06:59:15 EDT
Consider the following code:

------------------------------------------------------------
public class WrongRefactoring {
    Object x = null;

    void m() {
        Object o;

        if (x != null)
            o = x.toString();
        else
            o = ""abc"";
    }
}
------------------------------------------------------------

When choosing the ""Join variable declaration"" refactoring on ""Object o"", I get the following *different* program:

------------------------------------------------------------
public class WrongRefactoring {
    Object x = null;

    void m() {
        Object o = x.toString();

        if (x != null) {}
        else
            o = ""abc"";
    }
}
------------------------------------------------------------

It is clearly different because I can now get a NPE, which I couldn't get before!

A more reasonable refactoring would be to produce a conditional operator:

------------------------------------------------------------
public class WrongRefactoring {
    Object x = null;

    void m() {
        Object o = x != null ? x.toString() : ""abc"";
    }
}
------------------------------------------------------------

I can achieve this explicitly by choosing the ""Replace 'if-else' with conditional"" quick fix:

------------------------------------------------------------

public class WrongRefactoring {
    Object x = null;

    void m() {
        Object o;

        o = x != null ? x.toString() : ""abc"";
    }
}
------------------------------------------------------------

*and then* the ""Join variable declaration"" quick fix.

I think that's a significant bug, because users might not notice it and produce wrong code!
Eclipse Genie 2019-11-13 15:54:01 EST
New Gerrit change created: https://git.eclipse.org/r/152616
Eclipse Genie 2020-01-03 15:35:08 EST
Gerrit change https://git.eclipse.org/r/152616 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=6ff255082694dff064e6c69de236fa31ba6de6b6
Jeff Johnston 2020-01-03 15:35:45 EST
Released for 4.15M1
Jeff Johnston 2020-01-07 14:29:18 EST
Verified for 4.15M1 using I20200107-0600 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=108147,108147,P3,JDT,UI,jjohnstn,VERI,FIXE,[reorg] import statement not moved with moved static initializer [refactoring],2019/11/19,compile error,1,1,static initializer,move method,ast rewrite issue,"Bug 108147 - [reorg] import statement not moved with moved static initializer [refactoring]
Brian Miller 2005-08-26 12:49:18 EDT
------------------- Source.java ----------------
import java.util.*;
class Source {
    static{new Stack();}
}

------------------ Destination.java --------------
class Destination {}
Dirk Baeumer 2005-08-29 05:41:28 EDT
The reason for this is that the move of a static initializer is a pure textual
move right now.

Tobias, we might want to look into making this a full refactoring move.
Dirk Baeumer 2005-08-29 05:42:45 EDT
*** Bug 108145 has been marked as a duplicate of this bug. ***
Eclipse Genie 2019-03-22 09:49:23 EDT
This bug hasn't had any activity in quite some time. Maybe the problem got resolved, was a duplicate of something else, or became less pressing for some reason - or maybe it's still relevant but just hasn't been looked at yet.

If you have further information on the current state of the bug, please add it. The information can be, for example, that the problem still occurs, that you still want the feature, that more information is needed, or that the bug is (for whatever reason) no longer relevant.

--
The automated Eclipse Genie.
Dani Megert 2019-03-22 11:35:10 EDT
Still broken in 4.11.
Eclipse Genie 2019-10-30 18:38:16 EDT
New Gerrit change created: https://git.eclipse.org/r/151820
Eclipse Genie 2019-10-31 16:24:35 EDT
Gerrit change https://git.eclipse.org/r/151820 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=7e193f50e6652db32d1b98d44a95d8444c726d6c
Jeff Johnston 2019-10-31 16:27:02 EDT
Released for 4.14M3
Jeff Johnston 2019-11-19 20:50:25 EST
Verified for 4.14M3 using I20191119-1800 build
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=551002,551002,P3,JDT,UI,kalyan_prasad,RESO,FIXE,[13] Refactor > Extract Local Variable and Extract Constant not working on Text Block,2019/9/12,not available,1,1,-,Extract Local Variable;Extract Constant;Inline Method,others,"Bug 551002 - [13] Refactor > Extract Local Variable and Extract Constant not working on Text Block
Kalyan Prasad Tatavarthi 2019-09-12 04:29:24 EDT
Refactor > Extract Local Variable and Extract Constant do not work on Text Block
Eclipse Genie 2019-09-12 05:19:46 EDT
New Gerrit change created: https://git.eclipse.org/r/149406
Kalyan Prasad Tatavarthi 2019-09-12 05:22:42 EDT
(In reply to Eclipse Genie from comment #1)
> New Gerrit change created: https://git.eclipse.org/r/149406

This gerrit patch handles 
1) Refactor > Extract Local Variable...
2) Refactor > Extract Constant
and laso
3) Refactor > Inline...

the test case for 3. is as below

public static void main(String[] args) {
    System.out.println(abc());
}
	
public static String abc() {
    return """"""
	   abc
	   defg
	   lksjkljsd
	   """""";
}

Select method declaration abc() and Right click Refactor > Inline...
Eclipse Genie 2019-09-12 09:01:06 EDT
Gerrit change https://git.eclipse.org/r/149406 was merged to [BETA_JAVA13].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=55dc116ab4fec031a3ab8e6606e70730a2e17f89
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=547094,547094,P3,JDT,Core,stephan.herrmann,VERI,FIXE,Refactoring not working with Java 11 (NPE at org.eclipse.jdt.internal.compiler.util.Sorting.sortSuper(Sorting.java:75),2019/5/21,exception,1,1,-,rename method,others,"Bug 547094 - Refactoring not working with Java 11 (NPE at org.eclipse.jdt.internal.compiler.util.Sorting.sortSuper(Sorting.java:75)
Nicole Behlen 2019-05-08 09:55:26 EDT
Created attachment 278540 [details]
log file

In some cases I am not able to refactor a method name with java 11 and compliance also set to java 11.

In error log a NPE is reported

Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.util.Sorting.sortSuper(Sorting.java:75)
	at org.eclipse.jdt.internal.compiler.util.Sorting.sort(Sorting.java:56)
	at org.eclipse.jdt.internal.compiler.util.Sorting.sortTypes(Sorting.java:44)
Nicole Behlen 2019-05-08 10:00:05 EDT
Created attachment 278541 [details]
project for reproducing the problem

this problem is reproducible, when trying to refactor (renaming) the method debug of the class com.mytest.other.Log

setting the compliance level to java 1.8, the refactor (renaming) works without any problem
Nicole Behlen 2019-05-09 03:40:57 EDT
Created attachment 278549 [details]
exception CTRL+Shift+G (references)

I also get the NPE when searching References.
Andrey Loskutov 2019-05-10 15:51:04 EDT
Can you please try 4.12 nigtly build?
Stephan Herrmann 2019-05-10 17:00:51 EDT
Thanks a lot. An NPE in this location has been reported time and again, but today for the first time I'm able to watch this exception occurring live and in 3D.
Stephan Herrmann 2019-05-10 17:17:46 EDT
Broken in 4.11, works in HEAD, can be re-broken by reverting the fix for bug 545293

Before marking as a duplicate of that bug, I will use the opportunity to check if we can harden the implementation in a meaningful way to avoid that NPE.
Stephan Herrmann 2019-05-10 17:56:43 EDT
Some findings:

NPE occurs during MethodVerifier.computeInheritedMethods() if one of the superInterfaces is LE.TheNotFoundType.

AFAICS the intention is to always use MissingTypeBinding instead, which is more robust for further handling downstream.

The reason for TheNotFoundType occurring here is:
- due to bug 545293 tons of (all?) JRE types were not found
- due to the fix for bug 522327 this type escaped LE#getTypeFromCompoundName()

The condition for the latter issue looked a bit complex:
- getCachedType() returned null, because the containing package is an SPB,
  which prefers answering null rather than TheNotFoundType
- computePackageFrom() answered a plain package
- packageBinding.getType0() found TheNotFoundType from some previous lookup

The mistake from bug 522327 was to bypass
  if (binding == TheNotFoundType)
by keeping it as
  } else if (binding == TheNotFoundType) {
 
Removing ""else"" avoids the NPE downstream, because this ensures that TheNotFoundType is replaced with a MissingTypeBinding.

(history around bug 522327 is a bit blurred by removal and revert from bug 522671).
Eclipse Genie 2019-05-10 18:00:40 EDT
New Gerrit change created: https://git.eclipse.org/r/141999
Stephan Herrmann 2019-05-10 19:12:52 EDT
@Till, I don't have a test but if you could do a review I'd still like to release this change?
Eclipse Genie 2019-05-11 05:14:02 EDT
Gerrit change https://git.eclipse.org/r/141999 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=66765d11a86c7477838a39eafba6169fca506ed3
Till Brychcy 2019-05-11 05:18:09 EDT
(In reply to Stephan Herrmann from comment #8)
> @Till, I don't have a test but if you could do a review I'd still like to
> release this change?

Good catch! Fix looks good. I've merged it is was possible without rebase.

(In reply to Eclipse Genie from comment #9)
> Gerrit change https://git.eclipse.org/r/141999 was merged to [master].
> Commit:
> http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
> ?id=66765d11a86c7477838a39eafba6169fca506ed3

Released for 4.12M3
Stephan Herrmann 2019-05-11 07:21:41 EDT
(In reply to Till Brychcy from comment #10)
> (In reply to Stephan Herrmann from comment #8)
> > @Till, I don't have a test but if you could do a review I'd still like to
> > release this change?
> 
> Good catch! Fix looks good. I've merged it is was possible without rebase.
> 
> (In reply to Eclipse Genie from comment #9)
> > Gerrit change https://git.eclipse.org/r/141999 was merged to [master].
> > Commit:
> > http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
> > ?id=66765d11a86c7477838a39eafba6169fca506ed3
> 
> Released for 4.12M3

Thanks for your time!
Stephan Herrmann 2019-05-11 14:02:57 EDT
*** Bug 546740 has been marked as a duplicate of this bug. ***
Manoj N Palat 2019-05-21 06:03:57 EDT
Verified for Eclipse Version: 2019-06 (4.12) Build id: I20190520-0600
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=544992,544992,P3,JDT,UI,rgrunber,RESO,FIXE,[10][refactoring] convert local variable to field not working for 'var',2019/4/2,compile error,1,1,var type,convert local variable ,Incorrect Type Resolving,"Bug 544992 - [10][refactoring] convert local variable to field not working for 'var'
Clovis Seragiotto 2019-03-03 03:58:06 EST
Original code:

public class Foo {
    static void foo() {
        var a = """";
        System.out.println(a);
    }
}

After ""convert local variable to field"" for variable <a>:

public class Foo {
    private static var a;

    static void foo() {
        a = """";
        System.out.println(a);
    }
}
Jay Arthanareeswaran 2019-03-06 23:55:01 EST
Looking at the code, I think PromoteTempToFieldRefactoring knows enough to extract the type to be able to fix this.

Moving to UI.
Noopur Gupta 2019-03-07 00:41:59 EST
Roland, can you please take a look at this?
Roland Grunberg 2019-03-07 14:50:36 EST
Version: 2019-03 (4.11)
Build id: I20190307-0500

I'm also able to reproduce. I've got a fix similar to what I did for the try/catch work. If the 'var' statement must be split due to the refactoring, then it should get resolved to its inferred type (String in the example).
Eclipse Genie 2019-03-07 15:28:39 EST
New Gerrit change created: https://git.eclipse.org/r/138300
Eclipse Genie 2019-04-02 06:48:02 EDT
Gerrit change https://git.eclipse.org/r/138300 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=a1aec7e49bb03171b086f9aa7e5855d10b4be0b1
Noopur Gupta 2019-04-02 07:17:31 EDT
Thanks, Roland.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=540873,540873,P3,JDT,UI,rgrunber,VERI,FIXE,[10][move] Refactor/Move generates invalid code with 'var',2018/11/21,compile error,1,1,var type,move class,Incorrect Type Resolving,"Bug 540873 - [10][move] Refactor/Move generates invalid code with 'var'
Clovis Seragiotto 2018-11-07 04:00:38 EST
Original code:

class Foo {
    static class X {}

    static class Y {}

    static void foo() {
        var x = new X();
    }
}

After Refactoring/Move... (moving class X to Y):

class Foo {
    static class Y {

        static class X {}}

    static void foo() {
        Y.var x = new Y.X();
    }
}

Problem: ""var x"" became ""Y.var x""
Noopur Gupta 2018-11-08 01:44:16 EST
It should be handled similar to bug 539289 i.e. change 'var' to the actual type and then perform the refactoring. We should also consider the case when the refactoring is applied to multiple types at the same time i.e. on a package etc. and inform the user that it will result in changing the type 'var'.
Noopur Gupta 2018-11-08 01:47:20 EST
The other option is to leave the 'var' type as it is and don't qualify it while performing the refactoring. I think this will be a better approach for this case.

Roland, can you please take a look at this one?
Eclipse Genie 2018-11-08 14:10:16 EST
New Gerrit change created: https://git.eclipse.org/r/132143
Noopur Gupta 2018-11-09 03:03:18 EST
(In reply to Eclipse Genie from comment #3)
> New Gerrit change created: https://git.eclipse.org/r/132143

This patch works for the given case but fails in the following example when Y is moved to X:

class Foo {
	static class X {
	}

	static class Y {
		static void foo() {
			var x = new X();
		}
	}
}
Roland Grunberg 2018-11-09 14:08:09 EST
(In reply to Noopur Gupta from comment #4)
> (In reply to Eclipse Genie from comment #3)
> > New Gerrit change created: https://git.eclipse.org/r/132143
> 
> This patch works for the given case but fails in the following example when
> Y is moved to X:
> 
> class Foo {
> 	static class X {
> 	}
> 
> 	static class Y {
> 		static void foo() {
> 			var x = new X();
> 		}
> 	}
> }

Thanks for trying this out.

Looks like ReferenceAnalyzer handles references to moved members, but for the moved members themselves, it's handled by MovedMemberAnalyzer.
Eclipse Genie 2018-11-12 04:41:29 EST
Gerrit change https://git.eclipse.org/r/132143 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=1eefd99e462f44c9b4a4e7b1d29c7b135c7ddc83
Noopur Gupta 2018-11-12 04:43:03 EST
Thanks, released the fix in master.
Noopur Gupta 2018-11-21 04:25:07 EST
Verified as fixed in I20181120-1800.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=532996,532996,P3,JDT,UI,kalyan_prasad,VERI,FIXE,[10] Refactor -> Rename operation should not be available on 'var' type,2018/3/29,others,1,1,var type,rename variable,overly weak preconditions,"Bug 532996 - [10] Refactor -> Rename operation should not be available on 'var' type
Kalyan Prasad Tatavarthi 2018-03-28 07:27:47 EDT
In the below snippet

class One {
};

public class Test {
    {
          var one = new One();
    } 
}


Refactor->Rename operation  is available on var and it renames the class One , which is not the expected behavior. This operation should not be available on var type.
Sasikanth Bharadwaj 2018-03-29 02:25:45 EDT
While you are at this, also check that rename operation is available for variables declared using var declaration when they are assigned later on as well. 

For example, if we have a var v = 100; at one point and at some latter point in the code assign v = 200;
rename operation should be available at the latter point as well. I see that this works for simple types like the one mentioned above but does not for other types.
I would suspect this could be because of intersection types, but I may be wrong
Eclipse Genie 2018-03-29 03:21:44 EDT
New Gerrit change created: https://git.eclipse.org/r/120401
Eclipse Genie 2018-03-29 03:43:12 EDT
Gerrit change https://git.eclipse.org/r/120401 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=e6058a2669d4f36d3a69db40480d577ed82b633b
Eclipse Genie 2018-03-29 03:43:14 EDT
New Gerrit change created: https://git.eclipse.org/r/120404
Eclipse Genie 2018-03-29 03:43:25 EDT
Gerrit change https://git.eclipse.org/r/120404 was merged to [R4_7_maintenance].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=c44c4d0de7c71de256928d90be5551114aa04d73
Kalyan Prasad Tatavarthi 2018-03-29 03:46:51 EDT
(In reply to Sasikanth Bharadwaj from comment #1)
> While you are at this, also check that rename operation is available for
> variables declared using var declaration when they are assigned later on as
> well. 
> 
> For example, if we have a var v = 100; at one point and at some latter point
> in the code assign v = 200;
> rename operation should be available at the latter point as well. I see that
> this works for simple types like the one mentioned above but does not for
> other types.
> I would suspect this could be because of intersection types, but I may be
> wrong

Can you please provide an example where this functionality is not working?

I am resolving this bug as the issue reported for this bug is fixed. If You provide a use case where rename is not working, I will open an other bug to handle this issue.
Eclipse Genie 2018-03-29 05:40:45 EDT
New Gerrit change created: https://git.eclipse.org/r/120421
Eclipse Genie 2018-03-29 05:41:27 EDT
Gerrit change https://git.eclipse.org/r/120421 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=c18c674600c765991e164a669d58708e7f9a7de8
Noopur Gupta 2018-03-29 05:46:42 EDT
Released the fix to disable rename in file/workspace quick assists on the type 'var' to both master and R4_7 branches.
Eclipse Genie 2018-03-29 06:12:35 EDT
New Gerrit change created: https://git.eclipse.org/r/120425
Eclipse Genie 2018-03-29 06:19:48 EDT
Gerrit change https://git.eclipse.org/r/120425 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=02939fd8fa3ed56f2a6305da596d65953b43c222
Eclipse Genie 2018-03-29 06:19:50 EDT
New Gerrit change created: https://git.eclipse.org/r/120426
Eclipse Genie 2018-03-29 06:20:32 EDT
Gerrit change https://git.eclipse.org/r/120426 was merged to [R4_7_maintenance].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=ee26c07ed246304886c0a1cae1827962e00c9b4e
Noopur Gupta 2018-03-29 06:29:42 EDT
public class ZZ {
	void test() {
		var comp = new ZZ();
		comp = new ZZ();
		System.out.println(comp);
	}
}

- Start rename in file/workspace on 'ZZ'. It should not include 'var' in rename i.e. 'var' should not appear in linked mode while renaming 'ZZ'.

Commits in comment #11 and comment #13 fix this issue.
Dani Megert 2018-03-29 12:08:39 EDT
Verified in eclipse-SDK-M20180329-1005-win32-x86_64.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=416198,416198,P3,JDT,UI,manju656,RESO,FIXE,[Inline] Inline method refactoring fails to update method reference as of enum constructor call's argument,2016/9/3,compile error,1,1,enum,inline method,flow analysis issue,"Bug 416198 - [Inline] Inline method refactoring fails to update method reference as of enum constructor call's argument
Jongwook Kim 2013-08-29 21:33:13 EDT
Here is the code snippet before applying inline refactoring:

public class A {
	public static int i;

	public static int getI() {         // APPLY INLINE HERE
		return i;
	}
}

public enum B {
	m(A.getI());
	
	B(int j){		
	}
}

Applying inline refactoring to getI() cannot update A.getI() that is a parameter of enum constructor call:

public class A {
	public static int i;
}

public enum B {
	m(A.getI());             // ERROR
	
	B(int j){		
	}
}
Martin Mathew 2013-08-30 03:23:58 EDT
Reproducible using Eclipse Build id: I20130820-0800.

As per the initial investigation in-lining with in an EnumConstantDeclaration having a MethodInvocation argument is not handled. We will require modification in TargetProvider, where we need a #visit(EnumConstantDeclaration).
Martin Mathew 2013-08-30 04:56:34 EDT
Created attachment 235023 [details]
Patch with testcases.

Modified the InvocationFinder ASTVisitor to consider EnumConstantDeclaration. Added a testcase for the reported scenario.

Dani, kindly let me know whether the approach is right.
Dani Megert 2014-04-15 11:25:40 EDT
Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=54ea4fdbda3ed1872331fd567678081492644323
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=497368,497368,P3,JDT,UI,noopur_gupta,RESO,FIXE,[pull up] Pull Up refactoring to interface generates broken code,2016/7/18,compile error,1,1,input options,pull up method,ast rewrite issue,"Bug 497368 - [pull up] Pull Up refactoring to interface generates broken code
Carsten Reckord 2016-07-06 04:45:03 EDT
Create an interface IFoo and implementing classes Foo, FooImpl1, FooImpl2. In Foo, define a method as follows:

	public void log(Level level, String message, String... parameters) {
		String formattedMessage = MessageFormat.format(message, (Object[])parameters);
		System.out.println(""Logging ""+message+"" with ""+Arrays.asList(parameters));
		LogManager.getLogManager().getLogger(Foo.class.getName()).log(level, formattedMessage);
	}

Use the Pull Up refactoring to pull the method up into interface IFoo. In the wizard, select ""Create necessary method stubs ...""

Expected outcome:
1. The result is compile-error free
2. The method is added to IFoo along with imports needed for the method signature
3. The method is added to all non-abstract implementors along with imports needed for the method signature
4. The method in implementors looks the same as when using the ""Add unimplemented methods"" hotfix to create it, including
- task marker //TODO auto-generated method stub
- @Override annotation

The method stub should look something like this:

	//import for java.util.logging.Level
	
	@Override
	public void log(Level level, String message, String... parameters) {
		// TODO Auto-generated method stub
		
	}

Actual outcome:
1. All implementors (except Foo) have compile errors
2. IFoo gets additional, unnecessary imports for classes used in the method body of the original implementation in Foo
3. Imports needed for the method signature are not added to implementors
4. The method in implementors lacks both the //TODO marker and the @Override annotation

The method stub actually looks like this:

	//no import for java.util.logging.Level

	public void log(Level level, String message, String... parameters) {
	}
Noopur Gupta 2016-07-15 07:52:36 EDT
*** Bug 444002 has been marked as a duplicate of this bug. ***
Noopur Gupta 2016-07-15 08:03:24 EDT
*** Bug 35167 has been marked as a duplicate of this bug. ***
Eclipse Genie 2016-07-15 08:10:07 EDT
New Gerrit change created: https://git.eclipse.org/r/77384
Eclipse Genie 2016-07-18 04:07:03 EDT
Gerrit change https://git.eclipse.org/r/77384 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=a2db02a5370121790fc04dfd719f54f39ad664e0
Noopur Gupta 2016-07-18 04:19:12 EDT
Fixed the issues in PullUpRefactoringProcessor and released the changes with tests. 

Didn't use StubUtility2 as Pull Up refactoring uses MemberVisibilityAdjustor and ImportRewriteUtil#addImports also based on different cases.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=396524,396524,P3,JDT,UI,register.eclipse,RESO,FIXE,[refactoring] Pull Up and Extract Interface refactorings add unexpected @Override,2016/4/25,compile error,1,1,-,pull up method,ast rewrite issue,"Bug 396524 - [refactoring] Pull Up and Extract Interface refactorings add unexpected @Override
Jan Koehnlein 2012-12-13 12:22:49 EST
Pull-up refactoring 
- does not add imports for parameters and return types to destiantion type
- adds an @Override to the source member even if the runtime environment is set to Java 5 and the target is an interrface

=> broken code
Jesse Weinstein 2013-02-11 18:21:37 EST
I'm unable to verify this with eclipse-SDK-N20130210-2000-win32, as best as I can understand the bug.

Specifically, running ""Pull Up"" does add (and remove) imports correctly, for both parameters and return types. I don't fully understand what the 2nd item mentioned means.

Jan -- please clarify exactly what you observed, and what was wrong with it. Also, specifying the version of Eclipse you are using would be helpful.
Jan Koehnlein 2013-02-12 02:58:45 EST
Hmm, strange it's so easy to reprodice here (MacOSX, Eclipse 4.3M5a)

1) Create a plugin project 'test.plugin' with J2SE-1.5 as execution environment (no UI contribution, no activator).

2) Create an interface 'Foo':
  package test.plugin;
  public interface Foo {
  }

3) Create a class 'Bar':
  package test.plugin;
  import java.io.File;
  public class Bar implements Foo {
    public void method(File x) {}
  }

4) Everything is fine and compieles nicely. Now trigger pull-up refactoring on 'method' with default settings

=>

Foo:
  package test.plugin;
  public interface Foo {
    public abstract void method(File x);  
  }
-> compile error because of missing import for java.io.File

Bar:
  package test.plugin;
  import java.io.File;
  public class Bar implements Foo {
    @Override   
    public void method(File x) {}
  }
-> @Override for interface method is not supported in Java5
-> 3 compile errors as the interface does not compile and the method 'method' cannot be found.

So pull-up refactoring breaks both, the source (the class 'Bar' where the method resides originally) and the target (the interface 'Foo').
Dani Megert 2013-02-12 06:38:16 EST
Can reproduce with 4.3 M5 and also old versions of Eclipse (e.g. 3.6).

Paste this into 'Package Explorer':

  package test.plugin;
  public interface Foo {
  }
  package test.plugin;
  import java.io.File;
  public class Bar implements Foo {
    public void method(File x) {}
  }
Jesse Weinstein 2013-02-12 14:01:02 EST
I've now also been able to verify it with Indigo. Jan, thanks for providing the additional information, and Dani -- I'd forgotten about the very neat pasteable code feature. That makes verification much easier.
Jared Martin 2014-02-24 11:18:54 EST
I had this problem in Kepler SR 1 today
Martin Mathew 2014-02-24 18:22:10 EST
(In reply to Jared Martin from comment #5)
> I had this problem in Kepler SR 1 today

Fix for bug 426963 will take care of the missing import scenario.
Jared Martin 2014-03-26 16:19:51 EDT
(In reply to Manju Mathew from comment #6)
> (In reply to Jared Martin from comment #5)
> > I had this problem in Kepler SR 1 today
> 
> Fix for bug 426963 will take care of the missing import scenario.

Matt, does that bug fix also fix the @Override problem?
Martin Mathew 2014-03-27 02:59:25 EDT
Created attachment 241303 [details]
Patch+Tests

PullUp refactoring adding @Override annotation for interface methods for projects in Java 1.5 is taken care by this patch. 
The import issue will be handled by bug 426963.
Martin Mathew 2014-03-27 03:02:35 EDT
Noopur, can you have a look. The fix was simple, if the pullup method destination is interface then the Java project should be 1.6 or higher for the @Override annotation to be added.
Jared Martin 2014-03-27 10:02:05 EDT
Hi Mat,

I just realized I misread the case, this is not a Java 5 issue. Maybe I should make a separate case? Let me know, but follow these steps to reproduce the issue I was referring to in my comment:

Create the following three classes in a Java 7 project (this is using 4.3 SR1)

IFoo.java:

	public interface IFoo {
	}

SomeFoo.java:

	public abstract class SomeFoo implements IFoo {
		public abstract void doSomething();
	}

BarFoo.java

	public class BarFoo extends SomeFoo {
		@Override
		public void doSomething() {
	
		}
	}

Then, while in BarFoo.java use refactor -> pull up on the doSomething method.

After the refactoring, there will be two @Override tags.
Martin Mathew 2014-03-27 21:38:21 EDT
(In reply to Jared Martin from comment #10)
> After the refactoring, there will be two @Override tags.
That should be handled in bug 394551. Will put a note in that bug. Thanks.

Manju. 
Ps: Mat sounds very manly but i am a lady :-)
Martin Mathew 2014-03-28 03:20:22 EDT
Created attachment 241357 [details]
Patch+Tests

This patch contains the fix for the missing @Override and duplicate  @Override annotation (bug 394551).

I have modified StubUtility2#addAnnotation method to handle the missing and duplicate @Override annotation cases. All the refactoring tests are green after the change.

@Noopur: Though there are more file changes this time, it is due to the ripple effect of modifying StubUtility2#addAnnotation and hence just one line changes in many files.

Added test for unwanted @Override annotation during pull up in Java 5 and duplicate @Override annotation during extract interface refactoring in Java 7.

Bug 426963 will take care of the missing import scenario.
Martin Mathew 2014-03-28 03:22:22 EDT
(In reply to Manju Mathew from comment #12)
> Created attachment 241357 [details] [diff]
> Patch+Tests
> 
> This patch contains the fix for the missing @Override

Not missing but unwanted @Override annotation.
Martin Mathew 2014-04-15 03:44:43 EDT
Created attachment 241997 [details]
Patch+Tests

Following issues are handled in this patch.
1. In Java 1.5 if a method is pulled up to an Interface, then @Override annotation should not be added.
2. Bug 394551, for Java 1.6 and above, when user performs Extract Interface or Pull up the method to an interface where the method already has @Override annotation, then duplicate annotation was added.

In StubUtility2, the existing method is not modified instead the method is overloaded to handle different cases. Tests are also added for the different cases.

Noopur, kindly have a look at the patch.
Noopur Gupta 2014-04-21 05:07:26 EDT
(In reply to Manju Mathew from comment #14)
> Created attachment 241997 [details] [diff]
> Patch+Tests
The patch looks good except the following issue which needs to be fixed:
---------------------------------
package bug2;

public class BarFoo extends SomeFoo {
	public void doSomething() {

	}
}

abstract class SomeFoo implements IFoo {
	public abstract void doSomething();
}

interface IFoo {
}
----------------------------------
Paste the above code in a Java 1.7 project.
Go to Java Compiler Errors/Warnings preferences and uncheck ""Include implementations of interface methods (1.6 or higher)"" for that project.

Now, pull up BarFoo#doSomething to IFoo.
Earlier: BarFoo#doSomething used to get @Override.
Now: BarFoo#doSomething does not get @Override.
Noopur Gupta 2014-04-21 05:17:11 EDT
It may need a review again after the fix.
Manju, if you are confident after the fix then release the patch directly.
Martin Mathew 2014-04-30 22:27:53 EDT
(In reply to Noopur Gupta from comment #15)

> The patch looks good except the following issue which needs to be fixed:
> Paste the above code in a Java 1.7 project.
> Go to Java Compiler Errors/Warnings preferences and uncheck ""Include
> implementations of interface methods (1.6 or higher)"" for that project.

Check bug 392931, this is the intended behavior. From bug 392931 comment 1, ""When that checkbox is checked and the diagnostic is set to error or warning, then we have to generate @Override. But when the checkbox is unchecked, we can also not add @Override.""
Noopur Gupta 2014-05-02 01:47:45 EDT
(In reply to Manju Mathew from comment #17)
> (In reply to Noopur Gupta from comment #15)
> Check bug 392931, this is the intended behavior. From bug 392931 comment 1,
> ""When that checkbox is checked and the diagnostic is set to error or
> warning, then we have to generate @Override. But when the checkbox is
> unchecked, we can also not add @Override.""

That bug also says ""Note that generation of @Override can be toggled on the Code Style preference page"".

So, if ""Add @Override..."" is checked in Code Style preference page and the ""Include implementations..."" checkbox is unchecked at Java Compiler Errors/Warnings preference page with the diagnostic as Ignore, the behavior is different before and after the patch. 

Just confirm if that is the intended behavior.
Martin Mathew 2014-05-02 02:46:55 EDT
(In reply to Noopur Gupta from comment #18)
> That bug also says ""Note that generation of @Override can be toggled on the
> Code Style preference page"".
> 
> So, if ""Add @Override..."" is checked in Code Style preference page and the
> ""Include implementations..."" checkbox is unchecked at Java Compiler
> Errors/Warnings preference page with the diagnostic as Ignore, the behavior
> is different before and after the patch. 
Before the patch, it was a bug that @Override annotation was being added to implementation of interface methods for projects in Java 1.5. The patch fixes the issue and adds @Override annotation for implementation of interface methods only if it is in Java 1.6 and higher and also after considering ""Include implementations..."" option in Java Compiler Errors/Warnings preference page.

> Just confirm if that is the intended behavior.
""Add @Override..."" in Code Style preference page decides whether @Override annotation should be added at all, whether interface or class. If this option is unchecked, then none of the overriden method generated through refactoring will get @Override annotation.

""Include implementations..."" option in Java Compiler Errors/Warnings preference page lets user decide whether @Override annotation be added for the implementation of Interface methods for 1.6 and higher.

So when ""Add @Override..."" is checked and the ""Include implementations..."" checkbox is unchecked, then implementations of interface methods for 1.6 and higher will not have @Override annotation added to them.

@Markus: Kindly verify our understanding.
Martin Mathew 2014-05-02 03:01:08 EDT
Came across the scenario when ""Add @Override..."" is unchecked in Code Style preference page and ""Missing '@Override' annotation"" in Java Compiler Errors/Warnings preference page is set to ""ERROR"", then Pull Up Refactoring adds @Override annotation. Isn't that wrong? Using the same setting when a method is overriden in a class implementing an interface, then the @Override annotation is not added.
Martin Mathew 2014-05-18 19:43:30 EDT
*** Bug 394551 has been marked as a duplicate of this bug. ***
Markus Keller 2014-06-30 11:58:55 EDT
(In reply to Manju Mathew from comment #19)
Sounds all good, except for the decision whether @Override annotation should be added at all. The code in PullUpRefactoringProcessor#createAbstractMethod(..) was added for bug 97215 to avoid creating compile errors on Pull Up if the ""Add @Override..."" code style is unchecked. We should expand that to a general policy that should be used everywhere:

Add the @Override if source level >= 1.5 and (if interface method in 1.6 and COMPILER_PB_MISSING_OVERRIDE_ANNOTATION_FOR_INTERFACE_METHOD_IMPLEMENTATION is enabled), and
- if ""Add @Override..."" in Code Style preference page is checked,
- or if the severity of COMPILER_PB_MISSING_OVERRIDE_ANNOTATION is not IGNORE.

I think the problem in comment 20 is that the code in StubUtility2#addOverrideAnnotation(..) doesn't have enough context and decides based on source level and COMPILER_PB_MISSING_OVERRIDE_ANNOTATION_FOR_INTERFACE_METHOD_IMPLEMENTATION alone. The decision when and when not to add @Override should be centralized in StubUtility2.

Implementation problems:
- The old code with newSimpleName(""Override"") was already bad and should be replaced with importRewrite.addImport(""java.lang.Override"", ...).
- The new code in StubUtility2#isOverrideAnnotationPresent(MethodDeclaration) makes wrong assumptions about the AST representation of the annotation. It should use ""java.lang.Override"".equals(binding.getQualifiedName()) to check for the annotation, so that it also works for @java.lang.Override or @Override(), or even if the Override annotation should get an optional argument in the future.

> Came across the scenario when ""Add @Override..."" is unchecked in Code Style
> preference page and ""Missing '@Override' annotation"" in Java Compiler
> Errors/Warnings preference page is set to ""ERROR"", then Pull Up Refactoring
> adds @Override annotation. Isn't that wrong? Using the same setting when a
> method is overriden in a class implementing an interface, then the @Override
> annotation is not added.
Noopur Gupta 2016-04-18 07:32:03 EDT
*** Bug 491195 has been marked as a duplicate of this bug. ***
Noopur Gupta 2016-04-18 07:38:29 EDT
Updating the bug summary as the issue of missing imports has been fixed via bug 426963.
Eclipse Genie 2016-04-18 16:37:30 EDT
New Gerrit change created: https://git.eclipse.org/r/70907
Till Brychcy 2016-04-18 16:40:49 EDT
(In reply to Eclipse Genie from comment #25)
> New Gerrit change created: https://git.eclipse.org/r/70907

I've rebased the patch and adjusted the tests (removed public abstract in interfaces; removed @Override-annotation in PullUpTests.test52, because test setup if for java 1.5)

I haven't done anything suggested in comment #22 yet.
Till Brychcy 2016-04-20 17:28:11 EDT
(In reply to Markus Keller from comment #22)
[...]
> Add the @Override if source level >= 1.5 and (if interface method in 1.6 and
> COMPILER_PB_MISSING_OVERRIDE_ANNOTATION_FOR_INTERFACE_METHOD_IMPLEMENTATION
> is enabled), and
> - if ""Add @Override..."" in Code Style preference page is checked,
> - or if the severity of COMPILER_PB_MISSING_OVERRIDE_ANNOTATION is not
> IGNORE.
> 
> I think the problem in comment 20 is that the code in
> StubUtility2#addOverrideAnnotation(..) doesn't have enough context and
> decides based on source level and
> COMPILER_PB_MISSING_OVERRIDE_ANNOTATION_FOR_INTERFACE_METHOD_IMPLEMENTATION
> alone. The decision when and when not to add @Override should be centralized
> in StubUtility2.

I've done that part in patch set 3 (I haven't run all tests yet, so there might be some  failures of tests that need to be adjusted, because of the new rule ""or if the severity of COMPILER_PB_MISSING_OVERRIDE_ANNOTATION is not IGNORE"")
Till Brychcy 2016-04-21 13:48:34 EDT
(In reply to Markus Keller from comment #22)
> Implementation problems:
> - The old code with newSimpleName(""Override"") was already bad and should be
> replaced with importRewrite.addImport(""java.lang.Override"", ...).
> - The new code in
> StubUtility2#isOverrideAnnotationPresent(MethodDeclaration) makes wrong
> assumptions about the AST representation of the annotation. It should use
> ""java.lang.Override"".equals(binding.getQualifiedName()) to check for the
> annotation, so that it also works for @java.lang.Override or @Override(), or
> even if the Override annotation should get an optional argument in the
> future.

I've done these remaining things from comment #22 in patch set 4.

@Noopur, same question I already asked in 491195:
The patch uses the existing method ModifierCorrectionSubProcessor.findAnnotation.
I just made it public to keep the patch minimal, but maybe it should be moved to a better place?
Till Brychcy 2016-04-21 15:16:30 EDT
in patch set 5, i added another test to check that @java.lang.Override is added if necessary.
(btw. the test failure in patch set 4 is also on the master and is caused by the change for bug 479553)
Till Brychcy 2016-04-21 16:26:35 EDT
Finally, in patch set 6, I've added a few more tests to test the different cases when an annotation should be added or not.
Till Brychcy 2016-04-22 02:29:31 EDT
patch set 7 is just rebased because i want to see a build with +1 from hudson
Noopur Gupta 2016-04-22 02:40:19 EDT
(In reply to Till Brychcy from comment #31)
> patch set 7 is just rebased because i want to see a build with +1 from hudson

There is another test failure due to bug 492199, so you will have to wait. And Gerrit related comments should be directly added to the Gerrit change instead of the bug report.
Till Brychcy 2016-04-22 16:55:42 EDT
In patch set 9, I've moved findAnnotation to StubUtility2 as requested.
Till Brychcy 2016-04-23 05:18:17 EDT
In patch set 12, I've fixed the flacky test (JavaOptions also need to be restored at the end of each test in this infrastructure)
Noopur Gupta 2016-04-25 05:06:15 EDT
(In reply to Till Brychcy from comment #34)

Thanks for the patch. See review comments on Gerrit.
Eclipse Genie 2016-04-25 08:44:27 EDT
Gerrit change https://git.eclipse.org/r/70907 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=802be9e760c8fe1dfae679949ddf363fa94fa93c
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=444354,444354,P3,JDT,UI,kalyan_prasad,RESO,FIXE,[pull up] pull up refactoring doesn't add the required 'public' modifier,2015/9/16,compile error,1,1,-,pull up method,ast rewrite issue,"Bug 444354 - [pull up] pull up refactoring doesn't add the required 'public' modifier
Noopur Gupta 2014-09-17 08:00:03 EDT
Works fine in Eclipse 4.4.
Looks like a regression from bug 71627.

-------------------------
package p1;

import java.util.List;

public class PullUpBaz implements PullUpToInterfaceBug.Foo {

	public void b() {
		List<Object> l = null;
	}
}
-------------------------
package p1;

public class PullUpToInterfaceBug {

	interface Foo {
	}

	static class Bar implements Foo {

		/** baz it! */
		void baz(final String s) {
		}
	}
}
-------------------------

Pull up the method PullUpBaz.b() to PullUpToInterfaceBug.Foo.
The method added in PullUpToInterfaceBug.Bar doesn't have the required 'public' modifier and results in compiler error.
Noopur Gupta 2015-08-05 04:55:53 EDT
*** Bug 473656 has been marked as a duplicate of this bug. ***
Eclipse Genie 2015-08-17 03:09:19 EDT
New Gerrit change created: https://git.eclipse.org/r/53853
Eclipse Genie 2015-08-17 03:52:45 EDT
New Gerrit change created: https://git.eclipse.org/r/53855
Noopur Gupta 2015-08-17 09:42:31 EDT
(In reply to Eclipse Genie from comment #2)
> New Gerrit change created: https://git.eclipse.org/r/53853

Change looks fine. See Gerrit for comments.
Eclipse Genie 2015-08-18 07:30:56 EDT
Gerrit change https://git.eclipse.org/r/53853 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=43269564691d3f443f31cf0d1eb9c1cbac8e9f8d
Noopur Gupta 2015-08-18 07:34:54 EDT
(In reply to Eclipse Genie from comment #5)
> Gerrit change https://git.eclipse.org/r/53853 was merged to [master].
> Commit:
> http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/
> ?id=43269564691d3f443f31cf0d1eb9c1cbac8e9f8d

Released in master.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=41468,41468,P3,JDT,UI,markus.kell.r,RESO,FIXE,move instance method: method parameter lost [refactoring],2015/2/10,compile error,1,1,-,move method,ast rewrite issue,"Bug 41468 - move instance method: method parameter lost [refactoring]
Adam Kiezun 2003-08-13 06:50:52 EDT
20030806+0812export
A.java
package p;
public class A {
	Second s;
	public void print() {
		s.foo(s);
		s.bar();
		
	}
}

Second.java
package p;
class Second {
	public void foo(Second s) {
		s.bar();
	}

	public void bar() {
	}
}

move print from A to Second - the code does not compile after that because
the call to foo looses an argument
Dirk Baeumer 2003-08-13 09:03:13 EDT
Markus, please have a look.
Markus Keller 2003-08-14 11:32:13 EDT
Created attachment 5766 [details]
Fix

Method arguments were not copied when the new receiver became the implicit
""this"". Corrected.
Markus Keller 2003-08-14 11:32:32 EDT
Created attachment 5767 [details]
Tests.
Markus Keller 2003-08-15 05:38:04 EDT
Patches for bug 41597 include patches for this bug.
Adam Kiezun 2003-08-15 10:18:05 EDT
released
thanks
Adam Kiezun 2003-08-21 10:24:34 EDT
*** Bug 40713 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=430267,430267,P3,JDT,UI,noopur_gupta,RESO,FIXE,[refactoring][extract method] Extract Method misses parameter used in try-with-resources statement,2014/12/4,compile error,1,1,try-with-resource,extract method,flow analysis issue,"Bug 430267 - [refactoring][extract method] Extract Method misses parameter used in try-with-resources statement
Mirko Stocker 2014-03-13 06:24:33 EDT
Given the following code:

static String readFirstLineFromFile(String path) throws IOException {
	try (BufferedReader br = new BufferedReader(new FileReader(path))) {
		return br.readLine();
	}
}

When using Extract Method on the body of the method, the required parameter ""path"" is not passed to the extracted method:


static String readFirstLineFromFile(String path) throws IOException {
	return readLine();
}

private static String readLine() throws IOException, FileNotFoundException {
	try (BufferedReader br = new BufferedReader(new FileReader(path))) {
		return br.readLine();
	}
}
Simon Archer 2014-12-03 22:12:45 EST
+1 for this bug report... I seem to be hitting it on a daily basis. Please can this important bug be addressed soon. Thanks.
Noopur Gupta 2014-12-04 06:52:58 EST
Created attachment 249165 [details]
Patch

Attached the fix and test. All existing tests are green with the fix.
Markus, please review.
Markus Keller 2014-12-04 12:19:33 EST
Hmm, did you realize that all your changes put the processing of the ""resources"" property *after* the processing of the ""body"" property, although the ""resources"" precede ""body"" in the AST as well as in the order of execution?

When I fixed the order, the new ExtractMethodTests17#test8() failed again. That's because TryFlowInfo#mergeTry(FlowInfo, FlowContext) just calls

	assign(info);

and thereby drops the flow info of preceding resource nodes. When I called

	mergeSequential(info, context);

instead, then all tests were green again.

Unfortunately, I couldn't come up with a code snippet for which the proper processing order actually matters. But for the sake of clarity, I committed the correct order: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=2ec9b22523223bf401d505a2b640b76ece079822
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=408966,408966,P3,JDT,UI,noopur_gupta,RESO,FIXE,[1.8][inline] Invalid inline constant and inline temp refactorings using lambda expressions,2014/6/15,exception,1,1,lambda,inline constant,Incorrect Type Resolving,"Bug 408966 - [1.8][inline] Invalid inline constant and inline temp refactorings using lambda expressions
Noopur Gupta 2013-05-24 08:01:26 EDT
Consider the following example and perform Refactor > Inline as per the comments:

@FunctionalInterface
interface I1 {
	int foo(int x);	
}

public class X {
	public static final I1 a= (int x) -> x;
	
	void fun1() {
		int n = a.foo(0); // [1] Inline ""a"" => AFE	
		
		I1 i= (int x) -> { return x; }; // [2] Inline ""i""
		I1 i1= x -> i.foo(x); // => Invalid inlining of ""i""
		fun2(i); // => Valid inlining of ""i""
	}
	
	void fun2(I1 i) {}
}

[1] => 
java.lang.reflect.InvocationTargetException
...
Caused by: org.eclipse.core.runtime.AssertionFailedException: assertion failed: 
	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:110)
	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:96)
	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.setFragment(ASTFragmentFactory.java:194)
	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.visit(ASTFragmentFactory.java:133)
	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:547)
	at org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.visit(HierarchicalASTVisitor.java:566)
	at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:149)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2718)
	at org.eclipse.jdt.core.dom.LambdaExpression.accept0(LambdaExpression.java:215)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2670)
	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentFactory.createFragment(ASTFragmentFactory.java:186)
	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory$FragmentForFullSubtreeFactory.createFragmentFor(ASTFragmentFactory.java:115)
	at org.eclipse.jdt.internal.corext.dom.fragments.ASTFragmentFactory.createFragmentForFullSubtree(ASTFragmentFactory.java:56)
	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitializer(InlineConstantRefactoring.java:789)
	at org.eclipse.jdt.internal.corext.refactoring.code.InlineConstantRefactoring.checkInitialConditions(InlineConstantRefactoring.java:736)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
...


[2] => Results in:
I1 i1= x -> (int x) -> { return x; }.foo(x); // => Invalid inlining of ""i""
fun2((int x) -> { return x; }); // => Valid inlining of ""i""
Noopur Gupta 2013-11-20 08:43:42 EST
When we have a lambda reference being used as the expression in a method invocation, we cannot inline the lambda as shown in cases [1] and [2]'s invalid inlining in comment #0.

In cases like [1], the inline refactoring can be disabled.
In cases like [2], where some occurrences are valid and some are not, we cannot remove the lambda declaration as invalid occurrences cannot be inlined. Should we inline only the valid locations and keep the lambda declaration also for other occurrences or should the inline refactoring be disabled here?
Markus Keller 2013-11-20 14:46:30 EST
> Should we inline only the valid locations and keep the lambda
> declaration also for other occurrences [..]?

Let's do the same as Inline Method (bug 83041):
- show a (non-fatal) error message for each invalid location and then don't inline
- keep the declaration if these was an invalid location
Markus Keller 2013-11-26 14:38:15 EST
The categorization of places where a lambda or a method reference can be inlined and where not looks like a generally useful property of an ASTNode location.

The general question is: Can the StructuralPropertyDescriptor for the target location hold a poly expression? This will probably also be useful for other refactorings, so please make this functionality reusable (e.g. in ASTNodes).

For cases where inlining is possible (i.e., the target accepts a poly expression), we also need to think about inadvertent semantic shifts because the type inference could resolve to different types at the new location. Maybe we need something similar to MethodInvocation#isResolvedTypeInferredFromExpectedType() from JDT Core?

See also the call hierarchy of Invocations#isResolvedTypeInferredFromExpectedType(Expression). I expect the fix for this bug to be applicable in similar situations, so this is probably an opportunity to share even more code.
Noopur Gupta 2013-11-28 08:56:35 EST
-------------------------------------------------------------
package test.inline.lambda.constant;

@FunctionalInterface
interface FI {
	int foo(int x);
}

@FunctionalInterface
interface F {
	FI foo();
}

class C1 {
	public static final FI fi = x -> x++;	// inline all references of 'fi' and delete it.
	
	static {
		FI fi1 = fi;	// [1]
		
		FI fi2;
		fi2 = fi;		// [2]		
	}
	
	private FI fun1() {
		return fi;		// [3]
	}
	
	FI[] fis = new FI[] {fi, fi}; // [4]
	
	
	int x1 = fun2(fi);	// [5a]
	
	C1 c1 = new C1(fi);	// [5b]
	
	private int fun2(FI fi) {return 0;}
	public C1(FI fi) {}

	FI fi3 = fun3();

	private FI fun3() {
		F f = () -> fi;	// [6]
		return f.foo();
	}

	private void fun4() {
		boolean flag = true;
		FI fi4 = flag ? fi : fi; // [7]
	}
	
	
	private Object fun5() {
		Object o = fi; // [8a]
		
		Object fi2;
		fi2 = fi; // [8b]
		
		Object[] fis = new Object[] {fi, fi}; // [8c]
		
		System.out.println(fi);  // [8d]

		Object fi4 = true ? fi : fi; // [8e]
		
		int x2 = fi.foo(10); // [8f]
				
		return fi;	// [8g]
	}
        
        // etc.
}
-------------------------------------------------------------

The above example shows some cases where a lambda constant can be inlined.

In cases [1] to [7], it can be inlined directly.
In cases [8*], lambda will need a type cast to the functional interface type while inlining.

Examples are based on http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html, section 5: Contexts for target typing.
Noopur Gupta 2013-11-28 09:14:33 EST
(In reply to Markus Keller from comment #3)
> The categorization of places where a lambda or a method reference can be
> inlined and where not looks like a generally useful property of an ASTNode
> location.
> 
> The general question is: Can the StructuralPropertyDescriptor for the target
> location hold a poly expression? This will probably also be useful for other
> refactorings, so please make this functionality reusable (e.g. in ASTNodes).

Does it mean that we need to know if the StructuralPropertyDescriptor of the target location defines a target type, as poly expressions cannot be typed in the absence of a target type?
http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html, section 5: Contexts for target typing : lists the contexts that have target types. Would that be helpful?

If the target location's StructuralPropertyDescriptor accepts a poly expression ( i.e. defines a target type) then we need to know what is the defined target type.

And, if the defined target type matches the type of the lambda expr being inlined, it can be inlined directly.
Otherwise, we could cast the lambda expr to its functional interface type, as the target was already having the functional interface reference at that location before inling.

> For cases where inlining is possible (i.e., the target accepts a poly
> expression), we also need to think about inadvertent semantic shifts because
> the type inference could resolve to different types at the new location.
> Maybe we need something similar to
> MethodInvocation#isResolvedTypeInferredFromExpectedType() from JDT Core?

Can you give an example?

> See also the call hierarchy of
> Invocations#isResolvedTypeInferredFromExpectedType(Expression). I expect the
> fix for this bug to be applicable in similar situations, so this is probably
> an opportunity to share even more code.
Markus Keller 2013-11-28 10:10:09 EST
> http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html,
> section 5: Contexts for target typing : lists the contexts that have target
> types. Would that be helpful?

Yes, that section is helpful to understand the problem, but the implementation should be based on the spec: http://cr.openjdk.java.net/~dlsmith/jsr335-0.7.0.html#E

> > For cases where inlining is possible (i.e., the target accepts a poly
> > expression), we also need to think about inadvertent semantic shifts because
> > the type inference could resolve to different types at the new location.
> > Maybe we need something similar to
> > MethodInvocation#isResolvedTypeInferredFromExpectedType() from JDT Core?
> 
> Can you give an example?

@FunctionalInterface
interface FI {
    int foo(int x);
}
@FunctionalInterface
interface FL {
    long foo(long x);
}

class C2 {
    public static final FI fi = x -> x++; // inline 'fi'
    public static final FL fl = x -> x++;

    {
        bar(fi); // can't inline fi without explicit cast to FI
        bar(fl); // can't inline fl without explicit cast to FL
    }
    void bar(FI fi) { }
    void bar(FL fl) { }
}
Noopur Gupta 2013-12-31 01:56:31 EST
Created attachment 238615 [details]
Fix

Attaching a patch for the fix based on the common code given in bug 423439 comment #6.
Noopur Gupta 2013-12-31 02:34:19 EST
Created attachment 238616 [details]
Tests

Attaching the patch for the following commit from mmathew/BETA_JAVA8 branch:

http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?h=mmathew/BETA_JAVA8&id=262e59c07ad895ff0657dd9c9a42c9b541c1a5ac
Markus Keller 2014-04-27 18:44:41 EDT
There are a few more cases, where we need to insert a cast:

@FunctionalInterface
interface I1 {
    int foo(int x); 
    int CONST= 12;
}

public class FI {
    void fun1() {
        I1 i= (int x) -> { return x; }; // [3] Inline ""i""
        int c = i.CONST;
        IntFunction<Integer> f= i::foo;
        synchronized (i) { }
    }
}

I think we can avoid adding more cases to ASTNodes#getExplicitCast(..) if we just add a cast when getTargetType(reference) returns null. These are exactly the those cases where the target type is not defined and hence needs to be supplied by a cast.

Fixed InlineConstantTests18#test1003()/test3()/test4() to make them interesting again after bug 423439 comment 14: FX#foo() now also returns int.

Committed fix & tests with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=7a1839ac4f876d3ebafe5fef49d315db2ab6f6f9
Noopur Gupta 2014-06-15 08:08:22 EDT
*** Bug 437442 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=24941,24941,P3,JDT,UI,dirk_baeumer,RESO,FIXE,inline method - doesn't handle implicit cast [refactoring],2014/4/25,behavior change,1,1,-,inline method,Incorrect Type Resolving,"Bug 24941 - inline method - doesn't handle implicit cast [refactoring]
Claude Knaus 2002-10-17 08:20:36 EDT
I-20021016 linux-gtk:

public class Woo {
  static void goo(char c) {
    System.out.println(""char"");
  }
  static void goo(int i) {
    System.out.println(""i"");
  }
  static int foo() {
    return 'a';
  }
  public static void main(String[] args) {
    goo(foo());
  }
}

1. execute the class
2. observe the output is ""int""
3. inline method foo
4. execute the class
5. observe the output is ""char""

characters are implicitely cast to int on return. When the method is inlined,
the implicit cast must be made explicit. If there's no ambiguity the cast could 
be omitted.

The fix should handle all kind of possible implicit conversions.

There's a similar case:

public class Zoo {
  static int foo() {
    return 'A';
  }
  public static void main(String[] args) {
    System.out.println(""output: "" + foo());
  }
}

Before inlining, the output is '65', after inlining, it's 'A'.

In the past I often got bitten by implicit conversions of characters to int, 
which is hard to debug.
Dmitry Stalnov 2003-06-14 12:58:39 EDT
Created attachment 5197 [details]
Patch fixing the bug

The patch fixes the problem described in the bug report but there is one issue.
If access to overloaded function is restricted then no explicit cast is really
needed, in this case I still think it is safer to have cast in place.

Example:

public class Fruit {
}
public class Apple extends Fruit {
}
public class Woo {
	public static Fruit foo() {
		return new Apple();
	}
	private static void goo(Apple apple) {
	}
	public static void goo(Fruit fruit) {
	}
}
public class Test {
	public static void main(String[] args) {
		Woo.goo(Woo.foo());
	}
}

Woo.foo() will be inlined as (Fruit)new Apple() though goo(Apple apple) is
private in class Woo.
Dmitry Stalnov 2003-06-19 08:59:35 EDT
Created attachment 5243 [details]
final patch fixing the bug

Previous version of the patch created unneeded explicit casts. This one doesn't
have such problems.
Dmitry Stalnov 2003-06-19 09:04:27 EDT
Created attachment 5244 [details]
unit tests for the submitted patch

Eclipse 'Create Patch' command didn't include resources in generated patch.
Probably, because I put them into separate folder.
Dmitry Stalnov 2003-06-19 09:05:16 EDT
Created attachment 5245 [details]
Resources for unit tests
Dirk Baeumer 2003-06-19 12:22:41 EDT
I will look at the patch (very likely not before beginning of next week).
Dirk Baeumer 2003-06-24 10:28:59 EDT
Dmitry,

nice work ! I released the patch after applying the following changes.

- adapted code to JDT/UI guidelines (f prefix for fields and asymmetric
  assignment)
- moved resolveInvokedType to ASTNodes and renamed it to
  getReceiverTypeBinding since it is a general useful method.
- moved code from ASTResolving to new class TypeRules to avoid layer breakers.
- shortened needsExplicitCast() a little bit since fInvocation == arguments(i)
  for 0 < i < number of arguments. No need to loop over it and to compare
  start offsets.

Besides these changes I think the findMethodsInHierarchy method should 
consider interfaces as well. Currently it only considers super classes. 
Additionally it is sufficient to collect all methods with the same number of 
parameters. Method foo(Woo) doesn't overload method foo(Woo, int). Furthermore 
the method canImplicitlyCall can be optimized. Since we only replace one 
argument it is sufficient to check this one. Are you interested in 
implementing these changes/optimizations.
Dirk Baeumer 2003-06-24 10:35:51 EDT
And a question: what is the purpose of

// fixes bug #35905
if(expression instanceof CastExpression) {
	realArguments[i] = ""("" + realArguments[i] + "")"";
}
Dmitry Stalnov 2003-06-25 10:39:13 EDT
Dirk, thank you for the review!

I thought about moving resolveInvokedType method to Bindings class and haven't 
done that only because wanted to limit my changes to as less number of files as 
possible. If you think ASTNodes serves that purpose better then I agree.

Method findMethodsInHierarchy was designed to be more generic than was required 
for this fix and again that was done to simplify movement of the method into 
Bindings afterwards. Now, taking into account your comments, I think that 
following set of methods can be added to ASTNodes class:
  - findMethodsInHierarchy(ITypeBinding type, String methodName) - it will 
return all methods with specified name, considering interfaces too
  - findMethodsInHierarchy(ITypeBinding type, String methodName, int 
numberOfArguments) - the same as previous but methods are additionally filtered 
with number of arguments
  - findMethodsInSuperclasses(ITypeBinding type, String methodName) - this one 
is equal to current implementation of findMethodsInHierarchy.
  - findMethodsInSuperclasses(ITypeBinding type, String methodName, int 
numberOfArguments) - the patch must be modified to use this method.
If you approve this change I will implement it.

Regarding comment #7. The change got into the patch accidentially and was 
inteded to fix bug #35905.

I'm definitely interested in further work on this bug.
Dirk Baeumer 2003-06-25 12:47:28 EDT
I think we should start with one findMethodInHierarchy. It should take the 
type, the method name and the number of parameters. If we need another method 
we can add it later.

Have you thought about optimizing ""canImplicitlyCall"" as well ?

As said, I have released your fix to the HEAD so it is part of todays 
integration build.

So I am expecting another patch from you ;-)).
Dmitry Stalnov 2003-06-25 17:52:07 EDT
I don't see a possibility how ""canImplicitlyCall"" can be optimized. Consider 
following code:

class Base {}
class Derived extends Base {}
class Woo {
  static void goo(String s, Base b) {
    System.out.println(""String"");
  }
  static void goo(Integer i, Derived d) {
    System.out.println(""Integer"");
  }
  static Base foo() {
    return new Derived();
  }
  public static void main(String[] args) {
    goo(""String"", foo());
  }
}
If only second parameters of foo() methods are taken into account then it 
looks like explicit cast is needed, but it is not since the first parameter 
defines which overloaded method will be invoked.

Actually, above example helped me to discover another case when the fix 
doesn't work. Here it is:

class Woo {
  static void goo(String s) {
    System.out.println(""String"");
  }
  static void goo(Integer i) {
    System.out.println(""Integer"");
  }
  static Integer foo() {
    return null;
  }
  public static void main(String[] args) {
    goo(foo());
  }
}
Inlining foo() will break the code. Method TypeRules.canAssign doesn't process 
null types correctly. I will fix it along with the ""findMethodInHierarchy"" 
change.
Dmitry Stalnov 2003-06-26 03:45:49 EDT
Created attachment 5298 [details]
Code restructuring, fixed null types problem

I moved findMethodsInSuperclasses to Bindings because it takes ITypeBinding as
first parameter and ASTNodes class manipulates with AST nodes only.

Fixed the null types problem described in comment #10.

I'm not sure that additional check is neccessary in the following code:
  int argumentIndex= methodInvocation.arguments().indexOf(fInvocation);
  if (argumentIndex == -1)
    return false; // will never be executed
Since the compilation unit is compiled without errors, state of bindings is
up-to-date and consistent then argumentIndex will never be -1. Am I wrong?

When will the status of the bug change to FIXED ? :)
Dmitry Stalnov 2003-06-26 03:47:03 EDT
Created attachment 5299 [details]
Unit test for patch #5298
Dirk Baeumer 2003-06-27 10:57:10 EDT
Looking at your comment #10 I get the feeling that findMethodInHierarchy 
should be coded in the following way:

IMethod[] findMethodInHierarchy(ITypeBinding type, String methodName, 
ITypeBinding parameters[])

if (parameters[i] == null) then the parameter is ignored during method 
comparison.

This will find all methods that cause a potential conflict. So instead of 
opimizing canImplicitlyCall we should optimize findMethodInHierarchy.

What do you think ?

Regarding the two questions:

  if (argumentIndex == -1)
    return false; // will never be executed

is not needed. You are correct.

When will the bug be closed: we close the bug when all issues enumerated in 
this bug are solved. IMO we are 95% done. Only little tweaking here and there 
<g>.
Dmitry Stalnov 2003-06-30 08:41:17 EDT
Created attachment 5315 [details]
Generalized Bindings.findMethodsInSuperclasses

I generalized method Bindings.findMethodsInSuperclasses as you suggested. The
change added one more loop traversing method arguments (see
Bindings.isEqualMethod) and array allocation when calling to
Bindings.findMethodsInSuperclasses from CallInliner. This can decrease
performance a little.

I also removed ""if (argumentIndex == -1)"" check and added another one
""if(methodInvocation.getExpression() == fTargetNode)"" because target node can
be a receiver expression in the method invocation (see TestParenthesis unit
test).

Unit test for the patch is attached to comment #12.
Dmitry Stalnov 2003-07-01 09:04:06 EDT
Created attachment 5324 [details]
Considered interfaces, created binding predicate

  Dirk, 

Sorry for the 'spam' but there is no limit to code improvements :)

First of all, I realized that interfaces should be considered too. Following
code demonstrates why it is so:

class Base {}
class Derived extends Base {}
interface I {
	public void foo(Derived d);
}
abstract class Goo implements I {
	public void foo(Base b) {
	}
}
class Woo extends Goo {
	public void foo(Derived d) {
	}
}
class Test {
	Base inlineMe() {
		return new Derived();
	}
	void main() {
		Goo goo = new Woo();
		goo.foo(inlineMe());
	}
}

Actually, we don't need to traverse all superclasses and interfaces searching
for ALL methods with the specified name and number of parameters. What we
really want is to find ONE(any) method that after inlining can be confused with
original invocation. That would save us many loop iterations and probably call
to type.getInterfaces(). I also noticed that there is many
Bindings.findMethod...s in Bindings class and the number tends to grow. That
can make it difficult to find an appropriate method, especially for newbies
like me :)

Considering above ideas I decided to employ predicate pattern. I created new
BindingPredicate interface and added several searching routines based on the
predicates to Bindings class. Method CallInliner.needsExlplicitCast was
simplified and canImplicitlyCall moved to new AmbiguousMethodPredicate class.

What do you think? Is it 100% now? ;)
Dirk Baeumer 2003-07-01 13:16:00 EDT
Will look into it tomorrow morning.
Dirk Baeumer 2003-07-02 10:10:06 EDT
Dmitry,

I looked at the code and functional wise I think we are done. However I don't 
like the additional methods on Bindings since I am not sure if they are really 
useful (for example we can't remove the existing find* method or even make 
them wrappers around the new methods).

From looking at your new code I get the feeling that we are missing a type 
hierarchy visitor. The the different find methods would be different visitors 
and the Bindings class would only contain code to visit the hierarchy.

What do you think about this ?
Dmitry Stalnov 2003-07-07 16:38:09 EDT
Created attachment 5370 [details]
Replaced binding predicate with visitor

I modified the patch and replaced predicate with visitor as you suggested. The
new BindingVisitor is very simple but in the future it can be extended to the
scale of ASTVisitor if needed.

Take a look and let me know if it is what you meant.
Dirk Baeumer 2003-07-14 11:58:24 EDT
Released path with two little changes:

- renamed BindingVisitor to TypeBindingVisitor
- made AmbiguousMethodAnalyzer an inner class of CallInliner (we don't use 
  secondary top level types in Eclipse).

Thanks for your contribution !!
Markus Keller 2014-04-25 09:55:46 EDT
Bindings.visitInterfaces(ITypeBinding, TypeBindingVisitor) didn't visit superinterfaces of interfaces recursively.

Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=7edc5f69024dacad9e60d721905913043dc5a57f
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=426963,426963,P3,JDT,UI,manju656,RESO,FIXE,[pull up] Import declaration for the type use annotation is missing after pull up refactoring,2014/4/9,compile error,0,1,nan,pull up method,nan,"Bug 426963 - [pull up] Import declaration for the type use annotation is missing after pull up refactoring
Martin Mathew 2014-01-30 01:32:21 EST
Consider the code snippet:
import org.eclipse.jdt.annotation.NonNull;
public class Square implements Shape {

	public Integer getArea(@NonNull Integer length) {
		return new Integer(length * length);
	}
}

Refactor ""Pull Up"" the method to ""Shape"", the resulting file does not contain the import declaration for @NonNull and hence the user ends up with compilation errors.
Martin Mathew 2014-02-06 23:11:55 EST
Created attachment 239720 [details]
Patch + Tests

The fix was to pass the old method declaration to the ImportRewriteUtil#addImports() in PullUpRefactoringProcessor as the new method declaration will not contain the type annotation yet at that particular point.
Martin Mathew 2014-02-24 18:23:10 EST
Note: Check bug 396524 before closing this bug.
Martin Mathew 2014-04-09 23:20:12 EDT
The issue was not particular to Java 8. Released the fix with:
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=ad0af002d891b21af6600ff540accabffbc82f68
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=305182,305182,P3,JDT,Debug,sarika.sinha,VERI,FIXE,[breakpoints] Refactoring a method/field with associated breakpoint changes working set,2014/4/3,breakpoint,1,1,nan,Change Method Signature,ast rewrite issue,"Bug 305182 - [breakpoints] Refactoring a method/field with associated breakpoint changes working set
Darin Wright 2010-03-09 11:26:17 EST
Using I20100309-0100

* Create breakpoint working sets A and B
* Make working set A default
* Create a method entry breakpoint (appears in A)
* Make working set B default
* refactor the method name where the breakpoint is
* The breakpoint will move to working set B after being refactored

If there is no default working set, it will move to the ""Other"" category. Looks like the newly created breakpoint gets the current ""defaut working set"" applied to it rather than retaining its original working set. Same happens for refactored watch points.
Sarika Sinha 2014-02-25 04:25:09 EST
Created attachment 240290 [details]
Preserving the working set

This patch preserves  the Working set for the new breakpoint created after method/watchpoint  refactor. Refactoring causes the deletion of original breakpoint and creation of new breakpoint with original attributes.
Michael Rennie 2014-02-25 08:34:19 EST
The patch works great for method entry/exit and watchpoints, but does not work for class load breakpoints:

1. create two working sets A and B - set A as the default
2. using the following snippet set breakpoints where indicated:

public class Clazz { //class load
	
	int field = 10; //watchpoint
	
	void method() {} //method breakpoint
}

3. set all the breakpoints in working set B (non-default)
4. rename Clazz to Clazz2 - notice that *all* breapoints are moved to the default working set.
Sarika Sinha 2014-02-26 05:06:24 EST
Created attachment 240322 [details]
Preserving the working set at BreakpointChange level

This patch preserves the working set for Line, Field, Method and Class breakpoints during refactor. Original Working set is stored at Breakpoint change level as Class refactor can knock off the original marker attributes.
Michael Rennie 2014-02-26 11:26:38 EST
Works perfectly now.

Pushed to: http://git.eclipse.org/c/jdt/eclipse.jdt.debug.git/commit/?id=0bfc63099d16d40e4ca4fcb5a1e013da07febc8b

Thanks Sarika.
Sarika Sinha 2014-03-04 02:49:14 EST
Verified with 
Version: Luna (4.4)
Build id: I20140303-2000
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=429498,429498,P3,JDT,UI,manju656,RESO,FIXE,[1.8][refactoring] Change Method Signature refactoring breaks lambda,2014/3/16,compile error,1,1,lambda,Change Method Signature,ast rewrite issue,"Bug 429498 - [1.8][refactoring] Change Method Signature refactoring breaks lambda
Srikanth Sankaran 2014-03-03 14:17:05 EST
interface I {
    public void doit();
}

public class X {
	I i = () -> {};
}


Change I.doit()'s signature - the lambda does not compile anymore.

Now that declarations in hierarchy correctly tags the lambda as implementing
I.doit, expectation is that this should work.
Srikanth Sankaran 2014-03-03 14:20:20 EST
At the moment the JavaElement for LambdaExpression's answers true to isReadOnly.
This does not seem to have a brearing though.
Martin Mathew 2014-03-03 21:47:10 EST
@Srikanth: Can you elaborate the steps you performed after which you ended up with a broken lambda?
When i tested, Java Model Exception is thrown when the 'OK' button is clicked after adding a method parameter in I#doit() using Alt+Shift+C:

Java Model Exception: Java Model Status [lambda$1() [in <lambda> [in i [in X [in [Working copy] X.java [in p5 [in src [in com.test.hover.lambda]]]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:499)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:533)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:259)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:245)
	at org.eclipse.jdt.internal.core.SourceMethod.getParameterNames(SourceMethod.java:118)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureProcessor.checkParameterNamesInRippleMethods(ChangeSignatureProcessor.java:1140)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureProcessor.checkRenamings(ChangeSignatureProcessor.java:1130)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureProcessor.checkFinalConditions(ChangeSignatureProcessor.java:855)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2333)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
Martin Mathew 2014-03-03 21:58:49 EST
When we rename(Atl+Shift+R) the method I.doit() also we get a fatal error:
Related method 'lambda$1' (declared in 'p5.X.<lambda>') does not exist in the model.
Srikanth Sankaran 2014-03-04 00:16:08 EST
(In reply to Manju Mathew from comment #3)
> When we rename(Atl+Shift+R) the method I.doit() also we get a fatal error:
> Related method 'lambda$1' (declared in 'p5.X.<lambda>') does not exist in
> the model.

Manju, please test with HEAD.
Martin Mathew 2014-03-04 00:34:19 EST
After pulling the latest from HEAD, confirming that the lambda is broken after the Change Method Signature(Alt+Shift+C) refactoring modifies (Add/Edit/Remove) method parameter. The rename refactoring (Alt+Shift+R) completes normally. There is no exception from model as stated earlier.
Martin Mathew 2014-03-11 21:48:12 EDT
Here is what i found after analysis:
package p1;

interface I {
    public void doit(); // Invoke Alt+Shift+C here and add 'int i' as the method parameter
}

public class X {
	I i = () -> {};
	
	I i2= new I() {
		
		@Override
		public void doit() {
			
		}
	};
}

During Change Method Signature refactoring, RefactoringSearchEngine#internalSearch invoke SearchEngine#search with  SearchPattern:
""MethodCombinedPattern: p1.I.doit() --> void, exact match, case sensitive, generic erasure match, fine grain: none
| MethodCombinedPattern: p1.X.*.Lambda(I).doit() --> void, exact match, case sensitive, generic erasure match, fine grain: none
| MethodCombinedPattern: p1.X.*..doit() --> void, exact match, case sensitive, generic erasure match, fine grain: none""
Lambda is part of the search pattern, but the search does not return lambda as part of the result and hence lambda is not updated after the refactoring. 

@Srikanth: Is there any problem with the SeachPattern that UI is sending to the core?
Srikanth Sankaran 2014-03-12 03:39:10 EDT
(In reply to Manju Mathew from comment #6)

> During Change Method Signature refactoring,
> RefactoringSearchEngine#internalSearch invoke SearchEngine#search with 
> SearchPattern:
> ""MethodCombinedPattern: p1.I.doit() --> void, exact match, case sensitive,
> generic erasure match, fine grain: none
> | MethodCombinedPattern: p1.X.*.Lambda(I).doit() --> void, exact match, case
> sensitive, generic erasure match, fine grain: none
> | MethodCombinedPattern: p1.X.*..doit() --> void, exact match, case
> sensitive, generic erasure match, fine grain: none""
> Lambda is part of the search pattern, but the search does not return lambda
> as part of the result and hence lambda is not updated after the refactoring. 
> 
> @Srikanth: Is there any problem with the SeachPattern that UI is sending to
> the core?

Well, Lambda(I) is a made up name and won't match any index entries. I'll see
what can be done.
Srikanth Sankaran 2014-03-12 06:49:18 EDT
Folks, this would be nice to show case in ECNA. Appreciate your enabling it
if possible. This is blocked by a Core bug for which early patch is posted
in bug 430159.

With that patch search engine returns the lambda nodes as results, but there
is a subsequent exception inside UI code from:

org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureProcessor.NullOccurrenceUpdate.updateNode()
Martin Mathew 2014-03-13 03:39:30 EDT
Created attachment 240839 [details]
WIP Patch

@Markus, can you have a look at it and let me know if i am in the right direction.
Below are assumptions taken while working on this bug:
1. Ignored method name change for LambdaExpression.
2. Ignored the visibility change(method visibility being changed from private to public etc) possibility as LambdaExpression can come from an interface method which is always public.
3. Ignored Exception change as LambdaExpression do not store this information.
4. This fix is not complete without releasing the fix for bug 408979.
5. Currently when Change Method Signature refactoring is invoked directly on the lambda, due to bug 429814 the LambdaMethod is not found, but the parent SAM from the interface, which is wrong.
6. In the case of ExpressionMethodReference, only the method name change will be considered.

Tomorrow i will work on the remaining issues and code polishing.
Markus Keller 2014-03-13 08:21:16 EDT
(In reply to Manju Mathew from comment #9)
The general direction looks good. Comments:

- #createChangeManager: why ""|| update instanceof ExpressionMethodRefUpdate""?

- Looks like LambdaExpressionUpdate copies a lot of code from DeclarationUpdate. Try to reduce copied code. Maybe add an
""AbstractDeclarationUpdate<N extends VariableDeclaration> extends OccurrenceUpdate<N>"", and make DeclarationUpdate and LambdaExpressionUpdate extend that one?

- Make sure you have test cases for lambda expressions with and without parameters, and with and without explicit parameter types.
Srikanth Sankaran 2014-03-13 08:35:39 EDT
(In reply to Markus Keller from comment #10)

> - Make sure you have test cases for lambda expressions with and without
> parameters, and with and without explicit parameter types.

and with and without parentheses around parameters.
Markus Keller 2014-03-13 16:13:32 EDT
(In reply to Manju Mathew from comment #9)
> 4. This fix is not complete without releasing the fix for bug 408979.
Done.

> 5. Currently when Change Method Signature refactoring is invoked directly on
> the lambda, due to bug 429814 the LambdaMethod is not found, but the parent
> SAM from the interface, which is wrong.

That's no big deal. ChangeSignatureProcessor#checkInitialConditions(..) should anyway check this and make RefactoringExecutionStarter#startChangeSignatureRefactoring(..) ask the user whether it's OK to start the refactoring on the top method.
Martin Mathew 2014-03-14 05:23:55 EDT
Created attachment 240895 [details]
Patch + Tests

Markus, as you had suggested, i have created an abstract class to handle LambdaExpression and MethodDeclaration.

1. When change method declaration is invoked directly on lambda, currently we do not get SAM(as i claimed earlier), but the enclosing method where the lambda is declared. Bug 429785 should solve this issue.
2. When a parameter is deleted which is used in a lambda expression, the message shown needs better wording.
3. Tests are added for lambda expressions with and without parameters, and with and without explicit parameter types. Also with and without parentheses around parameters.
4. Tests are incomplete, need to add more test case for removing parameters and some more cases.
Markus Keller 2014-03-16 17:46:43 EDT
New test suites need to be added to a test suite that is included from test.xml. Added ChangeSignatureTests18 to AllRefactoringTests.

Test resources should use the same casing as their test method. I'm pretty sure A_testlambda0_in.java for testLambda0() would not be found on case-sensitive file systems. Renamed the resources.

class AbstractDeclarationUpdate<N extends VariableDeclaration> should extend OccurrenceUpdate<N> and class DeclarationUpdate should extend AbstractDeclarationUpdate<SingleVariableDeclaration>. This may not be absolutely necessary right now, but it will become necessary when the ASTRewrite API is generified. And it's the right thing to do anyway. And it helps avoid the strange things you did to DeclarationUpdate#createNewParamgument(..).

I didn'd find a caller of LambdaExpressionUpdate#getMethodName() => removed it. But AbstractDeclarationUpdate#checkIfDeletedParametersUsed() now wrongly referred to ChangeSignatureProcessor#getMethodName(). Fixed to use ""getMethod().getElementName()"".

Reverted some other unnecessary edits and reverted order of methods, so that I could easily see the actual changes.

Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=7683edb224866dae4aae1d071fdfbb035f7bbdd6
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=406786,406786,P3,JDT,UI,noopur_gupta,VERI,FIXE,[1.8][extract method] Extract Method refactoring in interfaces not handled,2014/2/23,exception,1,1,lambda,extract Method,overly strong preconditions,"Bug 406786 - [1.8][extract method] Extract Method refactoring in interfaces not handled
Noopur Gupta 2013-04-29 07:44:40 EDT
Consider the following interfaces: I2 (having lambda expression) and I3 (having default and static methods). 
Perform ""Extract Method"" refactoring on the lines with comments. We get exception and no refactoring is performed.
It should be possible to extract methods in interfaces which would be created as default or static methods in those interfaces.

@FunctionalInterface
public interface I1 {
	int foo(int a);
}

interface I2 {
	I1 i1= (a) -> {
		int b= 10; // Exception on extracting to method
		return a + b;
	};
}

interface I3 {
	default int foo () {
		int a= 10; // Exception on extracting to method
		return a;
	}
	
	static int bar() {
		int a= 10; // Exception on extracting to method
		return a;
	}
}
Noopur Gupta 2013-06-25 13:28:22 EDT
*** Bug 411608 has been marked as a duplicate of this bug. ***
Noopur Gupta 2013-07-11 06:40:51 EDT
If the method is being extracted from a default method, then the extracted method will be default; otherwise it will be static.
 
Some open points regarding the expected behavior:
 
1. Access Modifier radio buttons:
If Destination type while opening the wizard is an interface, should 'public' be selected by default with all radio buttons disabled, or should we hide the access modifier composite itself?
And, when user changes the Destination type from an interface to non-interface and vice-versa, the composite would need to be updated accordingly.
 
2. When the expr being extracted from a default method, is also present in a static method and ""Replace additional occurrences..."" is checked, we get compilation error after refactoring since the new default method cannot be accessed from the static method. 
The same issue already happens in a class also.
 
3. Currently if we try to extract a method from a field initialization expr in an interface for source level < 1.8, we get NPE.
We can add a check and show error message ""Cannot extract to an interface."" in this case.
  
Markus, please share your thoughts.
Markus Keller 2013-07-11 08:24:06 EDT
> 1. Access Modifier radio buttons:

We should keep the access modifier composite, but disable the modifiers that are not allowed for the selected destination. If the destination is an interface, then the extracted method should have the same keyword modifiers as the source method (i.e. if the original doesn't have a 'public' keyword, then the extracted method also shouldn't have it, although 'public' was selected in the UI).

> 2. When the expr being extracted from a default method, ...

Yeah, that's bug 393098. The ""default method"" variant can also be handled there.

> 3. Currently if we try to extract a method from a field initialization expr
> in an interface for source level < 1.8, we get NPE.
> We can add a check and show error message ""Cannot extract to an interface.""
> in this case.

Yes, please do that.
Noopur Gupta 2013-08-22 07:01:01 EDT
Created attachment 234655 [details]
Patch + Tests

Patch contains the following major changes:

- ExtractMethodInputPage.java:
* If destination is an interface, all access modifiers in the wizard should be disabled and 'public' should be selected.
The access modifier setting for next invocation of the wizard should not be changed by the earlier forced 'public' for interface.
---------------------------------
- ExtractMethodRefactoring.java
* createChange(..) : Updated since the first type in destinations list need not be the direct parent type of code being extracted. Example:
class C {
    @interface A {
    	int i= /*[*/0;/*]*/	
    }
}
* initializeDestinations() : Updated so that combo displays only valid destination types.
* createNewMethodDeclaration() : 
  - If the user extracts an expression from a method into the directly enclosing interface, the extracted method has 'public' iff the enclosing method also was public.
  - New method will be 'static' if any of its ancestor nodes up to the destination type (excluding the destination) is static. In case of interface as destination, if method is not 'static' then it will be 'default'.
---------------------------------
- ExtractMethodAnalyzer.java:
* isValidDestination(ASTNode) : To check for interfaces < 1.8 and annotation types.
* checkInitialConditions(ImportRewrite) : check if any valid destination type exists for extraction, otherwise return with error.
* checkInput(RefactoringStatus, String, ASTNode) : Existing impl ignored the methods from direct super-interfaces hierarchies of destination type, added check for that. And added null check for super-class in interface.
---------------------------------
- Checks.java:
* checkMethodInType(ITypeBinding, String, ITypeBinding[]) : Updated as constructor warning is already added and it is not an 'error' to have a method with same name as constructor.
* checkMethodInHierarchy(ITypeBinding, String, ITypeBinding, ITypeBinding[]) : Added a different explicit warning message for constructors.
---------------------------------
- ASTResolving.java:
* Updated javadocs of #findParentType(..) methods.
---------------------------------
- TODO:
* Update test cases with formatted default methods (instead of the unformatted ones currently), once bug 413592 is fixed.
---------------------------------
- This patch also contains changes from bug 403924 in ExtractMethodRefactoring.java.

Markus, please have a look.
Noopur Gupta 2013-10-01 08:25:10 EDT
Created attachment 236008 [details]
Patch + Tests

(In reply to Noopur Gupta from comment #4)
> - TODO:
> * Update test cases with formatted default methods (instead of the
> unformatted ones currently), once bug 413592 is fixed.

Updated the tests with formatted default methods.
Noopur Gupta 2014-01-15 09:08:40 EST
*** Bug 425759 has been marked as a duplicate of this bug. ***
Martin Mathew 2014-01-15 22:11:21 EST
Created attachment 239048 [details]
Patch + Tests


(In reply to Markus Keller from comment #3)
> > 2. When the expr being extracted from a default method, ...
> 
> Yeah, that's bug 393098. The ""default method"" variant can also be handled
> there.
This patch handles the case when code is extracted from default method and the duplicate code is present in static method also. The fix was given in bug 393098, i have merged the changes from master and added a testcase. The patch is checked in to mmathew/BETA_JAVA8 branch.
Markus Keller 2014-02-20 11:59:33 EST
Released all necessary commits to BETA_JAVA8, see http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=c656ba52079370b803406e5b65ffe3b2c3f6e8f6 and 4 parent commits.
Martin Mathew 2014-02-23 19:35:14 EST
Verified using Kepler SR2 + Java 8 RC1 +   Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140220-2054
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=407985,407985,P3,JDT,UI,noopur_gupta,VERI,FIXE,[1.8][extract method] Extract Method refactoring from Lambda Expressions,2014/2/23,exception,1,1,lambda,extract method,flow analysis issue,"Bug 407985 - [1.8][extract method] Extract Method refactoring from Lambda Expressions
Noopur Gupta 2013-05-14 05:16:19 EDT
Consider the following having lambda expressions: Class X and Interface I2.
We get exception or incorrect refactoring by performing ""Extract Method"" refactoring on the lines with comments.

It should be possible to extract methods from a lambda expression, which would be created in its enclosing type.

@FunctionalInterface
public interface I1 {
	int foo(int a);
}

// Error: Extracted to m1() and placed in enclosing type. 
// But replaced with ""m1();"" instead of ""int b= m1();""
class X {
	I1 i1= (int a) -> {
		int b= 10; // Error
		return a + b;
	};
	
	class Y {
		I1 i1= (int a) -> {
			int b= 10; // Error
			return a + b;
		};
	}
	
	void foo() {
		I1 i1= (int a) -> {
			int b= 10; // Error
			return a + b;
		};
	}
	
	void bar() {
		Runnable r= new Runnable() {
			I1 i1= (int a) -> {
				int b= 10; // Error
				return a + b;
			};
			
			@Override
			public void run() {
				I1 i1= (int a) -> {
					int b= 10; // Error
					return a + b;
				};				
			}
		};
	}
}

// see bug 406786 for Extract Method from lambda expr in interfaces
interface I2 {	
	I1 i1= (int a) -> {
		int b= 10; // Exception on extracting to method
		return a + b;
	};	
}
Noopur Gupta 2013-05-14 07:15:52 EDT
Another case is when we have an inferred type parameter in lambda expression and we use it in an expression, being extracted to a method. 
We get ""Unknown VariableDeclaration"" exception.

Example:

class Y {
	I1 i = (a) -> { 
		int b= a; //  Exception(Unknown VariableDeclaration)
		return b;
	};
}
Noopur Gupta 2013-08-22 06:30:08 EDT
(In reply to comment #0)
> // see bug 406786 for Extract Method from lambda expr in interfaces
> interface I2 {	
> 	I1 i1= (int a) -> {
> 		/*[*/ int b= 10; /*]*/ // Exception on extracting to method
> 		return a + b;
> 	};	
> }

After bug 406786 is fixed, there will not be any exception in the above example.
The code will be extracted to a static method in I2 and now the issue will be as in the other examples of comment #0:
> // But replaced with ""m1();"" instead of ""int b= m1();""
Noopur Gupta 2013-08-29 05:22:49 EDT
Created attachment 234907 [details]
Patch for exception in comment #1

(In reply to comment #1)
> Another case is when we have an inferred type parameter in lambda expression
> and we use it in an expression, being extracted to a method. 
> We get ""Unknown VariableDeclaration"" exception.
> 
> Example:
> 
> class Y {
> 	I1 i = (a) -> { 
> 		/*[*/ int b= a; /*]*/ //  Exception(Unknown VariableDeclaration)
> 		return b;
> 	};
> }

The attached patch fixes the issue mentioned above i.e. now there will not be any exception in the above example. The code will be extracted to a method in Y and now the issue will be as in the other examples of comment #0:
> // replaced with ""m1(a);"" instead of ""int b= m1(a);""

Markus, please have a look.
Noopur Gupta 2013-08-30 07:45:50 EDT
Some more cases:

1. 
@FunctionalInterface
public interface I {
	int foo(int a);
}

class C_Test {

	// [1] Error - return type of new method is void, should be int
	I i= a -> {
		/*[*/ return a++; /*]*/ 
	};
	
	String foo() {
		// [2] Error - return type of new method is String, should be int
		I i= a -> {
			/*[*/ return a++; /*]*/ 	
		};
	
		return """";
	}	
}

This is because the valid enclosing body declarations for method extraction are method declaration, field declaration and initializer only.
Hence, on extracting a return statement in a lambda expr, the return type of the corresponding enclosing body decl is checked, which is null in case [1] (for field) and String in case [2] (for method).

If the return stmt being extracted is within a lambda expr, return type of lambda expr should be considered instead of the enclosing body decl's return type.

2.
@FunctionalInterface
public interface J {
	void foo();
}

class X1 {
	J j1= () -> {
		/*[*/ return; /*]*/ 
	};
}

Results in =>

class X1 {
	J j1= () -> {
		extracted();
		return; // Bug - 'return;' not removed.
	};

	private void extracted() {
		/*[*/ return; /*]*/
	}
}
Noopur Gupta 2013-09-11 04:45:46 EDT
Created attachment 235376 [details]
Patch + Tests

- The patch is created from ngupta/BETA_JAVA8 branch for:
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?h=ngupta/BETA_JAVA8&id=7da82302f552442f5453a887781bf468047f8d44
It depends on the patch for bug 406786 and patch given for comment #1.

- Added the following important methods:
* ExtractMethodAnalyzer#endVisit(FieldDeclaration) to prevent CCE when only a variable declaration fragment is extracted from field declaration.
* ExtractMethodAnalyzer#visit(LambdaExpression) to allow extraction only at valid locations in lambda expr and handle bug 408009. 
* ASTNodeFactory#newReturnType(LambdaExpression, AST, ImportRewrite, ImportRewriteContext) to get the Type node for return type of lambda expr.
* ASTResolving#findEnclosingLambdaExpression(ASTNode node)

- Paste the given example in package explorer and edit the file (example: change /*a*/ to /*b*/).
Select lambda expr ""(int n1, int n2) -> n1 * n2"" and extract it to a method.
The extracted method takes unnecessary param ""int n1"" and will have compilation error which is due to bug 416560.
-------------------------------
package misc.test;

interface FI {
	int foo(int s1, int s2);
}

class Test {
	FI fi= /*a*/ (int n1, int n2) -> n1 * n2;
}
------------------------------- 

- TODO: Update tests with formatted default methods, once bug 413592 is fixed.

Markus, please have a look.
Noopur Gupta 2013-09-11 11:52:42 EDT
Another test case to be added after bug 417017 is fixed, which currently produces wrong parameter type for the extracted method:

@FunctionalInterface
interface FI {
	int foo1(int a);
}

class FI_1 {
	void fun(int a) {
		FI i1 = x1-> x1;
		FI i2 = xxx-> {
			i1.foo1(a);
			/*]*/return xxx;/*[*/
		};
	}
}
Noopur Gupta 2013-10-01 09:28:24 EDT
Created attachment 236009 [details]
Patch with updated tests

(In reply to Noopur Gupta from comment #5)
> - TODO: Update tests with formatted default methods, once bug 413592 is
> fixed.
Updated the tests with formatted default methods, added the test case from comment #6, updated fReturnTypeBinding for lambda expr.

- The patch is created from ngupta/BETA_JAVA8 branch for:
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?h=ngupta/BETA_JAVA8&id=fb4597d2163679af8202c37f5efc73a96ffa7db7
It depends on the patch given in comment #5.
Noopur Gupta 2014-02-03 03:38:59 EST
(In reply to Noopur Gupta from comment #5)
> - Paste the given example in package explorer and edit the file (example:
> change /*a*/ to /*b*/).
> Select lambda expr ""(int n1, int n2) -> n1 * n2"" and extract it to a method.
> The extracted method takes unnecessary param ""int n1"" and will have
> compilation error which is due to bug 416560.

Verified that the above issue is not reproducible after bug 416560 is fixed.
Markus Keller 2014-02-20 11:59:29 EST
Released to BETA_JAVA8 with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=f09aabc28fa041d926f45d21e601d4fac0e59812 and parent commit.
Martin Mathew 2014-02-23 18:20:02 EST
Verified using Kepler SR2 + Java 8 RC1 +   Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140220-2054
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=425950,425950,P3,JDT,UI,noopur_gupta,VERI,FIXE,"[1.8][quick assist][refactoring] ""Convert local variable to field"" on local variables of interface methods",2014/2/21,compile error,0,1,nan,Convert local variable ,overly weak precondition,"Bug 425950 - [1.8][quick assist][refactoring] ""Convert local variable to field"" on local variables of interface methods
Noopur Gupta 2014-01-17 02:08:16 EST
interface I {
	static void staticMethod() {
		int i;
	}
	default void defaultMethod() {
		int j= 0;
		j++;
	}
}

Converting local variables in interface methods (example: 'i' and 'j' in the above code) to fields should not be allowed because a field in an interface has to be initialized with some value and is 'final'. Hence, the quick assist and refactoring should be disabled in PromoteTempToFieldRefactoring.
(See also bug 410173)
Noopur Gupta 2014-01-17 02:13:10 EST
Created attachment 239083 [details]
Fix + Test

Patch based on mmathew/BETA_JAVA8 branch.
Markus Keller 2014-02-20 15:42:16 EST
Since bindings may not always be available (e.g. in case of syntax errors), we better use just the AST nodes if we can also get the information from there.

See my alternative fix in PromoteTempToFieldRefactoring#checkInitialConditions()

Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=57948a00bf129e0166b9cae7b6ae1183b5587b1b
Markus Keller 2014-02-20 15:42:28 EST
.
Martin Mathew 2014-02-21 02:12:02 EST
Verified in Java 8 RC1 using Kepler SR2(RC4) +   Eclipse Java Development Tools Patch for Java 8 Support (BETA)	1.0.0.v20140220-2054
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=356687,356687,P3,JDT,UI,nikolaymetchev,RESO,FIXE,[move method] super method invocation does not compile after refactoring,2013/8/27,compile error,1,1,-,move method,ast rewrite issue,"Bug 356687 - [move method] super method invocation does not compile after refactoring
Gustavo Soares 2011-09-04 17:26:47 EDT
Build Identifier: 20110615-0604

Applying the move method refactoring introduces a compilation error

Reproducible: Always

Steps to Reproduce:
1. Create the classes
public class A {
  public B b;
    private long m(long l) {
      return 0;
    }
  public long m(int i) {
    return 1;
  }
}
public class B extends A {
  public long test() {
    return super.m(2);
  }
}
2. Apply the move method refactoring to move m to B
public class A {
  public B b;
    private long m(long l) {
      return 0;
    }
}
public class B extends A {
  public long test() {
    return super.m(2);
  }
  public long m(int i) {
    return 1;
  }  
}
3. The resulting program does not compile: The method m from the type A is not visible
Markus Keller 2011-09-05 12:42:11 EDT
Refactoring is to move A#m(int) to B (move to the subclass).

The problem is that we don't handle the super.m(2) call in B at all.
Should at least issue an error in this case.
Markus Keller 2011-09-05 12:43:25 EDT
*** Bug 355329 has been marked as a duplicate of this bug. ***
Nikolay Metchev 2013-08-22 17:46:27 EDT
Created attachment 234680 [details]
propsed patch

This contribution complies with http://www.eclipse.org/legal/CoO.php

This fixes the reported issue. However I can't help feeling that there are corner cases that I have missed out. Even if I have missed out some cases it is still worth checking this patch in because it improves the situation.
Noopur Gupta 2013-08-23 07:13:05 EDT
Few more common cases can also be handled in this patch.
Have a look at the impl for ""if (node instanceof MethodInvocation)"" just below your fix to cover such cases, like :

1. super method invocation changes to ""null.m(2);"" :
public class A {
  public long m(B b, int i) {
  	return 1;
  }
}
public class B extends A {
  public long test() {
    return super.m(null, 2);
  }
}

2. Results in compilation error if target node was inserted while moving:
public class A {
	public int i= 0; 
	public long m(B b, int i) {
		return this.i + i;
	}
}
public class B extends A {
	public long test() {
		return super.m(new B(), 2);
	}
}

etc.
Nikolay Metchev 2013-08-23 10:24:28 EDT
Created attachment 234705 [details]
More test cases

This contribution complies with http://www.eclipse.org/legal/CoO.php

Ok I think I got all the corner cases.
Noopur Gupta 2013-08-26 08:21:39 EDT
Comment on attachment 234705 [details]
More test cases

- You are always adding ThisExpression as the *first* argument of new method invocation. This won't work here:
public class A {
	public int i= 0;
	public long m(int i, B b) {
		return this.i + i;
	}
}
public class B extends A {
	public long test() {
		return super.m(2, new B());
	}
}

- It is good to use 'if-else if' instead of consecutive 'if's wherever possible.

- Change the copyright addition to follow this one line pattern:
Name <e-mail> - summary - https://bugs.eclipse.org/BUG_NUMBER

- Please refer http://wiki.eclipse.org/JDT_UI/How_to_Contribute to configure your workspace with JDT UI specific Save Actions.
Nikolay Metchev 2013-08-26 10:26:14 EDT
Created attachment 234747 [details]
even more test cases covered

This contribution complies with http://www.eclipse.org/legal/CoO.php

Thanks Noopur,
Here is a patch with your comments incorporated
Noopur Gupta 2013-08-27 04:59:29 EDT
Thanks Nikolay, the patch looks good now.
Released after some refactoring and formatting, please have a look:
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=bd8e7065888ed4d82ba11a6485106ef4ebad93ae
Nikolay Metchev 2013-08-27 07:34:49 EDT
Thanks Noopur, Looks good
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=411529,411529,P3,JDT,UI,manju656,RESO,FIXE,[move method refactoring] reference to protected method,2013/8/21,incorrect warning message,1,1,-,move method,ast rewrite issue,"Bug 411529 - [move method refactoring] reference to protected method
Jongwook Kim 2013-06-24 14:42:53 EDT
package p;
public class A {
	protected void m(){}
}


package p;
public class B {
	public void n(q.C c, A a) {
		a.m();
	}
}

package q;
public class C {

}

When p.B.n(q.C, A) is moved to q.C, Eclipse move-refactoring pops up a warning message:

""The visibility of method `p.A.m()' will be changed to public.""

When I click the `continue' button to finish the refactoring, p.A.m() is still `protected' (no changes).

That is an error.
Martin Mathew 2013-06-25 00:38:46 EDT
Reproducible using Eclipse build: I20130605-2000. It is the same behavior in Eclipse 3.8.1 also. The refactoring results in compiler error as the visibility of the method is not modified after the refactoring operation.
Martin Mathew 2013-06-25 08:14:37 EDT
Created attachment 232727 [details]
Patch with testcases.

The CompilationUnitRewrite instance which was used to change the access modifier was not included as part of the TextChangeManager. This resulted in the in-complete refactoring.
With this patch the files that require method visibility modification is also added as part of the TextChangeManager. Added a testcase for this scenario.
Dani Megert 2013-08-20 10:23:04 EDT
(In reply to comment #2)
> Created attachment 232727 [details] [diff]
> Patch with testcases.

Storing the newly created rewrites in #getCompilationUnitRewrite makes. I don't think we neeed #getRewrites since
1. the client can already populate it upfront/before setting it
2. the client owns the map and already has access to it
Martin Mathew 2013-08-21 06:06:25 EDT
Thanks Dani. As you said the only change required was in #getCompilationUnitRewrite. Updated the code and released the fix as: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=8426c3bdd4e7c31d2c4a99dad8e963770d5f004e
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=394547,394547,P3,JDT,UI,nikolaymetchev,RESO,FIXE,[extract class] Extract class refactoring on a field in an inner non-static class yields compilation error,2013/8/12,compile error,1,1,inner class,extract class,ast rewrite issue,"Bug 394547 - [extract class] Extract class refactoring on a field in an inner non-static class yields compilation error
Milos Gligoric 2012-11-18 22:05:11 EST
Steps to reproduce:
1. Invoke ""Extract Class..."" on ""m"" in code below
2. Specify ""Nested Class in 'C'
3. There is a compilation error in the resulting file (""cannot be declared static"")

class ExtractClassBug {
    class C {
        // Invoke ""Extract Class..."" on ""m"" (and specify ""Nested Class in 'C'""
        int m;
    }
}

(Thanks to Yilong Li for helping with the bug report.)
Martin Mathew 2012-12-17 03:34:43 EST
Issue is reproducible using I20121210-0800. The refactoring results in compiler error.
Nikolay Metchev 2013-08-02 05:47:05 EDT
Created attachment 234049 [details]
Bug Fix + Test
Dani Megert 2013-08-02 06:49:45 EDT
Nikolay, you need to sign the CLA and confirm in each bug report that you want to commit the change. For details see
http://wiki.eclipse.org/Development_Resources/Contributing_via_Git#Contributing_via_Bugzilla
Noopur Gupta 2013-08-06 07:20:45 EDT
Thanks for the patch. It fixes the issue mentioned in the bug report.

Some comments:
- org.eclipse.jdt.core.dom.Modifier.isStatic(int flags) can be used to check for the ""static"" modifier in #shouldParamClassBeStatic(..)
- We should also take care of the implicitly static class declarations (without explicit ""static"" modifier). 
For example:
interface ExtractClassBug {
    class C {
        // Invoke ""Extract Class..."" on ""m"" (and specify ""Nested Class in 'C'""
        int m;
    }
}
Here, class C is implicitly static. 
Bindings always include the implicit modifiers, so if binding is not null, then you should take the modifiers form there.
- Update the tests for the case of implicitly static class declaration.

Please take care of the following general guidelines also:
- Add your credentials to the copyright headers
- Make sure the copyright date is updated to 2013 (if not yet already)
- As a rule, make the patch as small as possible i.e. don't make any changes that are not necessary to fix the problem (like marking fields 'final' and adding '@Override' to methods in existing code). This makes the review easier and faster.
- Post this in the individual bug report as a comment: ""This contribution complies with http://www.eclipse.org/legal/CoO.php""
Nikolay Metchev 2013-08-06 10:54:13 EDT
Thanks Noopur Gupta,
I will follow your suggestions and submit a new patch. Hopefully I can do it quickly.
Nikolay Metchev 2013-08-06 11:58:40 EDT
Hello Noopur,
I am having difficulty creating a combined patch. I have checked in 2 separate commits into my local git repository. I will attach the 2nd commit as a separate patch. If you have an easy way to create one patch from 2 commits please let me know. Otherwise hopefully you don't mind applying both patches separately.
Nikolay Metchev 2013-08-06 11:59:15 EDT
Created attachment 234126 [details]
code review changes

This is a patch on top of the 1st patch.
Nikolay Metchev 2013-08-07 05:21:48 EDT
This contribution complies with http://www.eclipse.org/legal/CoO.php
Noopur Gupta 2013-08-07 09:35:39 EDT
(In reply to comment #6)
> If you have an easy way to create one patch from 2 commits please let me know.

You can create a single patch for this fix by following these steps:
1. In the History view, showing eclipse.jdt.ui repository commits, select the commit which has no fix (the third from top, if the first two commits are the ones for this bug report).
2. Right click the selected commit, Reset > Mixed.
This will make all changes committed after the selected commit appear as outgoing changes. You can select only the changes for this fix and create a patch.

Please take care of the general guidelines. You could refer http://wiki.eclipse.org/JDT_UI/How_to_Contribute to configure your workspace with JDT UI specific Save Actions and follow the Coding Conventions mentioned there.
Nikolay Metchev 2013-08-07 10:04:49 EDT
Created attachment 234156 [details]
Code review changes, bug fix + unit test

Thanks Noopur Gupta,
I have created one patch for the entire change.
Many thanks for your help.
Noopur Gupta 2013-08-12 02:26:34 EDT
Thanks Nikolay. Released with some formatting changes. 
Please have a look in master:
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=7d8aced3a2b62980351820fd7f095b3ffa419391
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=408124,408124,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] CCE with Extract Class refactoring on a class with comment,2013/5/22,exception,1,1,comment related,extract class,ast rewrite issue,"Bug 408124 - [refactoring] CCE with Extract Class refactoring on a class with comment
Noopur Gupta 2013-05-15 09:01:01 EDT
Perform Refactor > Extract Class... on the following example:

// comment
public class Test {
	int i;
}

We get this exception:
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)
...
Caused by: java.lang.ClassCastException: org.eclipse.jdt.core.dom.CompilationUnit cannot be cast to org.eclipse.jdt.core.dom.TypeDeclaration
	at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractClassRefactoring.createParameterObject(ExtractClassRefactoring.java:479)
Dani Megert 2013-05-15 17:02:18 EDT
Broken since day one.
Markus Keller 2013-05-17 08:43:09 EDT
Created attachment 231151 [details]
Fix
Markus Keller 2013-05-17 08:44:54 EDT
Only happens if you set the destination to ""Nested Class"".

Dani, OK for RC2?
Dani Megert 2013-05-21 07:21:10 EDT
+1 for RC2.
Noopur Gupta 2013-05-21 07:45:24 EDT
+1 for RC2.
Markus Keller 2013-05-21 11:07:25 EDT
Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=c88048787bc4da7383cf9312520a59cc1619d909
Dani Megert 2013-05-22 03:06:45 EDT
Verified in I20130521-2000.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=69450,69450,P3,JDT,UI,jdt-ui-inbox,RESO,FIXE,[extract local] Refactor -> Extract local variable doesn't ignore whitespace in selection [refactoring],2013/1/9,fail to refactoring,0,1,nan,Extract local variable,incomplete implementation,"Bug 69450 - [extract local] Refactor -> Extract local variable doesn't ignore whitespace in selection [refactoring]
Alex Blewitt 2004-07-07 05:59:50 EDT
I used Refactor -> Extract local variable on the following piece of code:

[ getPattern().matcher(line).matches();]
^^ note space in beginning of selection

I was told that in order to use the Extract Local, I had to select an expression.

Getting rid of the space that I'd highlighted, it worked fine:
[getPattern().matcher(line).matches();]

Matcher matcher = getPattern().matcher(line);
matcher.matches();

It seems that ignoring whitespace would be trivial and that it wouldn't need to prevent such extractions 
from happening.

Mac OS X.3.4 (though suspect platform agnostic) on Eclipse 3.0 final.
Olivier Thomann 2004-07-07 10:48:56 EDT
Move to JDT/UI
Dirk Baeumer 2004-07-08 06:17:32 EDT
We should indeed try to me a little bit smarter here.
Andre Weinand 2005-03-24 07:48:18 EST
[does not seem to be Mac specific. Setting Hardware & OS to ""All""]
Martin Aeschlimann 2006-08-03 11:42:21 EDT
no plans for this at the moment.
Denis Roy 2009-08-30 02:20:21 EDT
As of now 'LATER' and 'REMIND' resolutions are no longer supported.
Please reopen this bug if it is still valid for you.
Nils Hartmann 2013-01-09 05:07:19 EST
Any plans to fix this issue? 

BTW: in some cases ""Extract local variable"" works even with selecteded the leading whitespace:

[ getPattern()] works (even though Eclipse correctly reports a compile error on that line due to the missing ';')
[ getPattern();] selecting everything including the ';' work
[ getPattern();] selecting everything but not the ';' does NOT work


(Tested with Eclipse 4.2.0)
Dani Megert 2013-01-09 06:54:47 EST
(In reply to comment #6)
> Any plans to fix this issue? 
> 
> BTW: in some cases ""Extract local variable"" works even with selecteded the
> leading whitespace:
> 
> [ getPattern()] works (even though Eclipse correctly reports a compile error
> on that line due to the missing ';')
> [ getPattern();] selecting everything including the ';' work
> [ getPattern();] selecting everything but not the ';' does NOT work
> 
> 
> (Tested with Eclipse 4.2.0)

I think you got it wrong. If the ';' is also selected then the refactoring is not available which is expected. The whitespace bug got fixed a while go.
Nils Hartmann 2013-01-09 09:57:02 EST
Created attachment 225384 [details]
Refactoring works with selected semicolon
Nils Hartmann 2013-01-09 09:57:41 EST
Created attachment 225385 [details]
Refactoring does not work without selected semicolon
Nils Hartmann 2013-01-09 09:58:37 EST
Please see the two screenshot that shows the behaviour in my Java editor (Eclipse 4.2.0)
Dani Megert 2013-01-09 10:59:57 EST
(In reply to comment #10)
> Please see the two screenshot that shows the behaviour in my Java editor
> (Eclipse 4.2.0)

I see. But still, the white psace itself is no longer a problem.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=393932,393932,P3,JDT,UI,markus.kell.r,RESO,FIXE,"[refactoring] pull-up with ""use the destination type where possible"" creates bogus import of nested type",2012/11/10,exception,1,1,input options,pull up method,ast rewrite issue,"Bug 393932 - [refactoring] pull-up with ""use the destination type where possible"" creates bogus import of nested type
Stephan Herrmann 2012-11-08 17:14:05 EST
Given this class:

package p;

public class C {
	protected class I1 {
		
	}
	protected class I2 extends I1 {
		protected void foo() {
			
		}
	}
	void test(I2 i) {
		i.foo();
	}
}

When pulling up foo() to I1 and enabling ""use the destination type where possible"" the change in test(..) creates a bogus import of the inner class I1.

Result is:

package p;

import p.C.I1; // BUG

public class C {
	protected class I1 {

		protected void foo() {
			
		}
		
	}
	protected class I2 extends I1 {
	}
	void test(I1 i) {
		i.foo();
	}
}

The bug seems to originate from the fact that SuperTypeRefactoringProcessor.createCorrespondingNode(CompilationUnitRewrite, TType) calls ImportRewrite.addImportFromSignature(String,AST) with no proper ImportRewriteContext.
Stephan Herrmann 2012-11-08 17:16:45 EST
Created attachment 223371 [details]
proposed patch

could it be as simple as this?

The patch fixes the immediate issue, not sure if more needs to be done for a full solution?
Markus Keller 2012-11-09 09:22:05 EST
Yes, it's really as simple as that, thanks for the patch.

Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=686e984f6a987f453770fc1ff7ed856e27238d93
Stephan Herrmann 2012-11-10 06:31:44 EST
(In reply to comment #2)
> Fixed with
> http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/
> ?id=686e984f6a987f453770fc1ff7ed856e27238d93

Thanks
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=393829,393829,P3,JDT,UI,markus.kell.r,RESO,FIXE,[change method signature] Precondition fails with exception when applying refactoring on a method of an anonyous class passed as argument,2012/11/9,exception,1,1,anonymous class,Change Method Signature,ast rewrite issue,"Bug 393829 - [change method signature] Precondition fails with exception when applying refactoring on a method of an anonyous class passed as argument
Milos Gligoric 2012-11-07 23:12:18 EST
Steps to reproduce:
1. Invoke ""Change Method Signature"" on method ""a""
2. Reorder parameters ""par1"" and ""par2"" (i.e., put ""par1"" ""Down"")
3. There is an exception reported in a dialog

public class ChangeMethodSignatureBug {

    public ChangeMethodSignatureBug(Object obj) {
    }

    public void m() {
        new ChangeMethodSignatureBug(new Object() {
            public void a(Object par1, Object par2) {
            }
        });
    }
}
Markus Keller 2012-11-09 10:23:57 EST
A nasty case! Thanks for the small example.

Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=ed033c13e7b5075887520e8ad96349d5f08d67db
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=297825,297825,P3,JDT,Core,tomasz.zarna,VERI,FIXE,[search] Rename refactoring doesn't update enclosing type,2012/9/17,compile error,1,1,-,rename class,Incorrect Type Resolving,"Bug 297825 - [search] Rename refactoring doesn't update enclosing type
Vladimir Piskarev 2009-12-15 06:46:54 EST
User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11
Build Identifier: M20090917-0800

When renaming a class which has a superclass containing an inner class, the type references to the inner class (qualified through the subclass) don't get updated.

Reproducible: Always

Steps to Reproduce:
1. Import project 'foo' from the attached zip file.
2. Rename class 'Foo'.
3. Note that 'Foo.Bar' reference in class 'Main' was not updated.
Vladimir Piskarev 2009-12-15 06:52:03 EST
Created attachment 154466 [details]
Zipped test project
Dani Megert 2010-01-12 03:54:00 EST
Can reproduce with I20100107-1410.
Markus Keller 2010-01-18 07:06:00 EST
The search engine does not find the reference to type Foo in 'new Foo.Bar();'. Also does not work here: 'foo.Foo.Bar bar;'.

Looks similar to bug 204118. Crucial point seems to be that Bar is not declared inside Foo, but inside _Foo, which is a supertype of Foo.
Tomasz Zarna 2012-07-16 07:43:03 EDT
Created attachment 218747 [details]
Vladmir's zip as a failing test case
Tomasz Zarna 2012-07-17 08:09:21 EDT
The test fails, because the given type binding [1] doesn't match the given qualified pattern ""b297825.Foo"" [2]. It ignores the fact that _Foo is the superclass for Foo.

[1] 
(id=NoId)
public class b297825._Foo
	extends java.lang.Object
/*   methods   */
[unresolved] public void <init>() 
/*   members   */
Member type : Bar (id=NoId)
public static class b297825._Foo$Bar
	extends java.lang.Object
	enclosing type : b297825._Foo
/*   methods   */
public void <init>() 

[2]
Thread [main] (Suspended)	
	TypeReferenceLocator(PatternLocator).resolveLevelForType(char[], char[], TypeBinding) line: 724	
	TypeReferenceLocator(PatternLocator).resolveLevelForType(char[], char[], char[][][], int, TypeBinding) line: 805	
	TypeReferenceLocator.resolveLevelForType(TypeBinding) line: 718	
	TypeReferenceLocator.resolveLevelForTypeOrEnclosingTypes(char[], char[], TypeBinding) line: 737	
	TypeReferenceLocator.resolveLevel(TypeReference) line: 683	
	TypeReferenceLocator.resolveLevel(ASTNode) line: 608	
	MatchLocator.reportMatching(CompilationUnitDeclaration, boolean) line: 2421	
	MatchLocator.process(PossibleMatch, boolean) line: 1731	
	MatchLocator.locateMatches(JavaProject, PossibleMatch[], int, int) line: 1141	
	MatchLocator.locateMatches(JavaProject, PossibleMatchSet, int) line: 1182	
	MatchLocator.locateMatches(SearchDocument[]) line: 1314	
	JavaSearchParticipant.locateMatches(SearchDocument[], SearchPattern, IJavaSearchScope, SearchRequestor, IProgressMonitor) line: 95	
	BasicSearchEngine.findMatches(SearchPattern, SearchParticipant[], IJavaSearchScope, SearchRequestor, IProgressMonitor) line: 231	
	BasicSearchEngine.search(SearchPattern, SearchParticipant[], IJavaSearchScope, SearchRequestor, IProgressMonitor) line: 515	
	SearchEngine.search(SearchPattern, SearchParticipant[], IJavaSearchScope, SearchRequestor, IProgressMonitor) line: 584	
	JavaSearchBugsTests2(AbstractJavaSearchTests).search(IJavaElement, int, int, IJavaSearchScope, SearchRequestor) line: 809	
	JavaSearchBugsTests2(AbstractJavaModelTests).search(IJavaElement, int, IJavaSearchScope, SearchRequestor) line: 2328	
	JavaSearchBugsTests2.testBug297825() line: 489
Tomasz Zarna 2012-07-17 12:08:59 EDT
Created attachment 218818 [details]
Dirty patch

A fix that enables polymorphic search (access to supertypes of Foo) in TypeReferenceLocator. Until now it was available only for MethodLocators. Collected supertypes are iterated in order to find a match with the given binding.

It's a dirty patch, so any comments are welcome. The good new is that all tests in JavaSearchBugsTests and JavaSearchBugsTests2 pass, including the new one. The fix in its current shape may have a performance impact since collecting supertypes takes some time.
Tomasz Zarna 2012-07-17 12:09:16 EDT
Created attachment 218819 [details]
mylyn/context/zip
Tomasz Zarna 2012-07-17 12:12:05 EDT
Created attachment 218820 [details]
Typos found

To make Srikanth's life easier - a typo-fixing patch as a separate attachment
Srikanth Sankaran 2012-07-18 11:15:56 EDT
Tomek, make sure to copy me on your bugs as you post patches/questions.
I'll take a look.
Srikanth Sankaran 2012-07-23 08:47:49 EDT
(In reply to comment #5)
> The test fails, because the given type binding [1] doesn't match the given
> qualified pattern ""b297825.Foo"" [2]. It ignores the fact that _Foo is the
> superclass for Foo.

Wow. We are confused between ""qualifying"" and ""enclosing"". Interesting.
I'll study the patch now.
Tomasz Zarna 2012-07-23 09:18:11 EDT
(In reply to comment #10)
> I'll study the patch now.

Thx, feel free to comment on https://git.eclipse.org/r/#/c/6847/ if you find it more convenient.
Srikanth Sankaran 2012-07-24 06:59:32 EDT
(In reply to comment #11)
> (In reply to comment #10)
> > I'll study the patch now.
> 
> Thx, feel free to comment on https://git.eclipse.org/r/#/c/6847/ if you find it
> more convenient.

The present patch as it stands has two problems as documented in gerrit: (a)
Triggers AIOOB (in a modified test case) (b) produces incorrect search results
(in a modified test).

(In reply to comment #10)

> Wow. We are confused between ""qualifying"" and ""enclosing"". Interesting.

Basically, the calls to TypeReferenceLocator#resolveLevelForTypeOrEnclosingTypes
in Juno code are pointless - It does not matter what is the enclosing type
of a member type - we should instead be concerned with the ""qualifying"" type
of ""qualified"" types.

However in an expression like Foo.Bar where Foo and Bar is valid types
and Foo.Bar itself is a valid reference, the type binding for the qualified
type has NO information about the qualifying type. 

Instead of looping finding the resolve level for each enclosing type at each
iteration, we should instead be looping finding the resolve level of the
next outer qualifying type.

This requires the ability to materialize the binding for the qualifying
type given the binding for the qualified type - some thing we are incapable
of  doing today (AFAIK). QTR itself should not be modified to capture 
these intermediate type bindings as it will blow up the memory usage - 
these should also not be recomputed in the current scenario.

So one plausible way is to introduce the notion of ""Resolution Listeners""
that would have the capability to ""notice resolutions"" and record the fact
that QualifiedTypeBindings's qualifying type's binding is 
QualifyingTypeBinding. These listners would be called only when registered
and only interested clients (TypeReferenceLocator) would register them.

Tomek, does that sound like a possible way forward ?
Srikanth Sankaran 2012-07-24 07:03:00 EDT
(In reply to comment #12)

QTR line 83 could be a suitable point to check if there are listeners
registered and if so to invoke call backs.

Registered listeners should not be captured in QTR itself. LookupEnvironment
could be a better place for that -
Tomasz Zarna 2012-07-24 08:59:34 EDT
(In reply to comment #8)
> Created attachment 218820 [details]
> Typos found

Added to typos on https://git.eclipse.org/r/#/c/6934/
Tomasz Zarna 2012-07-25 13:23:18 EDT
(In reply to comment #12)
> Tomek, does that sound like a possible way forward ?

I guess so, I implemented the suggested solution in https://git.eclipse.org/r/#/c/6847/4 and it made the tests green (all of them, including the failing ones you copy-pasted in gerrit). The fix definitely requires more polishing, but I wanted to share it with you anyway.

> QualifiedTypeBindings's qualifying type's binding is QualifyingTypeBinding

I scratched my head over this for a while ;)
Tomasz Zarna 2012-08-13 04:16:11 EDT
Created attachment 219794 [details]
Failing tests moved to JavaSearchBugsTests2.java

The failing tests extracted to JavaSearchBugsTests2.java.
Srikanth Sankaran 2012-08-14 00:17:50 EDT
All tests pass. Fix and tests released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=97d95c4ac398b379fa1804d302181f6e3b70918b - I ensured this time that
the authorship shows up properly. Thanks Tom.
Tomasz Zarna 2012-08-14 03:09:45 EDT
(In reply to comment #17)
> All tests pass. Fix and tests released via
> http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
> ?id=97d95c4ac398b379fa1804d302181f6e3b70918b

You didn't ask Gerrit to merge the change, did you? Should I abandon the change there in this case?
Srikanth Sankaran 2012-08-14 04:12:00 EDT
(In reply to comment #18)
> (In reply to comment #17)
> > All tests pass. Fix and tests released via
> > http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
> > ?id=97d95c4ac398b379fa1804d302181f6e3b70918b
> 
> You didn't ask Gerrit to merge the change, did you? Should I abandon the
> change there in this case?

Unless there is some real value in using Gerrit to merge the change, I would
prefer to generate a patch and release it myself. That will allow us to use
Gerrit for code reviews and inline comments & discussions, while otherwise
keeping the process simple.

Is there an issue in leaving it as it is ? The review is complete and all
the approvals are there.
Tomasz Zarna 2012-08-14 05:14:40 EDT
(In reply to comment #19)
> Is there an issue in leaving it as it is ? 

Technically, it's still open. To close the change it either needs to be merged or abandoned. I will do the latter. No big deal, but it's going to look weird with all the approvals in place ;)
Srikanth Sankaran 2012-08-14 06:04:21 EDT
(In reply to comment #20)
> (In reply to comment #19)
> > Is there an issue in leaving it as it is ? 
> 
> Technically, it's still open. 

What does this mean in real terms ? Does the act of merging on the one
hand or abandoning on the other cause some resource reclamation or garbage
collection of sorts to trigger ? 

Alternately does leaving it open cause some resource leakage/persistence 
issues ?
Dani Megert 2012-08-14 06:15:34 EDT
(In reply to comment #21)
> (In reply to comment #20)
> > (In reply to comment #19)
> > > Is there an issue in leaving it as it is ? 
> > 
> > Technically, it's still open. 
> 
> What does this mean in real terms ? Does the act of merging on the one
> hand or abandoning on the other cause some resource reclamation or garbage
> collection of sorts to trigger ? 

Merge would fail with a conflict, since the change is already in the repo. The right thing to do is abandon the change with a comment.
Tomasz Zarna 2012-08-14 06:43:13 EDT
(In reply to comment #22)
> The right thing to do is abandon the change with a comment.

It's already done.
Srikanth Sankaran 2012-09-17 11:04:19 EDT
Verified for 4.3 M2 using Build id: I20120916-2000
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=386518,386518,P3,JDT,UI,markus.kell.r,RESO,FIXE,[extract method] CCE in ExtractMethodRefactoring#createMethodBody(..),2012/8/29,exception,1,1,foreach,extract method,overly weak preconditions,"Bug 386518 - [extract method] CCE in ExtractMethodRefactoring#createMethodBody(..)
Holger Klene 2012-08-02 14:39:35 EDT
From my logfile:

!SESSION 2012-08-02 08:19:17.758 -----------------------------------------------
eclipse.buildId=I20120608-1400
java.version=1.7.0_04
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=de_DE
Command-line arguments:  -os linux -ws gtk -arch x86

!ENTRY org.eclipse.jface.text 2 0 2012-08-02 10:10:56.675
!MESSAGE 
!STACK 0
java.lang.ClassCastException: org.eclipse.jdt.core.dom.ChildPropertyDescriptor cannot be cast to org.eclipse.jdt.core.dom.ChildListPropertyDescriptor
	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractMethodRefactoring.createMethodBody(ExtractMethodRefactoring.java:1115)
	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractMethodRefactoring.createNewMethod(ExtractMethodRefactoring.java:960)
	at org.eclipse.jdt.internal.corext.refactoring.code.ExtractMethodRefactoring.createChange(ExtractMethodRefactoring.java:508)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.RefactoringCorrectionProposal.createTextChange(RefactoringCorrectionProposal.java:59)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.createChange(CUCorrectionProposal.java:244)
	at org.eclipse.jdt.ui.text.java.correction.ChangeCorrectionProposal.getChange(ChangeCorrectionProposal.java:355)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getTextChange(CUCorrectionProposal.java:254)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getAdditionalProposalInfo(CUCorrectionProposal.java:141)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.RefactoringCorrectionProposal.getAdditionalProposalInfo(RefactoringCorrectionProposal.java:71)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
Ayushman Jain 2012-08-02 14:46:02 EDT
Moving to JDT/UI.

Holger, can you please attach a code snippet showing the problem? Thanks!
Holger Klene 2012-08-02 15:04:11 EDT
Comparing with local history I found:

OLD:
------------------
    public static boolean compare(final MultiAlignment first, final MultiAlignment second) {
        assert first.m_totalCost == second.m_totalCost;
        final Set<InDelSequence> unchecked = new HashSet<>(second);
        outer: for (final InDelSequence f : first) {
            for (final Iterator<InDelSequence> iterator = unchecked.iterator(); iterator.hasNext();) {
                final InDelSequence s = iterator.next();
                if (f.equals(s)) {
                    iterator.remove();
                    continue outer;
                }
            }
            assert false : ""No match for "" + f + "" in "" + second;
        }
        return true;
    }



NEW:
----------------
    public static boolean equal(final MultiAlignment first, final MultiAlignment second) {
        assert first.m_totalCost == second.m_totalCost;
        final Set<InDelSequence> unchecked = new HashSet<>(second);
        outer: for (final InDelSequence f : first) {
            for (final Iterator<InDelSequence> iterator = unchecked.iterator(); iterator.hasNext();) {
                final InDelSequence s = iterator.next();
                if (InDelSequence.equal(f, s)) {
                    iterator.remove();
                    continue outer;
                }
            }
            assert false : ""No match for "" + f + "" in "" + second;
        }
        assert unchecked.isEmpty() : String.format(""Could not match %d of %s in %s%n%s"",
            unchecked.size(), second, first, unchecked);
        return true;
    }


BTW: As there are other changes, I suspect, I was trying to issue the rename while the editor was still dirty (possibly not compiling)
Markus Keller 2012-08-03 06:29:18 EDT
I don't see how this could happen. Please reopen if you have more information.
Holger Klene 2012-08-25 04:25:08 EDT
Sorry, for the misleading code snippet in comment 2 ... I was hunting for refactorings and only found that one.

But now, I nailed the true culprit:

public class Proposal {

    public static void main(final String[] args) {
        int[] array = {1,2,3};

        for (int i : array) { // <- select HERE
            System.out.println(i);
        }
    }

}



Steps to reproduce:
1. select everything between () of the for loop
2. invoke content assist by Ctrl+1
3. Cursor down over entry ""extract method""
4. The initial exception is written to the log
5. if you keep on cycling with the cursor around, an additional followup exception is logged:

!SESSION 2012-08-25 09:26:45.899 -----------------------------------------------
eclipse.buildId=I20120810-1300
java.version=1.7.0_06
java.vendor=Oracle Corporation
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=de_DE
Command-line arguments:  -os linux -ws gtk -arch x86

[...]

!ENTRY org.eclipse.jface.text 2 0 2012-08-25 10:19:10.221
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.getAdditionalProposalInfo(CUCorrectionProposal.java:142)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.RefactoringCorrectionProposal.getAdditionalProposalInfo(RefactoringCorrectionProposal.java:71)
	at org.eclipse.jface.text.contentassist.AdditionalInfoController$3.run(AdditionalInfoController.java:106)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)



BTW: I updated to 4.3M1
Markus Keller 2012-08-27 14:13:22 EDT
Thanks, fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=f3a6bb494a448de140b9d6f3983d1f4b5f49c893

Note that ""int i : array"" cannot be extracted, since the variable declaration must stay there. But you can extract ""array"".
Holger Klene 2012-08-29 13:16:05 EDT
(In reply to comment #5)
> Note that ""int i : array"" cannot be extracted, since the variable
> declaration must stay there. But you can extract ""array"".

Actually I had not intent to extract anything. I just had to cursor over it to get to the more relevant refactorings to convert the loop to iterator or index based. Now I wonder how Eclipse determines the order / relevance of such proposals?

Anyway, I'm glad you could fix it now.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=347389,347389,P3,JDT,UI,markus.kell.r,RESO,FIXE,[move member type] IllegalArgumentException on Refactor: Move Type to new File..,2012/6/12,exception,1,1,synchronized block,Move member Type to new File,ast rewrite issue,"Bug 347389 - [move member type] IllegalArgumentException on Refactor: Move Type to new File..
Miles Parker 2011-05-26 21:33:45 EDT
I don't think there was anything unusual happening when I tried this.

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:605)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:678)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:472)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:624)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:240)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4123)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1457)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1480)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1465)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1270)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3969)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3608)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:181)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:193)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:116)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:378)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:170)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4123)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1457)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1480)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1465)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:1270)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3969)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3608)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:187)
	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:1303)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring$TypeReferenceQualifier.visit(MoveInnerToTopRefactoring.java:323)
	at org.eclipse.jdt.core.dom.ThisExpression.accept0(ThisExpression.java:137)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2530)
	at org.eclipse.jdt.core.dom.SynchronizedStatement.accept0(SynchronizedStatement.java:164)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2553)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2530)
	at org.eclipse.jdt.core.dom.IfStatement.accept0(IfStatement.java:190)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2553)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2530)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:504)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2553)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:484)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createCompilationUnitRewrite(MoveInnerToTopRefactoring.java:912)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:842)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:736)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Root exception:
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:187)
	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:1303)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring$TypeReferenceQualifier.visit(MoveInnerToTopRefactoring.java:323)
	at org.eclipse.jdt.core.dom.ThisExpression.accept0(ThisExpression.java:137)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2530)
	at org.eclipse.jdt.core.dom.SynchronizedStatement.accept0(SynchronizedStatement.java:164)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2553)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2530)
	at org.eclipse.jdt.core.dom.IfStatement.accept0(IfStatement.java:190)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2553)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2530)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:504)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2553)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:484)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2482)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createCompilationUnitRewrite(MoveInnerToTopRefactoring.java:912)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:842)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:736)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Miles Parker 2011-05-26 21:35:22 EDT
There is a synchronized block in the code and I can see that in the AST. Here's the code:

	protected class SynchronizedCommandStack extends BasicCommandStack {
		public void execute(Command command) {
			if (command instanceof AbstractOverrideableCommand) {
				synchronized (SynchronizedCommandStack.this) {
					super.execute(command);
				}
			} else {
				super.execute(command);
			}
		}
	}
Miles Parker 2011-05-26 21:37:59 EDT
Sure enough, commenting out those lines allowed the refactoring to suceed. This doesn't sound like UI, so I'm moving it to core.

	protected class SynchronizedCommandStack extends BasicCommandStack {
		public void execute(Command command) {
			if (command instanceof AbstractOverrideableCommand) {
				//synchronized (SynchronizedCommandStack.this) {
					super.execute(command);
				//}
			} else {
				super.execute(command);
			}
		}
	}
Olivier Thomann 2011-05-26 21:43:33 EDT
Could you please provide complete steps to reproduce?
I'll take a look.
Miles Parker 2011-05-26 22:21:27 EDT
Hi Oliver,

I can do better. Here's a simple test case that works consistently. Create the following:

public class TestClass {
    protected class SynchronizedSomething {
        public void execute() {
        	if (true) {
                synchronized (SynchronizedSomething.this) {
                    System.err.println();
                }
            }
        }
        
    }
}

Invoked the Refactor: Move Type to new File on SynchronizedSomething.
Markus Keller 2011-05-27 09:38:40 EDT
Already happened in 3.6.2.

The bug is in the refactoring implementation (which is in the jdt.ui plug-in). 

Raksha, please have a look for 3.8. We must not pass """" to SimpleName#setIdentifier(String).
Raksha Vasisht 2011-09-06 04:57:43 EDT
(In reply to comment #5)
> Already happened in 3.6.2.
> 
> The bug is in the refactoring implementation (which is in the jdt.ui plug-in). 
> 
> Raksha, please have a look for 3.8. We must not pass """" to
> SimpleName#setIdentifier(String).

Hmm after initial debugging I found that the analysis done in in the refactoring implementation(jdt.ui) to determine whether we need to provide a name for the enclosing instance field name optionally or mandatorily- depending on whether it contains any references to the enclosing type- is correct in   org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.isInstanceFieldCreationMandatory(). 
 In the example provided in comment#4 there is no reference to the enclosing type, hence we allow passing """" empty string in the name field. (See that if the example is changed to :
 
public class TestClass {
	protected class SynchronizedSomething {
		public void execute() {
			if (true) {
				synchronized (TestClass.this) { // changed here
					System.err.println();
				}
			}
		}
	}
the dialog asks for a non-optional string for enclosing field name, which is right)

Also, for the current example, if you try to provide any string (say 'i') as the enclosing instance field name, the refactoring completes without any error but results in wrong code in the end: 

class SynchronizedSomething {
    /**
	 * 
	 */
	private final TestClass i;

	/**
	 * @param testClass
	 */
	SynchronizedSomething(TestClass testClass) {
		i = testClass;
	}

	public void execute() {
        if (true) {
            synchronized (i) {  // WRONG HERE, should be 'this' 
                System.err.println();
            }
        }
    }
}

The code path from :

declaration.accept(new TypeReferenceQualifier(binding, null));

(line 912) in method:  
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createCompilationUnitRewrite(...) 

is wrong and somewhere in the call stack below we replace SynchronizedSomething.this with instance of TestCase. 

Stack trace:

SimpleName.setIdentifier(String) line: 177	
AST.newSimpleName(String) line: 2036	
MoveInnerToTopRefactoring$TypeReferenceQualifier.visit(ThisExpression) line: 323	
ThisExpression.accept0(ASTVisitor) line: 137	
ThisExpression(ASTNode).accept(ASTVisitor) line: 2514	
SynchronizedStatement(ASTNode).acceptChild(ASTVisitor, ASTNode) line: 2562	
SynchronizedStatement.accept0(ASTVisitor) line: 164	
SynchronizedStatement(ASTNode).accept(ASTVisitor) line: 2514	
Block(ASTNode).acceptChildren(ASTVisitor, ASTNode$NodeList) line: 2585	
Block.accept0(ASTVisitor) line: 136	
Block(ASTNode).accept(ASTVisitor) line: 2514	
IfStatement(ASTNode).acceptChild(ASTVisitor, ASTNode) line: 2562	
IfStatement.accept0(ASTVisitor) line: 190	
IfStatement(ASTNode).accept(ASTVisitor) line: 2514	
Block(ASTNode).acceptChildren(ASTVisitor, ASTNode$NodeList) line: 2585	
Block.accept0(ASTVisitor) line: 136	
Block(ASTNode).accept(ASTVisitor) line: 2514	
MethodDeclaration(ASTNode).acceptChild(ASTVisitor, ASTNode) line: 2562	
MethodDeclaration.accept0(ASTVisitor) line: 504	
MethodDeclaration(ASTNode).accept(ASTVisitor) line: 2514	
TypeDeclaration(ASTNode).acceptChildren(ASTVisitor, ASTNode$NodeList) line: 2585	
TypeDeclaration.accept0(ASTVisitor) line: 484	
TypeDeclaration(ASTNode).accept(ASTVisitor) line: 2514	
MoveInnerToTopRefactoring.createCompilationUnitRewrite(ITypeBinding[], CompilationUnitRewrite, Map<ICompilationUnit,SearchMatch[]>, Map<ICompilationUnit,SearchMatch[]>, boolean, ICompilationUnit, ICompilationUnit, boolean, RefactoringStatus, IProgressMonitor) line: 912
Markus Keller 2012-06-12 12:48:46 EDT
Fixed with http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=c9b0a72830519fb2b28487bac66b7c8b96c9112b
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=379095,379095,P3,JDT,UI,markus.kell.r,RESO,FIXE,[introduce parameter] NullPointerException during refactor -> introduce parameter,2012/5/10,exception,1,1,-,introduce parameter,overly weak preconditions,"Bug 379095 - [introduce parameter] NullPointerException during refactor -> introduce parameter
Alexander Winizki 2012-05-10 06:29:33 EDT
Build Identifier: 20120216-1857

Reproducibility: happens every time at one specific place in code, but not at other places.
1. Highlight a variable 
2. right click ""refactor -> introduce parameter""
3. in the refactoring dialog box click on ""OK"" -> an unexpected exception occurred while performing the refactoring.

In the log file, the following stack trace appears:

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2012-05-10 12:27:31.485
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:331)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:605)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:678)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:455)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:472)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:624)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:240)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3588)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3209)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:181)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:193)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:116)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startIntroduceParameter(RefactoringExecutionStarter.java:371)
	at org.eclipse.jdt.ui.actions.IntroduceParameterAction.run(IntroduceParameterAction.java:84)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:279)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3588)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3209)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2701)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2665)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2499)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:679)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:668)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:616)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
Caused by: java.lang.NullPointerException
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureProcessor.checkFinalConditions(ChangeSignatureProcessor.java:808)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceParameterRefactoring.checkFinalConditions(IntroduceParameterRefactoring.java:509)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Root exception:
java.lang.NullPointerException
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureProcessor.checkFinalConditions(ChangeSignatureProcessor.java:808)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
	at org.eclipse.jdt.internal.corext.refactoring.code.IntroduceParameterRefactoring.checkFinalConditions(IntroduceParameterRefactoring.java:509)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)

Reproducible: Always

Steps to Reproduce:
Reproducibility: happens every time at one specific place in code, but not at other places.
1. Highlight a variable 
2. right click ""refactor -> introduce parameter""
3. in the refactoring dialog box click on ""OK"" -> an unexpected exception occurred while performing the refactoring.
Alexander Winizki 2012-05-10 06:47:10 EDT
Here is an exact test case:

/****** class Super *************/
package pkg;

public abstract class Super {
	public abstract void foo();

	protected int xxx;

	public void bar() {
		foo();
	}
}
/****** end of class Super *************/

/****** class Sub1 *************/
1. package pkg;
2.
3. public class Sub1 extends Super {
4.
5.	@Override
6.	public void foo() {
7.		System.out.println(xxx);
8.	}
9.
10. }
/****** end of class Sub1 *************/

/****** class Sub2 *************/
package pkg;

public class Sub2 extends Super {

	@Override
	public void foo() {
	}
}
/****** end of class Sub1 *************/

/*** Steps to reproduce *********/

In class Sub1, on line 7, select the variable reference ""xxx"" and try ""refactor -> introduce parameter""
==> exception

Suggestion: if this refactoring is not possible, a meaningful error message should appear.
Ayushman Jain 2012-05-10 08:14:29 EDT
Moving to JDT/UI
Dani Megert 2012-05-10 11:24:57 EDT
This got fixed a month ago by:

http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=45d8a3a99533a613ae9fc4b24a51db54812dea2f
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=352785,352785,P3,JDT,UI,markus.kell.r,RESO,FIXE,[extract method] Refactor > Extract Method with break statement in switch causes NPE,2012/4/16,exception,1,1,switch case,extract method,overly weak preconditions,"Bug 352785 - [extract method] Refactor > Extract Method with break statement in switch causes NPE
Shawn Lauzon 2011-07-21 12:57:27 EDT
Build Identifier: 20110615-0604

If I attempt to Refactor > Extract Method which includes a break statement inside a switch, an unexpected exception occurs, which is an NPE (will attach stack later).

It should give an error which says something like you can't refactor a method which includes multiple exit points, or something like that.





Reproducible: Always

Steps to Reproduce:
1. Write some code:
   public void foo(int i) {

    	switch (i) {
    	case 1:
         	if (true) {
        		break;
        	}
    	}
} 

2. Highlight the some code within the case 1 statement.

3. Choose Refactor > Extract Method
Shawn Lauzon 2011-07-21 12:58:56 EDT
Created attachment 200107 [details]
Stack dump
Ayushman Jain 2011-07-21 13:01:37 EDT
Moving to JDT/UI
Dani Megert 2011-07-22 02:29:14 EDT
Used to work but got broken during 3.6.
Markus Keller 2012-04-16 14:05:14 EDT
http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=75fd0aa41dab6f964c2a3a76053e09ec6b3c1be7
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=366281,366281,P3,JDT,UI,deepakazad,RESO,FIXE,[refactoring] [extract method] Extract Method refactoring fails if trailing ';' is not selected,2012/1/21,not available,1,1,-,extract method,selection parsing issue,"Bug 366281 - [refactoring] [extract method] Extract Method refactoring fails if trailing ';' is not selected
Mohsen Vakilian 2011-12-09 22:37:23 EST
Build ID: I20111207-2118

If a programmer selects the left-hand side ""i"" from a statement of form ""i = 0;"" and invokes the Extract Method refactoring, the refactoring tool will report the following problem and prevent the programmer from continuing the refactoring:

>Cannot extract the left-hand side of an assignment.

However, we noticed that the refactoring tool will report the above error message even if the programmer selects an expression of form ""i = 0"" from a statement of form ""i = 0;"". Two of the participants of the CodingSpectator study <http://codingspectator.cs.illinois.edu/> forgot to include the trailing semicolon in their selections and ran into this problem. This problem occurred three times. Because our participants sometimes repeated the refactoring multiple times, they received the above error message five times. In all three instances, our participants eventually overcome the problem by including the trailing semicolon in their selections.

It would be nice if the refactoring automatically extends the selection to cover the trailing semicolon the same way that it shrinks the selection to exclude the trailing semicolon in some cases (See Bug 324237).
Deepak Azad 2011-12-16 06:36:34 EST
The if condition in ExtractMethodAnalyzer.visit(Assignment) does not look perfect.
Jean-Noel Rouvignac 2012-01-20 03:03:14 EST
What about using this:

if ((getSelection().covers(node.getLeftHandSide()) && !getSelection().covers(node.getRightHandSide())) || getSelection().coveredBy(node.getLeftHandSide())) {
Deepak Azad 2012-01-21 10:15:16 EST
(In reply to comment #2)
> if ((getSelection().covers(node.getLeftHandSide()) &&
> !getSelection().covers(node.getRightHandSide())) ||
> getSelection().coveredBy(node.getLeftHandSide())) {

Thanks! That works.

Fixed in master - 371ad683cf46d904a9c00c3494d31522d33f5b08

Note that the result is slightly different when you select 'i = 0;' or 'i = 0', but I think that is OK.
Mohsen Vakilian 2012-01-21 10:31:03 EST
(In reply to comment #3)
> Note that the result is slightly different when you select 'i = 0;' or 'i = 0'

How are the results different?
Deepak Azad 2012-01-21 10:44:41 EST
(In reply to comment #4)
> How are the results different?

New method with ; selected
private void extracted() {
	field = 1;
}

New method with ; NOT selected
private int extracted() {
	return field = 1;
}

Full code snippets are available here - http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=371ad683cf46d904a9c00c3494d31522d33f5b08
Mohsen Vakilian 2012-01-21 16:03:16 EST
(In reply to comment #5)
> (In reply to comment #4)
> > How are the results different?
> 
> New method with ; selected
> private void extracted() {
>     field = 1;
> }
> 
> New method with ; NOT selected
> private int extracted() {
>     return field = 1;
> }
> 
> Full code snippets are available here -
> http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=371ad683cf46d904a9c00c3494d31522d33f5b08

Deepak,

Thanks for pointing me to the examples. The different behaviors in the above two cases seem consistent with how Eclipse handles other similar selections. I will try a few more examples when a build of Eclipse that contains your patch appears at http://download.eclipse.org/eclipse/downloads/
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=125326,125326,P3,JDT,UI,deepakazad,RESO,FIXE,[pull up] of abstract methods to abstract base class fails [refactoring],2011/11/15,exception,1,1,-,pull up method,ast rewrite issue,"Bug 125326 - [pull up] of abstract methods to abstract base class fails [refactoring]
Andreas Krüger 2006-01-26 08:39:15 EST
I have an abstract class X with some abstract methods, some regular methods, some static methods, and some subclasses. X has an abstract base class B. In fact, B is empty: It has no methods, no fields, nothing yet.

I want to move three abstract methods from X to B.  I could have simply used cut&paste in this situation. But instead, I choose to use ""refactor->pull up"".

That bombed on me.

The .metadata/.log has this to say (due to an oversecured internet setup, I have to copy this by typing it in, so pardon any mistakes):

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2006-01-26 14:10:28.07
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
   at org.eclipse.jface.operation.ModalContext.run(ModelContext.java:327)
   at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:830)
   at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:573)
   at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:416)
   at org.eclipse.ltk.ui.refactoring.RefactoringWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
   at org.eclipse.jdt.internal.ui.refactoring.PullUpWizard$PullUpInputPage2.getNextPage(PullUpWizard.java:1150)
   at org.eclipse.jface.wizard.WizardDialg.nextPressed(WizardDialg.java:747)
- and so on - 
Caused by: java.lang.IllegalArgumentException
   at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.createStringPlaceholder(ASTRewrite.java:428)
   at org.eclipse.jdt.internal.context.refactoring.structure.PullUpRefactoring.createJavadocForStub(PullUpRefactoring.java:1035)
   at org.eclipse.jdt.internal.context.refactoring.structure.PullUpRefactoring.addMethodStubsToNonAbstractSubclassesOfTargetClass(PullUpRefactoring.java:415)
   at org.eclipse.jdt.internal.context.refactoring.structure.PullUpRefactoring.createChangeManager(PullUpRefactoring.java:1002)
      at org.eclipse.jdt.internal.context.refactoring.structure.PullUpRefactoring.checkFinalConditions(PullUpRefactoring.java:615)
- and so on -

Regards, and thank you for providing fine software.
Dirk Bergstrom 2006-11-07 20:13:27 EST
I tried to pull up four or five methods and a few fields from two abstract classes into an abstract base class.  Three of the methods were abstract.  I went through the wizard, and clicked on the ""finish"" button, and got an error box that said ""Exception does not provide a detail message"".  When I dismissed that box, Eclipse hung.  I finally had to kill it.

I'll attach the relevant lines from .log, and my configuration details.
Dirk Bergstrom 2006-11-07 20:13:34 EST
Created attachment 53426 [details]
Eclipse configuration just after crash
Dirk Bergstrom 2006-11-07 20:14:07 EST
Created attachment 53427 [details]
Error log of crash
Dirk Bergstrom 2006-11-07 20:20:39 EST
I remembered a bit more about how the problem went...

After the error dialog, I was given the option to undo any changes.  I accepted the offer, and *then* Eclipse hung.

When I restarted and brought up all the files, one of the classes had had the methods pulled out of it, but the other two affected methods were unchanged.  So it looks like it failed part way through the refactoring, but hung while trying to undo.
Andrey Loskutov 2011-09-23 08:03:08 EDT
Wow, this one (pulling up few abstract methods from one abstract class into another one) is still present in the 3.7.0 Eclipse. Cool.

Stack:

eclipse.buildId=I20110613-1736
java.version=1.6.0_25
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -showLocation
Command-line arguments:  -os linux -ws gtk -arch x86_64 -showLocation

Error
Fri Sep 23 13:57:47 CEST 2011
Internal Error

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:1029)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:631)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:470)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
	at org.eclipse.jdt.internal.ui.refactoring.PullUpMethodPage.getNextPage(PullUpMethodPage.java:450)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:908)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:428)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:624)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:240)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3588)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3209)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:181)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:193)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:116)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startPullUpRefactoring(RefactoringExecutionStarter.java:423)
	at org.eclipse.jdt.ui.actions.PullUpAction.run(PullUpAction.java:128)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:275)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:251)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3588)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3209)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2696)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2660)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2494)
	at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:674)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:667)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:123)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:622)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:577)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1410)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1386)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.createStringPlaceholder(ASTRewrite.java:620)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createJavadocForStub(PullUpRefactoringProcessor.java:1299)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.addMethodStubForAbstractMethod(PullUpRefactoringProcessor.java:513)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.addNecessaryMethodStubs(PullUpRefactoringProcessor.java:536)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1208)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:765)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Root exception:
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.createStringPlaceholder(ASTRewrite.java:620)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createJavadocForStub(PullUpRefactoringProcessor.java:1299)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.addMethodStubForAbstractMethod(PullUpRefactoringProcessor.java:513)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.addNecessaryMethodStubs(PullUpRefactoringProcessor.java:536)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1208)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:765)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2344)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Deepak Azad 2011-11-08 10:33:38 EST
The interesting part of the exception

> Root exception:
> java.lang.IllegalArgumentException
>     at
> org.eclipse.jdt.core.dom.rewrite.ASTRewrite.createStringPlaceholder(ASTRewrite.java:620)
>     at
> org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createJavadocForStub(PullUpRefactoringProcessor.java:1299)
>     at
> org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.addMethodStubForAbstractMethod(PullUpRefactoringProcessor.java:513)
>     at
> org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.addNecessaryMethodStubs(PullUpRefactoringProcessor.java:536)
>     at

Javadoc of org.eclipse.jdt.ui.CodeGeneration.getMethodComment(ICompilationUnit, String, MethodDeclaration, boolean, String, String, String[], String) clearly states that this method can return null. We could check for null before calling ASTRewrite.createStringPlaceholder(..)

Having said that, I cannot reproduce the exception so far. 

Andrey, do you have a code snippet to reproduce this?
Markus Keller 2011-11-08 12:10:50 EST
Steps:
1. set ""Java Code Style > Code Template"" settings:
  - make ""Comments > Overriding methods"" empty
  - check ""Automatically add comments &for new methods and types""

2. Pull Up m():

abstract class A {
	
}

abstract class B extends A {
	abstract void m();
}

class C extends A {
	
}
Deepak Azad 2011-11-15 10:10:18 EST
Fixed in master - c2b87671e25f496909e03a7e4970fdf952dec5ea
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=295200,295200,P3,JDT,UI,raksha.vasisht,VERI,FIXE,[inline] Inline local variable refactoring deletes comment right before the variable declaration,2011/4/26,comment related,1,1,comment related,inline local variable,ast rewrite issue,"Bug 295200 - [inline] Inline local variable refactoring deletes comment right before the variable declaration
Arne Deutsch 2009-11-16 02:03:15 EST
User-Agent:       Mozilla/5.0 (Windows; U; Windows NT 5.1; de; rv:1.9.0.15) Gecko/2009101601 Firefox/3.0.15 (.NET CLR 3.5.30729)
Build Identifier: M20090917-0800

When using inline (ALT+SHIFT+I) to inline a local variable and right before the declaration of the variable is a comment, the comment disappears.

The bug _may_ be related to: https://bugs.eclipse.org/bugs/show_bug.cgi?id=279124

Reproducible: Always

Steps to Reproduce:
1. Create a class with the following method:

  public void testIt() {
  	// blah
  	String test = """";
  	System.out.println(test);
  }

2. Place the cursor on the literal ""test"".
3. Press ALT+SHIFT+I

The resulting code looks like this:

  public void testIt() {
  	System.out.println("""");
  }

The comment is lost.
Olivier Thomann 2009-11-26 13:11:32 EST
I don't know how the compiler can know if the comment is related or not to the next statement.
If we want to fix this, this means we never remove the preceding comment.
Frederic Fusier 2009-11-27 10:15:03 EST
Using the ASTView, I can see in the DOM/AST tree that the comment is well attached to the following VariableDeclarationSegment. So, I think that the problem comes from the fact that this segment is deleted by the inlining operation without taking care of the attached comment.

Howver, IMO, there's nothing else to do because, there's no way to know whether the comment would be still appropriate on the place where the local variable was inlined...
Arne Deutsch 2009-11-27 12:10:23 EST
I would vote to let the comment untouched. Delete the comment is unexpected behaviour because it might be unrelated to the local variable.

I would think this:

  public void testIt() {
      // TODO we have to do something fancy here
      String test = """";
      System.out.println(test);
  }

should be transformed to this:

  public void testIt() {
      // TODO we have to do something fancy here
      System.out.println("""");
  }

If the user wish to delete the comment he could do, but eclipse should not delete it by itself. In more complex code the user might not even notice that a comment is deleted.
Olivier Thomann 2010-03-17 12:02:53 EDT
Since the comment is part of the extended range of the VariableDeclarationStatement, we cannot easily fix it as it is specified that by default a TargetSourceRangeComputer is used.
Markus, I think there is nothing we can do about this one at the ASTRewrite level.
Markus Keller 2010-03-18 13:46:04 EDT
> Markus, I think there is nothing we can do about this one at the ASTRewrite
> level.

Yes, we need to fix this in the refactoring.
John Arthorne 2011-01-24 13:53:26 EST
Just got bitten by this. You definitely can't assume the comment is no longer relevant if a local variable declaration is inlined. My code was roughly like this:

void doPost(HttpServletRequest req, HttpServletResponse resp) {
	save();
	//if a range  is specified, then file is being uploaded during the post
	String range = req.getHeader(ProtocolConstants.HEADER_CONTENT_RANGE);
	if (range != null) {
		doPut(req, resp);
		return;
	}
}

Inlining ""range"" produced:

void doPost(HttpServletRequest req, HttpServletResponse resp) {
	save();
	if (req.getHeader(ProtocolConstants.HEADER_CONTENT_RANGE) != null) {
		doPut(req, resp);
		return;
	}
}

Increasing severity because you are deleting user data here.
Markus Keller 2011-01-24 14:27:22 EST
*** Bug 318471 has been marked as a duplicate of this bug. ***
Markus Keller 2011-01-24 14:29:48 EST
Yes, we shouldn't lose comments here.

The right fix is to use ASTRewrite#setTargetSourceRangeComputer() with a TightSourceRangeComputer that marks the replaced variable declaration node as a tight node, see e.g. LocalCorrectionsSubProcessor#getUnusedObjectAllocationProposals(..).
Raksha Vasisht 2011-04-21 07:43:59 EDT
Created attachment 193804 [details]
Patch + tests

Patch using the TightSourceRangeComputer for removed node.
Markus Keller 2011-04-21 10:03:22 EDT
Looks good, please release.

Test methods could get a comment telling what they test.
Raksha Vasisht 2011-04-21 11:58:45 EDT
(In reply to comment #10)
> Looks good, please release.
> 
> Test methods could get a comment telling what they test.

Done. Thanks Markus, committed to HEAD.
Dani Megert 2011-04-26 10:34:34 EDT
Verified in I20110425-1800.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=342074,342074,P3,JDT,UI,markus.kell.r,RESO,FIXE,[move method] Refactor->Move an instance method to another causes IAE in SimpleName.setIdentifier,2011/4/7,exception,1,1,-,move method,ast rewrite issue,"Bug 342074 - [move method] Refactor->Move an instance method to another causes IAE in SimpleName.setIdentifier
Chris Leon 2011-04-06 16:13:13 EDT
Build Identifier: M20110210-1200

I want to move some functionality of class A to a new composing class B.  I created a new class B, which has nothing in it.  I change A.method() to take a B as a parameter, so that I can use the instance method Move refactoring to move method() to B.  That fails with a NullPointerException, in the attached stack trace.

Reproducible: Always

Steps to Reproduce:
I tried to create a new set of classes that demonstrate this problem, but haven't been able to find whatever makes this refactoring fail in this case.  I can however reproduce it every time with my code, but confidentiality prohibits my posting that code here.
Chris Leon 2011-04-06 16:14:20 EDT
Created attachment 192667 [details]
Stack trace
Chris Leon 2011-04-06 16:17:56 EDT
I checked 328554 and 328786 which seemed similar, but this stack trace is different so I assume the underlying cause is new.
Dani Megert 2011-04-07 02:23:45 EDT
Just to clarify: you do this in the Java editor, right?
Chris Leon 2011-04-07 09:11:31 EDT
(In reply to comment #3)
> Just to clarify: you do this in the Java editor, right?

That's correct.  Refactor menu -> Move.  Select the object I want to move the method to, and hit either preview or OK, then get the error.
Markus Keller 2011-04-07 10:01:51 EDT
Snippet to reproduce (move A#foo(B) to B):

package p;
import com.example.Outer.Inner;
public class A {
	public void foo(B b) {
		Inner<String> i;
	}
}

package p;
public class B {
}

package com.example;
public class Outer {
	public static class Inner<E> {}
}
Markus Keller 2011-04-07 13:52:24 EDT
Created attachment 192766 [details]
Fix
Markus Keller 2011-04-07 13:53:02 EDT
Fixed in HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=328554,328554,P3,JDT,UI,markus.kell.r,RESO,FIXE,[move method] NPE during move method refactoring,2010/11/29,exception,1,1,-,move method,ast rewrite issue,"Bug 328554 - [move method] NPE during move method refactoring
Glenview Jeff 2010-10-24 16:47:20 EDT
Build Identifier: M20090917-0800

Manually (not using refactor assist) move a field F in class A to class B and this field is used by a method in class A.  The method will show an error because it doesn't know .

Then try to use refactor move method from class A to class B.  You'll receive the error ""an unhandled exception occurred while performing the refactoring.""

Reproducible: Always

Steps to Reproduce:
Manually (not using refactor assist) move a field F in class A to class B and this field is used by a method in class A.  The method will show an error because it doesn't know .

Then try to use refactor move method from class A to class B.  You'll receive the error ""an unhandled exception occurred while performing the refactoring.""
Olivier Thomann 2010-10-24 20:23:09 EDT
Would it be possible to get the .log file inside the .metadata folder?
Glenview Jeff 2010-10-25 09:54:44 EDT
Created attachment 181635 [details]
Gzipped log file as requested
Olivier Thomann 2010-10-25 10:02:26 EDT
Ok, this seems to be the problem that you are getting:java.lang.NullPointerException
	at org.eclipse.jdt.internal.corext.dom.Bindings.equals(Bindings.java:78)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor$MethodBodyRewriter.visit(MoveInstanceMethodProcessor.java:632)
	at org.eclipse.jdt.core.dom.SimpleName.accept0(SimpleName.java:148)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2480)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2528)
	at org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2480)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2551)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2480)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor.createMethodBody(MoveInstanceMethodProcessor.java:2055)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor.createMethodCopy(MoveInstanceMethodProcessor.java:2224)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor.createChangeManager(MoveInstanceMethodProcessor.java:1776)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor.checkFinalConditions(MoveInstanceMethodProcessor.java:1270)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:211)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1800)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)

Would it be possible for you to provide a self-containing test that reproduces this issue ?
You are getting a null binding and we need to understand why.
Thanks.
Glenview Jeff 2010-10-25 15:56:08 EDT
Did you attempt to follow my instructions to reproduce?  I noticed that I couldn't reproduce it on Helios, so please make sure to use last year's version.

Thanks,
Jeff
Olivier Thomann 2010-10-26 10:52:16 EDT
(In reply to comment #0)
> Steps to Reproduce:
> Manually (not using refactor assist) move a field F in class A to class B and
> this field is used by a method in class A.  The method will show an error
> because it doesn't know .
> 
> Then try to use refactor move method from class A to class B.  You'll receive
> the error ""an unhandled exception occurred while performing the refactoring.""
Do you mean that you are using refactoring on the code that contains the error reported in the first step ?
Glenview Jeff 2010-10-26 12:21:39 EDT
(In reply to comment #5)
> (In reply to comment #0)
> > Steps to Reproduce:
> > Manually (not using refactor assist) move a field F in class A to class B and
> > this field is used by a method in class A.  The method will show an error
> > because it doesn't know .
> > 
> > Then try to use refactor move method from class A to class B.  You'll receive
> > the error ""an unhandled exception occurred while performing the refactoring.""
> Do you mean that you are using refactoring on the code that contains the error
> reported in the first step ?

Yes.
Olivier Thomann 2010-10-26 17:17:58 EDT
(In reply to comment #4)
> Did you attempt to follow my instructions to reproduce?  I noticed that I
> couldn't reproduce it on Helios, so please make sure to use last year's
> version.
There is no more updates of the 3.5.x stream. Could you please try your test case with 3.6.1?
Thanks.
Olivier Thomann 2010-10-26 20:22:25 EDT
I got this error:

java.lang.NullPointerException
at org.eclipse.jdt.internal.core.search.matching.FieldLocator.reportDeclaration(FieldLocator.java:281)
at org.eclipse.jdt.internal.core.search.matching.FieldLocator.matchReportReference(FieldLocator.java:153)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2219)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2694)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2421)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1673)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1083)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1124)
at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1256)
at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:94)
at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchDeclarations(BasicSearchEngine.java:1513)
at org.eclipse.jdt.internal.core.search.BasicSearchEngine.searchDeclarationsOfAccessedFields(BasicSearchEngine.java:1561)
at org.eclipse.jdt.core.search.SearchEngine.searchDeclarationsOfAccessedFields(SearchEngine.java:1120)
at org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.searchReferencedFields(RefactoringSearchEngine2.java:513)
at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:739)
at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor.createChangeManager(MoveInstanceMethodProcessor.java:1778)
at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInstanceMethodProcessor.checkFinalConditions(MoveInstanceMethodProcessor.java:1274)
at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:224)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1975)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)

This is also reproducable in 3.6.1 and HEAD.
I could not reproduce your initial issue.

So you either better describe your steps or you try with 3.6.1 to tell me if you also get it with this build.
Olivier Thomann 2010-10-26 20:26:01 EDT
Created attachment 181792 [details]
Proposed fix

Patch for the second exception since I cannot reproduce the first one.
Glenview Jeff 2010-10-27 09:10:53 EDT
Oliver:

Thanks so much for looking into this.  It's not clear to me what you're doing or asking for.  You've begun to talk about two different exceptions and mentioned that you've been able to reproduce one of them.  I was only reporting one particular bug.  

I believe I described how to reproduce it.  I had asked if you were able to reproduce it using the steps I described with the version of Eclipse I reported.  Have you been able to do this?

Thanks,
Jeff

(In reply to comment #9)
> Created an attachment (id=181792) [details]
> Proposed fix
> 
> Patch for the second exception since I cannot reproduce the first one.
Olivier Thomann 2010-10-27 09:17:16 EDT
(In reply to comment #10)
> I believe I described how to reproduce it.  I had asked if you were able to
> reproduce it using the steps I described with the version of Eclipse I
> reported.  Have you been able to do this?
No, this is too general. Trying to reproduce it I caused another exception which is fixed now.

This is your steps:
<< Manually (not using refactor assist) move a field F in class A to class B and
this field is used by a method in class A.  The method will show an error
because it doesn't know .

Then try to use refactor move method from class A to class B.  You'll receive
the error ""an unhandled exception occurred while performing the refactoring."" >>

It would be easier if you actually describe what you have in A, B,..

So something like this:
1) Create a new Java project
2) Create a class A in this project with the following contents:
....

3) Create a class B in this project with the following contents:
....

4) Go to A and delete the field F.
5) You should see an error ..... at this moment reported again the method .... in A.
6) Select .... and use the Move refactoring to the class B.
7) You should get the exception in the log.

Something like this would let me reproduce this issue more clearly. Hope you can provide such steps for further investigations.
Targetting M4 if I get steps to reproduce this issue.
Olivier Thomann 2010-10-27 09:18:01 EDT
(In reply to comment #11)
> Targetting M4 if I get steps to reproduce this issue.
or 3.6.2 is the problem can be reproduced in 3.6.x since you are getting it inside 3.5.x which doesn't have any further updates.
Olivier Thomann 2010-10-29 11:24:47 EDT
Reproduced.
Investigating.
Olivier Thomann 2010-10-29 11:34:57 EDT
Steps to reproduce:
1) Create a class A with the following contents:
package p;

public class A {
	void foo(B b) {
		int j = i;
		System.out.println(j);
	}
}

2) Create a class B with the following contents:
package p;

public class B {
}
3) Invoke move refactoring on the method foo
4) The exception will be thrown.

There is a missing null check as the binding for 'i' is null.

If you replace foo with:
	void foo(B b) {
		int j = this.i;
		System.out.println(j);
	}
then you would get the exception I got in bug 328786.
Olivier Thomann 2010-10-29 11:41:53 EDT
Created attachment 182058 [details]
Proposed fix

Regression test needs to be added.
Olivier Thomann 2010-10-29 11:48:14 EDT
Moving to JDT/UI
Markus Keller 2010-11-29 13:21:13 EST
Created attachment 184064 [details]
fix and test

Fixes a few more similar cases where missing bindings caused trouble.
Markus Keller 2010-11-29 13:21:51 EST
Fixed in HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=330415,330415,P3,JDT,UI,deepakazad,RESO,FIXE,[inline] Refactor > Inline fails to parenthesize replaced arguments,2010/11/17,behavior change,1,1,arithmetic expression,inline expression,ast rewrite issue,"Bug 330415 - [inline] Refactor > Inline fails to parenthesize replaced arguments
Missing name 2010-11-16 19:07:25 EST
Build Identifier: M20100211-1343

Inlining a subtracted expression produces the wrong result because the refactoring tool fails to parenthesize the arguments.

Example: instead of x - (y + z), you can end up with x - y + z.

(See attached test case).

Reproducible: Always

Steps to Reproduce:
1. Run the test case as-is.
2. Inline each of the functions in main().
3. Run the test case again and observe the difference.
Missing name 2010-11-16 19:08:49 EST
Created attachment 183272 [details]
This is a test case to demonstrate the bug (requires manual steps; see file).
Remy Suen 2010-11-16 19:25:26 EST
Issues with Eclipse's Java tooling goes to JDT.
Deepak Azad 2010-11-17 00:30:14 EST
Created attachment 183275 [details]
fix + tests

It is better to add extra parenthesis in some cases e.g. x + (y + z) , than change the semantics on inlining.
Deepak Azad 2010-11-17 00:30:47 EST
Fixed in HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=314407,314407,P3,JDT,UI,deepakazad,VERI,FIXE,[inline] IndexOutOfBoundsException in inline method refactoring with compile error,2010/9/14,exception,1,1,nan,inline method,Incorrect Type Resolving,"Bug 314407 - [inline] IndexOutOfBoundsException in inline method refactoring with compile error
Ulli Hafner 2010-05-26 04:10:58 EDT
What steps will reproduce the problem?
1. Edit the attached file (it has compile errors)
2. Selected getImage() in line 31
3. Select Inline Method Refactoring
4. Select Replace all invocations
5. Error occurs
6. After saving the file, the error still remains

-- Error Details --
Date: Wed May 26 09:58:21 CEST 2010
Message: Internal Error
Severity: Error
Product: Eclipse SDK 3.6.0.v201005201744 (org.eclipse.sdk.ide)
Plugin: org.eclipse.ltk.ui.refactoring
Session Data:
eclipse.buildId=I20100520-1744
java.version=1.6.0_20
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=linux, ARCH=x86, WS=gtk, NL=en_US
Framework arguments:  --launcher.XXMaxPermSize=256m
Command-line arguments:  -os linux -ws gtk -arch x86 -debug /home/hafner/Documents/eclipse.debug -data /home/hafner/Workspaces/Faktor-Logik --launcher.XXMaxPermSize=256m


Exception Stack Trace:
java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:421)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:330)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:573)
at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:646)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:454)
at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:472)
at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:624)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:234)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1234)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3540)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3159)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
at org.eclipse.jface.window.Window.open(Window.java:801)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:180)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:192)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:115)
at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)
at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startInlineMethodRefactoring(RefactoringExecutionStarter.java:330)
at org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.tryInlineMethod(InlineMethodAction.java:143)
at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:122)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:250)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:498)
at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:185)
at org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:109)
at org.eclipse.core.commands.Command.executeWithChecks(Command.java:476)
at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:508)
at org.eclipse.ui.internal.handlers.HandlerService.executeCommand(HandlerService.java:169)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:468)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:786)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:885)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:567)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:508)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:123)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1525)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1233)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1258)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1243)
at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1270)
at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:729)
at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:2833)
at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:707)
at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:1719)
at org.eclipse.swt.widgets.Control.windowProc(Control.java:4783)
at org.eclipse.swt.widgets.Display.windowProc(Display.java:4358)
at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:8163)
at org.eclipse.swt.widgets.Display.eventProc(Display.java:1239)
at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:2224)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3157)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2629)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2593)
at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2427)
at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:670)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:663)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:115)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:369)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:597)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:619)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:574)
at org.eclipse.equinox.launcher.Main.run(Main.java:1407)
at org.eclipse.equinox.launcher.Main.main(Main.java:1383)
Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
at java.util.ArrayList.RangeCheck(ArrayList.java:547)
at java.util.ArrayList.get(ArrayList.java:322)
at org.eclipse.jdt.core.dom.ASTNode$NodeList.get(ASTNode.java:1211)
at org.eclipse.jdt.internal.corext.refactoring.code.SourceProvider.getParameterData(SourceProvider.java:301)
at org.eclipse.jdt.internal.corext.refactoring.code.CallInliner.computeRealArguments(CallInliner.java:507)
at org.eclipse.jdt.internal.corext.refactoring.code.CallInliner.initialize(CallInliner.java:290)
at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:306)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1975)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Root exception:
java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
at java.util.ArrayList.RangeCheck(ArrayList.java:547)
at java.util.ArrayList.get(ArrayList.java:322)
at org.eclipse.jdt.core.dom.ASTNode$NodeList.get(ASTNode.java:1211)
at org.eclipse.jdt.internal.corext.refactoring.code.SourceProvider.getParameterData(SourceProvider.java:301)
at org.eclipse.jdt.internal.corext.refactoring.code.CallInliner.computeRealArguments(CallInliner.java:507)
at org.eclipse.jdt.internal.corext.refactoring.code.CallInliner.initialize(CallInliner.java:290)
at org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:306)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:209)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1975)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
Ulli Hafner 2010-05-26 04:11:42 EDT
Created attachment 169941 [details]
The file that caused the exception
Olivier Thomann 2010-05-26 10:00:31 EDT
Could you please provide a small project that contains the attached file + all required files that are needed to be able to use the inline refactoring?
As is I cannot invoke the refactoring as the cu contains too many compile errors for types that cannot be resolved.
Olivier Thomann 2010-05-26 10:07:10 EDT
I reproduced it if the only compile error is related to the line:
        return getImage(node.hasUnknownAxioms(property));
Olivier Thomann 2010-05-26 10:28:15 EDT
Moving to JDT/UI. I'll attach a zipped project to reproduce the issue.
Olivier Thomann 2010-05-26 10:29:28 EDT
Created attachment 170003 [details]
Test case.

Import the zipped file as an existing project inside an archive file.
Markus Keller 2010-05-28 09:21:18 EDT
Easier example to reproduce (inline getImage()):

public class Try {
    Object getImage() {
	return null;
    }
    
    Object foo() {
	Object o= getImage();
	return getImage(o); 
    }
}
Deepak Azad 2010-07-21 06:47:20 EDT
Create the following 2 classes in different files and inline getImage(), Select ""All Invocations"" 
=> Invocation with error  in Try is inlined but the one in A is not. This is inconsistent behavior!

public class Try {
    Object getImage(Object o) {
    	return null;
    }

    Object foo() {
    	Object o= getImage();
    	return getImage(o); 
    }
}

class A {
	void foo() {
		new Try().getImage();
	}
}

Reason : The Java search in TargetProvider.MemberTypeTargetProvider.getAffectedCompilationUnits(...) does not matches invocations with compile errors. The invocations with compile errors get added later on using TargetProvider.InvocationFinder, because invocation with compilation error has the same method binding as the declared method but no indication that there is a compilation error.

I really think that JDT core should indicate the presence of an error on a method invocation. The current API does not do that and according to me that is incorrect.
Deepak Azad 2010-08-08 08:08:28 EDT
Created attachment 176108 [details]
fix+tests

Fixed in HEAD.

A method invocation with a compile error has type binding as null. I could use this information to exclude invocations with errors.
Deepak Azad 2010-08-08 08:09:08 EDT
.
Dani Megert 2010-09-14 09:45:38 EDT
Verified in I20100914-0100.
Rajesh 2010-09-14 12:22:43 EDT
Verified for 3.7 M2 with I20100913-1800.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=305103,305103,P3,JDT,UI,raksha.vasisht,VERI,FIXE,[refactoring] Comment deleted on 'Move type to new file' refactoring,2010/8/3,comment related,1,1,comment related,Move member type to new file,ast rewrite issue,"Bug 305103 - [refactoring] Comment deleted on 'Move type to new file' refactoring
Deepak Azad 2010-03-09 01:21:28 EST
For each code snippet below
- Move X to new file (problem is independent creating an instance variable)
- The comment gets deleted. Its neither in new file nor the old file.
- There can be some empty lines between the comment and class X, the comment will still be deleted

However if the comment is a javadoc (begins with /**) then its moved to new file.

Marking as major as there is loss of data and the user may not realize it right away. Also I do not see any junits which test these (comments) cases.

1)
package p;

class A {
	/*
	 * A very important comment.
	 */
	class X {

	}
}

2)
package p;

class A {
	/*
	 * A very important comment.	
	 */
	
	
		
	class X {

	}
	
}

3)
package p;

class A {
	// A very important comment.
	
		
	class X {

	}
	
}

4)
package p;

class A {	
		
	class X {

	}
	// A very important comment.
	
}
5)
package p;

class A {	
		
	class X {

	}	
	/* A very important comment.*/
	
}

6)
package p;

class A {	
		
	class X {

	}	
	/** A very important comment.*/
	
}


Things that work fine -
Javadoc comment before Class X
Empty lines between Class X and the comment when comment occurs after the class

1)
package p;

class A {
	/**
	 * A very important comment.
	 */
	class X {

	}
}
2)
package p;

class A {	
		
	class X {

	}
	
        // A very important comment.
	
}
3)
package p;

class A {	
		
	class X {

	}	
	
        /* A very important comment.*/
	
}

4)
package p;

class A {	
		
	class X {

	}	
	
        /** A very important comment.*/
	
}
Markus Keller 2010-03-10 11:01:06 EST
I don't think that's new (same problem in old refactoring). Raksha, can you please have a look? Maybe we should set a NoCommentSourceRangeComputer or another source range computer to the AST rewrite.
Deepak Azad 2010-03-10 12:18:56 EST
Yes the problem exists in 3.5 as well.

Also the problem is with Secondary types as well. For instance, moving X in the following also deletes the comment.

package p;
class A {    

}

/*
 * A very important comment.    
 */

class X {

}
Markus Keller 2010-04-08 11:08:21 EDT
Probably not for 3.6, waiting on decision in bug 306524.
Raksha Vasisht 2010-06-21 05:58:44 EDT
Created attachment 172314 [details]
Fix for the new CU

Markus, how about using a source range computer even for computing the new source range for the moved CU? This takes the extended range of the declaration node into account rather than just the simple range which helps in copying the comments which belong to the extended range of the node along with the declaration to the new CU. Since deleting the comments from the old CU which belong to the new CU in ASTRewriteAnalyzer is also done using the same source range computer, there wont be any inconsistencies. 

I tried this approach:
ASTNodes.getNodeSource(declaration, true, false), but that returns null in this case

ASTNode root= node.getRoot();
if (root instanceof CompilationUnit) {
			CompilationUnit astRoot= (CompilationUnit) root;
			ITypeRoot typeRoot= astRoot.getTypeRoot();

since the java type root of the astRoot is null.
Markus Keller 2010-06-22 10:41:13 EDT
(In reply to comment #4)
+1, makes sense.
Raksha Vasisht 2010-07-28 13:54:12 EDT
Created attachment 175427 [details]
Fix + tests

Added some tests and adjusted some for the changes in JDT-Core(bug 306524) and UI.
Raksha Vasisht 2010-07-29 04:22:10 EDT
(In reply to comment #6)
> Created an attachment (id=175427) [details] [diff]
> Fix + tests

Committed to HEAD after Ayush committed the fix for bug 306524.
Dani Megert 2010-08-03 03:19:20 EDT
Verified in I20100802-1800.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=29391,29391,P3,JDT,UI,jdt-ui-inbox,RESO,FIXE,[move member type] does not handle visibility of constants [refactoring],2010/7/8,compile error,0,1,nan,pull up field,nan,"Bug 29391 - [move member type] does not handle visibility of constants [refactoring]
Oyvind Harboe 2003-01-13 10:38:31 EST
I'm not sure whether or not this refactoring is supposed to generate code with 
errors.... 

1. Execute ""move to top level"" on TestRefactore->Foo

2. The visibility of ABC is not modified, hence the refactored code does not 
compile.

public class TestRefactor
{
	private final static int ABC=1;

	class Foo
	{
		int foo()
		{
			return  TestRefactor.ABC;
		}
	}
}
Adam Kiezun 2003-02-20 10:06:35 EST
sometimes to avoid generating errors you'd need a lot of analysis

this case we could cover however
you'll get a warning - it'll not modify the visibility of ABC (that's our 
policy)
Adam Kiezun 2003-04-25 12:57:40 EDT
to be investigated
Adam Kiezun 2003-11-10 18:58:07 EST
can't commit to this
Deepak Azad 2010-07-08 15:38:20 EDT
This works in I20100629-0800, visibility of ABC is changed to default.
Marking this as Fixed.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=289655,289655,P3,JDT,UI,markus.kell.r,RESO,FIXE,[rename] Refactor rename in editor is slow with many matches,2010/6/30,bad performance,0,1,nan,rename variable,nan,"Bug 289655 - [rename] Refactor rename in editor is slow with many matches
Kevin Barnes 2009-09-16 16:51:00 EDT
test case: 
public class Test {
    public void test(Object asdf) {
        if (asdf == null) asdf = null;
        if (asdf == null) asdf = null;
        if (asdf == null) asdf = null;
        if (asdf == null) asdf = null;
        if (asdf == null) asdf = null;
        if (asdf == null) asdf = null;
    }
} 

Use Alt-Shift-R refactoring to change the name of asdf variable. Type quickly and you'll notice the editor quickly falls behind your typing.

While investigating this we found that RenameInformationPopup calls updatePopupLocation every time a textChanged or keyPressed event occurs. This means a lot of calls to pack the shell, then update the region and change the shell's height to be one pixel taller.

Resizing the shell less would really improve perfomance here on all platforms.
Markus Keller 2009-09-18 10:18:38 EDT
Fixed in HEAD. What a difference a bit of tracing can make! Thanks for spotting and reporting this blooper.

After I added a cache to avoid unnecessary calls to pack(), the next hot spot was a lot of calls to Shell#setLocation(..), many of which actually didn't change the location at all.

When I added a guard for !loc.equals(shell.getLocation) before actually setting the new location, it became incredibly snappy.

When wrote that code, I probably assumed that setLocation(..) would be cheap if the location does not change (same as Label#setText(..)). But I guess the difference is that the check in Label is really just a cheap String#equals(..), whereas the detection in Shell#setBounds(..) would always need another OS call to fetch the current location.
Markus Keller 2010-06-30 09:06:55 EDT
*** Bug 185050 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=303617,303617,P3,JDT,UI,raksha.vasisht,RESO,FIXE,[extract constant] Refactoring not available on pop-up if selected string is an annotation,2010/6/18,not available,1,1,annotation,extract constant,selection parsing issue,"Bug 303617 - [extract constant] Refactoring not available on pop-up if selected string is an annotation
Neale Upstone 2010-02-23 08:53:23 EST
Build Identifier: 3.5.1

If I select a string that is the value for an annotation, ""Extract constant..."" is available on the Refactor menu, but not on the Shift-Alt-T quick menu.

This is inconsistent, as it is on that menu for string constants outside of annotations.

Reproducible: Always

Steps to Reproduce:
1. Select a string constant within  @Annotation(""string constant"")
2. Press Shift-Alt-T
3. Menu item is not available
Raksha Vasisht 2010-06-17 08:52:29 EDT
Created attachment 172111 [details]
Patch

Added another case for Annotation declarations in RefactoringAvailabilityTester.isExtractConstantAvailable(final JavaTextSelection selection) which checks for SingleMemberAnnotations. Markus, could you pls check if the fix is Ok?
Markus Keller 2010-06-17 13:49:45 EDT
You're on the right track, but you also need to allow NormalAnnotations, e.g. for this:

import java.util.ArrayList;
//@SuppressWarnings(""all"")
//@SuppressWarnings({""all"", ""rawtypes""})
//@SuppressWarnings(value= ""all"")
@SuppressWarnings(value= {""all"", ""rawtypes""})
public class Try extends ArrayList {
}

More changes:
- resolveInAnnotationDeclaration() should be called resolveInAnnotation(). We don't use the term ""annotation declaration"". Either it's an annotation, or it's an annotation type (the latter can also be called a. t. declaration).
- fInAnnotationsRequested and fInAnnotations should be singular
- Javadoc that talks about ""matches the type"" should be ""is of type"", or simply ""is an annotation type"".
- ""if if"" => ""if""
- ""any node in its hierarchy"" is ambiguous (type hierarchy or containment hierarchy?, are children also part of the hierarchy?). Use ""any of its ancestors"".
- since this is a general utility method that can also be used in other situations (e.g. bug 317224), you should allow all 3 kinds of Annotation nodes.
Raksha Vasisht 2010-06-18 03:52:02 EDT
Created attachment 172190 [details]
Patch_v2

Added the other 2 annotation types as well and made the other suggested changes. Markus, could you pls check?
Markus Keller 2010-06-18 09:21:11 EDT
(In reply to comment #3)
Looks good, but I would replace the check in resolveInAnnotation with ""node instanceof Annotation"". That's currently equivalent to testing for all 3 kinds, but it's shorter and it continues to work when another subtype of Annotation is added in the future.
Raksha Vasisht 2010-06-18 12:07:51 EDT
(In reply to comment #4)
> (In reply to comment #3)
> Looks good, but I would replace the check in resolveInAnnotation with ""node
> instanceof Annotation"". That's currently equivalent to testing for all 3 kinds,
> but it's shorter and it continues to work when another subtype of Annotation is
> added in the future.

Done. Released the patch with the above change.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=310867,310867,P2,JDT,Debug,Michael_Rennie,VERI,FIXE,refactoring a member of a class refactors all watchpoints in that class,2010/5/3,breakpoint,1,1,nan,rename field,ast rewrite issue,"Bug 310867 - refactoring a member of a class refactors all watchpoints in that class
Jeremiah Swan 2010-04-28 14:05:23 EDT
Build Identifier: I20100425-2000

Refactoring (renaming) a member of a class appears to refactor all existing watchpoints to reference that refactored member, regardless of what they were originally watching.  Using an IBM JRE160

Reproducible: Always

Steps to Reproduce:
1. Given a simple java class:
package my.test;
public class Foo {
	int a;
	int b;
	int c;
}
2. Create watchpoints for members 'a', 'b', 'c' in class Foo
3. Refactor>Rename... any member in class Foo.  ie: refactor 'a' to become 'd'
4. Note that all watchpoints now reference 'd'
Michael Rennie 2010-04-30 16:21:46 EDT
Created attachment 166677 [details]
fix

the problem was that we never checked for matching watchpoint names when composing rename changes. I also found that we were collecting too many breakpoints - i.e. all Java breakpoint on the resource instead of just watchpoints.
Darin Wright 2010-05-03 11:37:06 EDT
+1 for candidate and patch.
Darin Wright 2010-05-03 11:37:35 EDT
Applied/Fixed.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=308147,308147,P3,JDT,Text,jdt-text-inbox,VERI,FIXE,[BiDi] DBCS3.6: Fail to open rename refactoring popup when renaming Ext-B variants (surrogates),2010/4/30,not available,0,1,nan,rename variable,nan,"Bug 308147 - [BiDi] DBCS3.6: Fail to open rename refactoring popup when renaming Ext-B variants (surrogates)
Masaihko Maedera 2010-04-06 01:19:21 EDT
Build Identifier: I20100330-0800

OS:Windows 7
JRE:IBM JRE 1.6
Locale:Japanese

When renaming variants that contain Ext-B characters with Alt+Shift+R,
Java Editor does not open a hover help that shows more details.

Reproducible: Always

Steps to Reproduce:
1.Import bugXXXX.zip attached to this bug report, which is a Java project. 
2.See screenshot1.png and screenshot2.png
3.Move the cursot on str\u53f1 and press Alt+Shift+R, it is correct.
4.Move the cursot on str\ud842\udf9f and press Alt+Shift+R, it is wrong.
Masaihko Maedera 2010-04-06 01:26:04 EDT
Created attachment 163858 [details]
bug308147.zip, a Java Project with screen shots.
Markus Keller 2010-04-06 10:34:37 EDT
To reproduce, the project encoding must be set to UTF-8.

The problem is that codeSelect(..) doesn't work for the second local variable. The AST is fine in this case.

The missing popup is because we fall back to the 'Rename in File' quick assist in that case (which is sometimes useful when the code is not compiling but should be used here).
Olivier Thomann 2010-04-07 11:55:30 EDT
(In reply to comment #2)
> The problem is that codeSelect(..) doesn't work for the second local variable.
> The AST is fine in this case.
I think the problem comes from the region computation. On the second local variable the region length is 3 and not 4 even if the variable name has 4 characters.
In org.eclipse.jface.text.TextViewerHoverManager#computeInformation()
	final IRegion region= hover.getHoverRegion(fTextViewer, offset);

The region is computed using:
Character.isJavaIdentifierPart(c) to find out if the next character should be included in the region.
This is not that simple when Unicode 4 is involved. This is exactly the case here.
\ud842\udf9f is a high surrogate followed by a low surrogate.
If the first character is within 0xd800 and 0xdbff, then the second part must be within 0xdc00 and 0xdfff.
You can see the way we read the next character in:
org.eclipse.jdt.internal.compiler.parser.Scanner.getNextCharAsJavaIdentifierPart()

We might have a bug in codeSelect(..), but the region's length must be fixed first.
Moving back to JDT/UI for comment.
Markus Keller 2010-04-07 13:14:35 EDT
The fix for bug 308356 solves the steps in comment 0. But the Javadoc hover is still broken for such variables, since the JavaWordFinder does not consider supplementary characters.

Since support for code points has only been added in Java 1.5, the fix needs to implement this manually (like the Scanner in JDT Core).
Markus Keller 2010-04-09 08:55:03 EDT
Original problem is fixed in HEAD, see bug 308612 for the hover.
Masaihko Maedera 2010-04-30 00:54:32 EDT
I verified that this bug is fixed on I20100426-0852.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=307758,307758,P3,JDT,UI,deepakazad,VERI,FIXE,[extract local] Unable to refactor expression without resolved type in variable initializer,2010/4/26,exception,1,1,nan,extract constant,Incorrect Type Resolving,"Bug 307758 - [extract local] Unable to refactor expression without resolved type in variable initializer
Mihai Danila 2010-03-31 12:32:14 EDT
Build Identifier: 20100218-1602

Selection is between ""<"" and "">"". Alt+Shift+L (extract local) here reports ""expression expected"". One should not have to fix the error before refactoring in this manner.

class A {
    public void m() {
        // foo is undeclared.
        int a = <foo + 5>;
    }
}


Reproducible: Always
Mihai Danila 2010-03-31 12:54:29 EDT
Inferred type for such an expression could be derived from the variable being assigned to where possible. The type should be among the editable parts (just like the new local variable name).
Frederic Fusier 2010-03-31 13:02:39 EDT
Move to JDT/UI
Markus Keller 2010-04-01 05:19:03 EDT
This should work when we replace the line
> 		ITypeBinding tb= e.resolveTypeBinding();
in Checks#checkExpressionIsRValue(Expression) with:
>		ITypeBinding tb= ASTResolving.guessBindingForReference(e);
, since ExtractTempRefactoring#createTempType() uses the same utility to infer the type of the variable.

But before we can do that, we need to check and fix the other refactorings that use #checkExpressionIsRValue(..): They all need to use #guessBindingForReference(..) when guess the type.

And we need at least 1 regression test per refactoring.
Deepak Azad 2010-04-17 08:22:04 EDT
Created attachment 165178 [details]
fix

(In reply to comment #3)
> This should work when we replace the line
> > 		ITypeBinding tb= e.resolveTypeBinding();
> in Checks#checkExpressionIsRValue(Expression) with:
> >		ITypeBinding tb= ASTResolving.guessBindingForReference(e);
> , since ExtractTempRefactoring#createTempType() uses the same utility to infer
> the type of the variable.
Replacing the line results in a number of test failures. 

However with the attached patch all tests (AllRefactoringTests.java) pass and the bug here is fixed. Markus, is this good enough?
Deepak Azad 2010-04-19 04:20:03 EDT
(In reply to comment #4)
> Created an attachment (id=165178) [details] [diff]
> fix
> 
> is this good enough?

Probably not..

class A {
    public void m() {
        // foo is undeclared.
        int a = <foo + 5>;
    }
}

'Refactor -> Extract constant' causes an exception

java.lang.NullPointerException
at org.eclipse.jdt.internal.corext.dom.Bindings.normalizeForDeclarationUse(Bindings.java:1011)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.getConstantType(ExtractConstantRefactoring.java:546)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.getConstantTypeName(ExtractConstantRefactoring.java:691)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.getConstantSignaturePreview(ExtractConstantRefactoring.java:426)
at org.eclipse.jdt.internal.ui.refactoring.ExtractConstantWizard$ExtractConstantInputPage.updatePreviewLabel(ExtractConstantWizard.java:240)
at org.eclipse.jdt.internal.ui.refactoring.ExtractConstantWizard$ExtractConstantInputPage.addLabel(ExtractConstantWizard.java:227)
at org.eclipse.jdt.internal.ui.refactoring.ExtractConstantWizard$ExtractConstantInputPage.createControl(ExtractConstantWizard.java:130)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.createContents(RefactoringWizardDialog2.java:631)
at org.eclipse.jface.window.Window.create(Window.java:431)
at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1089)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:171)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:70)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:192)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:115)
at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:38)
at org.eclipse.jdt.ui.actions.ExtractConstantAction.run(ExtractConstantAction.java:85)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:278)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:250)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:498)
at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:584)
at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:501)
at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:411)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:84)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1050)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4039)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2582)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2546)
at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2395)
at org.eclipse.ui.internal.Workbench$7.run(Workbench.java:665)
at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:332)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:658)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:115)
at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:196)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:110)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:79)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:369)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:179)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:48)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:37)
at java.lang.reflect.Method.invoke(Method.java:600)
at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:619)
at org.eclipse.equinox.launcher.Main.basicRun(Main.java:574)
at org.eclipse.equinox.launcher.Main.run(Main.java:1407)
at org.eclipse.equinox.launcher.Main.main(Main.java:1383)
Markus Keller 2010-04-19 05:49:17 EDT
(In reply to comment #5)
> (In reply to comment #4)
> > Created an attachment (id=165178) [details] [diff] [details] [diff]
> > fix
> > 
> > is this good enough?
> 
> Probably not..

It looks good, but you now have to make sure all 3 refactorings use ASTResolving#guessBindingForReference(..) at all places where they need the binding.

Check all places where they call Expression#resolveTypeBinding() now and see whether you can update the code to guess if the resolved type binding is null. Probably extract this into a method per refactoring to avoid code duplication and to make it easier to understand how the checking phase and the change creation are connected (i.e. checking phase guarantees that binding is not null during change creation).
Deepak Azad 2010-04-20 00:01:00 EDT
Created attachment 165365 [details]
fix

Here is a quick stab at it as per comment 6. Existing tests (AllRefactoringTests.java) are green and the exception from comment 5 no longer occurs. I guess some new Tests are needed as well.
Deepak Azad 2010-04-20 15:41:17 EDT
Created attachment 165491 [details]
fix + tests

Added 1 Test for each refactoring.

For Extract Constant and Extract Local variable refactorings the single error is moved from one place to another, however for Introduce Parameter refactoring the single error can move to multiple places. Hence this is not implemented for Introduce Parameter refactoring.

Released to HEAD. Available in builds > I20100420-0800.
Deepak Azad 2010-04-20 15:51:11 EDT
.
Mihai Danila 2010-04-20 16:01:20 EDT
(In reply to comment #9)
> .

;( not implemented?
Deepak Azad 2010-04-20 22:03:42 EDT
(In reply to comment #10)
> (In reply to comment #9)
> > .
> 
> ;( not implemented?

To be more clear, select foo+5 -> Right Click -> Refactor -> 'Extract Local Variable' and 'Extract Constant' will work. However for reasons in comment 8 Introduce Parameter will not.

class A {
    public void m() {
        // foo is undeclared.
        int a = <foo + 5>;
    }
}
Mihai Danila 2010-04-21 08:25:18 EDT
(In reply to comment #11)
> (In reply to comment #10)
> > (In reply to comment #9)
> > > .
> > 
> > ;( not implemented?
> 
> To be more clear, select foo+5 -> Right Click -> Refactor -> 'Extract Local
> Variable' and 'Extract Constant' will work. However for reasons in comment 8
> Introduce Parameter will not.
> 
> class A {
>     public void m() {
>         // foo is undeclared.
>         int a = <foo + 5>;
>     }
> }

One way to address the introduce parameter functionality is to force the user to fix the error prior to committing the operation. Kind of a long shot and it involves alert boxes popping up if the user enters an as-yet-unresolved type, but probably more desirable than the function being unavailable.

Should I make another ticket, or do you feel I'm overshooting here?
Deepak Azad 2010-04-21 08:43:38 EDT
(In reply to comment #12)
> One way to address the introduce parameter functionality is to force the user
> to fix the error prior to committing the operation. Kind of a long shot and it
> involves alert boxes popping up if the user enters an as-yet-unresolved type,
> but probably more desirable than the function being unavailable.
Why not fix the error present (using available quick fixes) and then invoke the Introduce Parameter refactoring? ;-)

> or do you feel I'm overshooting here?
yes :)
Mihai Danila 2010-04-21 09:12:53 EDT
(In reply to comment #13)
> (In reply to comment #12)
> > One way to address the introduce parameter functionality is to force the user
> > to fix the error prior to committing the operation. Kind of a long shot and it
> > involves alert boxes popping up if the user enters an as-yet-unresolved type,
> > but probably more desirable than the function being unavailable.
> Why not fix the error present (using available quick fixes) and then invoke the
> Introduce Parameter refactoring? ;-)
> 
> > or do you feel I'm overshooting here?
> yes :)

Roger. Thanks for the fix! :)
Dani Megert 2010-04-26 06:41:19 EDT
Verified in I20100425-2000 on Windows 7.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=88396,88396,P3,JDT,UI,tobias_widmer,VERI,FIXE,[5.0] [refactoring] [move] Move member type refactoring does not update static import,2010/3/9,compile error,0,1,enum,move member type to new file,nan,"Bug 88396 - [5.0] [refactoring] [move] Move member type refactoring does not update static import
Tim Hanson 2005-03-17 17:35:55 EST
Given the following source file:

package pack;
import static pack.Test.Color.*;

public class Test {
    enum Color {WHITE, BLACK}
    
    public static void main(String[] args) {
        Color c = BLACK;
        switch(c) {
        case BLACK:
            System.out.println(""Black"");
            break;
        case WHITE:
            System.out.println(""White"");
            break;
        }
    }

}

Put the cursor on the definition of ""Color"". Select Refactor -> Move Member Type
to New File. Hit ok.

The static import in Test.java is now squiggled. It still reads:

import static pack.Test.Color.*;

It should read:

import static pack.Color.*;
Tobias Widmer 2005-05-18 12:34:04 EDT
Fixed > 20050518

Filed bug 95794 for related issue
David Saff 2005-05-27 11:12:03 EDT
Verified in I20050527-0010
Didier Loiseau 2010-03-09 05:15:49 EST
Hi,

I still experience this bug in Eclipse 3.5 (build 20090621-0832, Windows XP) when the static import is an exact name import instead of a wildcard import. So replacing the
    import static pack.Test.Color.*;
with
    import static pack.Test.Color.BLACK;
still causes this issue.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=286221,286221,P3,JDT,UI,markus.kell.r,RESO,FIXE,[move method] Move refactoring can produce duplicate methods [refactoring],2009/8/17,compile error,0,1,nan,move method,incorrect implementation,"Bug 286221 - [move method] Move refactoring can produce duplicate methods [refactoring]
Johannes Gebauer 2009-08-11 07:26:19 EDT
Build ID: I20090611-1540

Steps To Reproduce:
Steps To Reproduce:
1. Create the following classes:
public class O {
	private S _s;
	
	public void m(){}
}

public class S {
	public void m(){}
}

2.
Now use the move refactoring to move method O.m to S.

3.
The refactoring performs and produces the compile error without indicating an error status:
Duplicate method m() in type S	S.java



More information:
Markus Keller 2009-08-17 12:40:46 EDT
Fixed in MoveInstanceMethodProcessor.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=280518,280518,P3,JDT,Debug,Michael_Rennie,VERI,FIXE,[breakpoints] [refactoring] method breakpoints all change to one method,2009/6/29,breakpoint,1,1,nan,rename method,ast rewrite issue,"Bug 280518 - [breakpoints] [refactoring] method breakpoints all change to one method
Darin Wright 2009-06-16 16:24:40 EDT
3.5 RC4

Steps:
* using the following source, place a method breakpoint on each method
* select ""methodThree()"" in the editor outline
* refactor its name to ""methodFour()""

result: I end up with three breakpoints on ""methodFour()""

public class MethodTest {
	
	public void methodOne() {
		System.err.println(""one"");
	}
	
	public void methodTwo() {
		System.err.println(""two"");
	}
	
	public void methodThree() {
		System.err.println(""three"");
	}

}
Michael Rennie 2009-06-17 01:13:36 EDT
Also in 3.4.x

the problem is coming from BreakpointRenameMethodParticipant#gatherChanges(..). We should be asking if any of the markers actually reference the original method, but instead all we are doing is asking if the declaring type is the same for each of the method breakpoints - causing all markers to be updated to the new method (methodFour)
Michael Rennie 2009-06-17 01:23:38 EDT
Created attachment 139395 [details]
proposed fix

check that the method name and signature in the marker match the original method name and signature - so we only update method breakpoints actually set on the method being renamed - instead of all method method breakpoints in the type.
Michael Rennie 2009-06-17 01:24:54 EDT
we might consider for 3.5.1 as the fix is small and prevents loss of data (breakpoints and conditional breakpoints).
Michael Rennie 2009-06-29 15:34:56 EDT
applied patch to HEAD, please verify Curtis
Curtis Windatt 2009-06-29 17:09:17 EDT
Verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=20017,20017,P4,JDT,UI,dirk_baeumer,RESO,FIXE,"Self Encapsulate does not work correctly when ""this.field = value"" is used before refactoring [refactoring]",2009/5/4,compile error,0,1,nan,Self Encapsulate field,nan,"Bug 20017 - Self Encapsulate does not work correctly when ""this.field = value"" is used before refactoring [refactoring]
Zoltan Luspai 2002-06-12 10:13:35 EDT
As an example I start with this class:

public class Test {
	
	private Object obj;

	public Test (Object obj) {
		this.obj = obj;
	}

}

Then apply the ""Self Encapsulate"" refactoring on the obj field, which results:

public class Test {
	
	private Object obj;

	public Test (Object obj) {
		this.getObj() = obj;
	}

	private void setObj(Object obj) {
		this.obj = obj;
	}

	private Object getObj() {
		return obj;
	}

}

The ""this.getObj() = obj;"" in the constructor should be ""setObj(obj);"" 
correctly.

My Eclipse version was: 20020602
Dirk Baeumer 2002-06-12 15:02:43 EDT
The problem is that the left hand side of an assignment in this case isn't a 
name reference. Need to handle this case as well.

May be a candidate for F4 also this coding style isn't very common. Also it 
does the wrong thing there is still undo to revert it back. And it causes a 
compile error.
Dirk Baeumer 2002-06-14 09:53:08 EDT
Wrong code is only generated for type declaring the field (this.field is only 
valid there).
Erich Gamma 2002-06-15 05:03:57 EDT
it is rare and recovery path exists - readme
Dirk Baeumer 2002-07-23 08:27:32 EDT
2.0.1 candidate
Dirk Baeumer 2002-07-30 11:03:56 EDT
*** Bug 20761 has been marked as a duplicate of this bug. ***
Dirk Baeumer 2002-08-05 09:24:10 EDT
Not really critical for 2.0.1. Postpone to 2.1
Dirk Baeumer 2002-08-13 09:53:32 EDT
Reopen bug
Dirk Baeumer 2002-08-13 09:54:15 EDT
Fixed in 2.1 build > 20020813
Dirk Baeumer 2002-08-13 10:11:07 EDT
.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=243101,243101,P3,JDT,UI,markus.kell.r,VERI,FIXE,[extract local] IllegalArgumentException in ExtractTempRefactoring,2008/12/9,exception,1,1,enum,extract variable,ast rewrite issue,"Bug 243101 - [extract local] IllegalArgumentException in ExtractTempRefactoring
Brian Miller 2008-08-04 18:31:15 EDT
Build ID: I20080617-2000   (3.4.0)

Steps To Reproduce:
Please try to extract a temporary from the switch expression.  See crash below.

--------------- Bug.java ------------------
enum Bug { X;
	{
		switch(valueOf(""X"")){
		}
	}
}
-------------------------------------------
java.lang.IllegalArgumentException: Node does not exist
at org.eclipse.jdt.core.dom.rewrite.ListRewrite.insertBefore(ListRewrite.java:207)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.insertAt(ExtractTempRefactoring.java:718)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createAndInsertTempDeclaration(ExtractTempRefactoring.java:646)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.createTempDeclaration(ExtractTempRefactoring.java:738)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.doCreateChange(ExtractTempRefactoring.java:526)
at org.eclipse.jdt.internal.corext.refactoring.code.ExtractTempRefactoring.checkFinalConditions(ExtractTempRefactoring.java:469)
Dani Megert 2008-08-05 04:08:37 EDT
This used to work in 3.3.x. Possible 3.4.1 candidate.
Markus Keller 2008-09-12 13:28:04 EDT
Fixed in HEAD of ExtractTempRefactoring.
Dani Megert 2008-09-19 03:11:19 EDT
*** Bug 247848 has been marked as a duplicate of this bug. ***
Markus Keller 2008-11-06 09:42:31 EST
*** Bug 254449 has been marked as a duplicate of this bug. ***
Markus Keller 2008-11-06 09:45:44 EST
Should fix this for 3.4.2.
Markus Keller 2008-11-06 10:20:43 EST
Created attachment 117206 [details]
Fix for 3.4.2

Same as fix in 3.5M2.
Dani Megert 2008-11-13 09:05:38 EST
Patch is good but removed the line with the  // assert comment.

Committed to R3_4_maintenance.
Dani Megert 2008-12-09 07:28:52 EST
Verified in M20081127-1656 and I20081209-0100.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=74759,74759,P3,JDT,UI,markus.kell.r,VERI,FIXE,[introduce factory] refactoring doesn't work with nested constructors,2008/10/28,compile error,0,1,nested constructor,introduce factory,nan,"Bug 74759 - [introduce factory] refactoring doesn't work with nested constructors
Juan omínguez 2004-09-23 07:29:29 EDT
The nested constructor call in the following code is not refactored correctly:

public class Test 
{
	
public Test(Test tal)
{
	return;
}

public static void main(String[] args)
{
	Test test = new Test(new Test(null)); 
}
}
Markus Keller 2006-06-09 12:05:21 EDT
Result in 3.2 is this:

class Test {
    private Test(Test tal) {
        return;
    }

    public static void main(String[] args) {
        Test test= createTest(new Test());
    }

    public static Test createTest(Test tal) {
        return new Test(tal);
    }
}
Robert M. Fuhrer 2006-06-12 17:11:20 EDT
Interestingly, it doesn't just rewrite the outermost call. Consider this version, with 3 nested calls:

public class Test {
    public Test(Test t) {
	return;
    }

    public static void main(String[] args) {
	Test test= new Test(new Test(new Test(null)));
    }
}

gets rewritten as:

public class Test {
    private Test(Test t) {
	return;
    }

    public static void main(String[] args) {
	Test test= createTest(new Test(createTest(null)));
    }

    public static Test createTest(Test t) {
	return new Test(t);
    }
}

At least this result compiles, unlike the result for the originally posted testcase.
Markus Keller 2008-10-14 08:27:59 EDT
Fixed in HEAD.
Dani Megert 2008-10-28 06:24:28 EDT
Verified in I20081027-1300.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=251572,251572,P3,JDT,UI,daniel_megert,RESO,FIXE,[encapsulate field] encapsulate field refactoring fails with splitted array type,2008/10/22,exception,0,1,nan,encapsulate field,nan,"Bug 251572 - [encapsulate field] encapsulate field refactoring fails with splitted array type
Benjamin Muskalla 2008-10-21 13:32:31 EDT
N20081005-2000

Invoking ""Encapsulate field"" refactoring on the follow snippet leads to an exception.


public class A {
	boolean[] theField[];
}


Exception is:
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.AST.newArrayType(AST.java:1502)
	at org.eclipse.jdt.internal.corext.refactoring.sef.SelfEncapsulateFieldRefactoring.createGetterMethod(SelfEncapsulateFieldRefactoring.java:671)
	at org.eclipse.jdt.internal.corext.refactoring.sef.SelfEncapsulateFieldRefactoring.addGetterSetterChanges(SelfEncapsulateFieldRefactoring.java:581)
	at org.eclipse.jdt.internal.corext.refactoring.sef.SelfEncapsulateFieldRefactoring.checkFinalConditions(SelfEncapsulateFieldRefactoring.java:397)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:85)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:121)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1800)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:121)
	

Not sure if this should be handled gracefully eg. rewriting it as ""boolean[][]"" or just disabling the refactoring.
This may be related to bug 177099
Dani Megert 2008-10-22 11:26:10 EDT
Fixed in HEAD.
Available in builds > N20081021-2000.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=102020,102020,P3,JDT,UI,martinae,VERI,FIXE,[move member type] adds call to uncreated field [refactoring],2008/5/23,compile error,1,1,inner class,Move Member Type to New File,ast rewrite issue,"Bug 102020 - [move member type] adds call to uncreated field [refactoring]
David Saff 2005-06-28 10:31:39 EDT
In I20050627-1435.

Code:

public class Foo {
	private static final class Bar {
		private Class baz() {
			return getClass();
		}
	}

	private void bar() {
		new Bar();
	}
}

Select Bar, and Move Member Type to New File.  The new class created is: 

final class Bar {
	private Class baz() {
		return _foo.getClass();
	}
}

1) The call should simply be getClass(), with no reference to _foo.  (""_"" is the
field prefix set in the Preferences)
Dirk Baeumer 2005-07-11 06:08:11 EDT
Tobias, can you please investigate and check if this is a regression ?
Tobias Widmer 2005-07-12 04:43:40 EDT
Cannot reproduce with 3.0.2. Seems like a regression
Dirk Baeumer 2005-07-12 05:25:33 EDT
Can you please investigate and see how a fix would look like for 3.1.1.
Tobias Widmer 2005-07-12 10:27:49 EDT
The problem occurs with method invocations and field accesses of declaring 
types which are both supertypes of the inner class (Bar) and its enclosing 
class (Foo) (in this case java.lang.Object). The MemberAccessNodeCollector 
only checks whether the declaring type is in the type hierarchy of the 
enclosing type (Foo).

Fix would be to pass in a separate type hierarchy for the inner type (Bar) and 
to check whether the inner type hierarchy does not contain the declaring type 
of #getClass() (java.lang.Object).
Dirk Baeumer 2005-07-12 11:58:31 EDT
To clarify: the problem only occurs when the direct super type of both classes
is the same? How risky is the fix ?
Tobias Widmer 2005-07-13 05:12:02 EDT
It happens with all common super types, which are normally not many. I do not 
see an easy and unrisky fix for 3.1.1.

This bug has been introduced with a fix for a similar problem (don't recall 
exactly which PR). The current implementation is mainly not based on bindings. 
If we try to fix this case, I fear that is opens a lot of new problems.

IMO we should think about a reimplementation
Dirk Baeumer 2005-07-13 06:53:28 EDT
Tobias, as discussed can you investigate what it would mean to implement an
approach that checks whether the method is visible in the hierarchy itself
instead  of in the outer type. That should be easier.
Markus Keller 2006-10-26 06:43:33 EDT
*** Bug 162342 has been marked as a duplicate of this bug. ***
Martin Aeschlimann 2008-02-25 04:21:41 EST
*** Bug 220079 has been marked as a duplicate of this bug. ***
Martin Aeschlimann 2008-05-21 04:29:55 EDT
Created attachment 101200 [details]
patch
Martin Aeschlimann 2008-05-21 04:41:48 EDT
Created attachment 101203 [details]
Minimal patch

Minimal patch, still using type hierarchies. The first patch is more precise and fixes other issues as well (references to outer class of outer). The second patch is just minimal.
Martin Aeschlimann 2008-05-21 04:42:25 EDT
Markus, can you have a look?
Markus Keller 2008-05-21 10:43:35 EDT
(In reply to comment #10)
> Created an attachment (id=101200) [details]
> patch

I've reviewed this patch and give my +1.

A possible code clarification: In createCompilationUnitRewrite(..), move the call to modifyAccessToEnclosingInstance(..) into the ""if (binding != null) {..}"" block and then add the binding to the arguments list of modifyAccessToEnclosingInstance(..). This would make clear that the type binding can never be null.
Martin Aeschlimann 2008-05-21 10:54:43 EDT
Benno, can you review?
Benno Baumgartner 2008-05-21 12:34:16 EDT
(In reply to comment #14)
> Benno, can you review?
> 

Tststs, your new test fails:-) (just a newline too much) 
Besides that: +1 for RC2
Markus Keller 2008-05-21 12:49:22 EDT
(In reply to comment #15)
> Tststs, your new test fails:-) (just a newline too much) 

That's bug 116023, which steps by in every RC cycle :-(
Martin Aeschlimann 2008-05-22 03:41:22 EDT
patch (comment 10) released > 20080522
Martin Aeschlimann 2008-05-23 12:18:49 EDT
verified in I20080523-0100
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=209937,209937,P3,JDT,UI,martinae,VERI,FIXE,[push down] NPE in push down refactoring operation,2008/5/20,exception,1,1,nan,push down method,ast rewrite issue,"Bug 209937 - [push down] NPE in push down refactoring operation
Tod Creasey 2007-11-15 08:46:50 EST
When I attempted to push down a method using the Push Down entry in the refactoring menu I got the following NPE.

STEPS
1) Add the following method to TreeViewer


/* (non-Javadoc)
	 * @see org.eclipse.jface.viewers.AbstractTreeViewer#getChildren(org.eclipse.swt.widgets.Widget, java.lang.Object[])
	 */
	public Item[] getChildren(Widget widget, Object[] elementChildren) {
		Item[] items = super.getChildren(widget,elementChildren);
		if(elementChildren.length == 0 || items.length / elementChildren.length > 5){//Will there be a lot of disposal?
			getTree().removeAll();
			unmapAllElements();
			items =  getChildren(widget);
		}
		return items;
	}

2)  Select push down from the refactor menu in the outline view

3) Click OK on the dialog




!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2007-11-15 08:48:49.894
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:350)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:317)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:580)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:423)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:75)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:115)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.nextOrPreviewPressed(RefactoringWizardDialog2.java:488)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$0(RefactoringWizardDialog2.java:485)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:678)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:227)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:947)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3744)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3355)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:825)
	at org.eclipse.jface.window.Window.open(Window.java:801)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:142)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:154)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:37)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startPushDownRefactoring(RefactoringExecutionStarter.java:421)
	at org.eclipse.jdt.ui.actions.PushDownAction.run(PushDownAction.java:121)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:268)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:244)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:498)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:582)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:499)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:410)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:947)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3744)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3355)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:2395)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:2359)
	at org.eclipse.ui.internal.Workbench.access$4(Workbench.java:2225)
	at org.eclipse.ui.internal.Workbench$4.run(Workbench.java:468)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:288)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:463)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:106)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:193)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:106)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:76)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:362)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:175)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:515)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:455)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1193)
Caused by: org.eclipse.core.runtime.AssertionFailedException: null argument:
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:84)
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:72)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PushDownRefactoringProcessor.getCompilationUnitRewrite(PushDownRefactoringProcessor.java:272)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PushDownRefactoringProcessor.createChangeManager(PushDownRefactoringProcessor.java:722)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PushDownRefactoringProcessor.checkFinalConditions(PushDownRefactoringProcessor.java:456)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:174)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:119)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1798)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
org.eclipse.core.runtime.AssertionFailedException: null argument:
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:84)
	at org.eclipse.core.runtime.Assert.isNotNull(Assert.java:72)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PushDownRefactoringProcessor.getCompilationUnitRewrite(PushDownRefactoringProcessor.java:272)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PushDownRefactoringProcessor.createChangeManager(PushDownRefactoringProcessor.java:722)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PushDownRefactoringProcessor.checkFinalConditions(PushDownRefactoringProcessor.java:456)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:174)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:119)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1798)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Martin Aeschlimann 2007-11-15 09:19:53 EST
What build?
Tod Creasey 2007-11-15 09:27:37 EST
I1107-1330 on Vista
Martin Aeschlimann 2008-05-15 07:17:47 EDT
Created attachment 100407 [details]
patch

Reproduced in I20080513-2000 when there is a binary subclass of TreeViewer.
Martin Aeschlimann 2008-05-15 07:19:35 EDT
Benno, can you review?
Benno Baumgartner 2008-05-15 09:14:26 EDT
+1
Martin Aeschlimann 2008-05-15 09:45:52 EDT
patch released > 20080515
Dani Megert 2008-05-20 03:23:18 EDT
Starting verification...
Dani Megert 2008-05-20 03:26:46 EDT
Verified in 3.4 RC
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=136911,136911,P3,JDT,UI,martinae,RESO,FIXE,[convert local] fails in switch statement [refactoring],2007/11/7,exception,1,1,switch case,convert local variable,ast rewrite issue,"Bug 136911 - [convert local] fails in switch statement [refactoring]
Christopher Ebert 2006-04-15 12:51:12 EDT
Refactoring the following component to promote a local variable to a field fails:
		switch (3) {
		case 3:
			int foo = 3;
			break;
		}
with the following exception in the .metadata/.log:

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2006-04-15 09:22:17.96
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
        at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
        at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:293)
        at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:547)
        at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
        at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:613)
        at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:417)
        at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:409)
        at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:556)
        at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1021)
        at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2867)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2572)
        at org.eclipse.jface.window.Window.runEventLoop(Window.java:809)
        at org.eclipse.jface.window.Window.open(Window.java:787)
        at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
        at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
        at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
        at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
        at org.eclipse.jdt.ui.actions.ConvertLocalToFieldAction.run(ConvertLocalToFieldAction.java:89)
        at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)
        at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)
        at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
        at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
        at org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)
        at org.eclipse.core.commands.Command.execute(Command.java:311)
        at org.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:396)
        at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:459)
        at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:781)
        at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:828)
        at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:550)
        at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:493)
        at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:117)
        at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
        at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1252)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1020)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1045)
        at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1030)
        at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1057)
        at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:621)
        at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:1964)
        at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:560)
        at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:1365)
        at org.eclipse.swt.widgets.Display.windowProc(Display.java:3442)
        at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
        at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:4777)
        at org.eclipse.swt.widgets.Display.eventProc(Display.java:1067)
        at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
        at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:1158)
        at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2570)
        at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)
        at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)
        at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)
        at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
        at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
        at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
        at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:324)
        at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
        at org.eclipse.core.launcher.Main.basicRun(Main.java:278)
        at org.eclipse.core.launcher.Main.run(Main.java:973)
        at org.eclipse.core.launcher.Main.main(Main.java:948)
Caused by: java.lang.ClassCastException
        at org.eclipse.jdt.internal.corext.refactoring.code.PromoteTempToFieldRefactoring.addLocalDeclarationSplit(PromoteTempToFieldRefactoring.java:622)
        at org.eclipse.jdt.internal.corext.refactoring.code.PromoteTempToFieldRefactoring.createChange(PromoteTempToFieldRefactoring.java:484)
        at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:117)
        at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
        at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1721)
        at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
java.lang.ClassCastException
        at org.eclipse.jdt.internal.corext.refactoring.code.PromoteTempToFieldRefactoring.addLocalDeclarationSplit(PromoteTempToFieldRefactoring.java:622)
        at org.eclipse.jdt.internal.corext.refactoring.code.PromoteTempToFieldRefactoring.createChange(PromoteTempToFieldRefactoring.java:484)
        at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:117)
        at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
        at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1721)
        at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
        at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Benjamin Muskalla 2007-11-02 18:05:03 EDT
Created attachment 82009 [details]
patch

Here is a patch+test to make the refactoring work in a switch statement
Martin Aeschlimann 2007-11-07 05:46:49 EST
Released modified patch and went through all other similar places where statements are added to switch blocks > 20071107

Thanks Benjamin!
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=149775,149775,P2,JDT,UI,tobias_widmer,VERI,FIXE,[extract superclass] extract superclass refactor can cause stack overflow in refactored code,2007/5/2,compile error,0,1,super constructor,extract superclass,incorrect implementation,"Bug 149775 - [extract superclass] extract superclass refactor can cause stack overflow in refactored code
Matthew Cooper 2006-07-05 22:00:12 EDT
If i have these 2 classes...

public class ExistingSuper {
    void method() {
        // do something
    }
}

public class Subclass extends ExistingSuper {
    @Override
    void method() {
        super.method();
    }
}

...and I extract a superclass for 'SubClass' and select the method to be moved up to superclass then I get this...

public class Extracted extends ExistingSuper {
    public Extracted() {
        super();
    }
    @Override
    void method() {
        this.method();
    }

}

...which has super.method() replaced with this.method() which causes a stack overflow. It should remain as super.method().
Martin Aeschlimann 2007-02-16 04:08:30 EST
*** Bug 155988 has been marked as a duplicate of this bug. ***
Tobias Widmer 2007-04-23 03:45:41 EDT
Problem is not specific to Extract Supertype. Fix also fixes problem in Pull Up.

Fixed in HEAD.
Benno Baumgartner 2007-05-02 11:24:44 EDT
start verification...
Benno Baumgartner 2007-05-02 11:26:57 EDT
verified in I20070502-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=170239,170239,P2,JDT,UI,tobias_widmer,VERI,FIXE,[extract superclass] IllegalArgumentException during Extract Superclass refactor,2007/5/2,exception,0,1,nan,extract superclass,nan,"Bug 170239 - [extract superclass] IllegalArgumentException during Extract Superclass refactor
kentho_98 2007-01-11 12:47:41 EST
This class will produce an IllegalArgumentException after selecting methods to be removed from the subclass:
import java.io.FilterReader;
import java.io.IOException;
import java.io.Reader;

public class ClassA extends FilterReader {
  public ClassA(Reader in) {   
    super(in);
  }

  @Override
  public int read(char[] cbuf, int off, int len) throws IOException {
    return super.read(cbuf, off, len);
  }
}

Steps to Reproduce:
1- Select the class ""ClassA""
2- Choose ""Refactor|Extract Superclass..."" from the menus.
3- Enter a superclass name, i.e., ""SuperClass""
4- Check the ""read"" method under ""Specify actions for members:""
5- Set the action to ""extract""
6- Click ""Next"".
7- Ensure the ""read"" method is checked.
8- Click ""Next"".

Results:
An error is displayed: ""A fatal error occured while performing the refactoring."", ""An unexpected exception occured while creating a change object. See the error log for details.""

If the ""read"" method does not exist (e.g. substitute ""toString"") then the exception does not occur.
kentho_98 2007-01-11 12:48:16 EST
Error Log:
eclipse.buildId=M20060921-0945
java.version=1.6.0
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=en_US
Command-line arguments:  -os win32 -ws win32 -arch x86

Error
Thu Jan 11 10:34:43 MST 2007
Internal Error

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:350)
	at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:851)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:571)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:414)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:75)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:115)
	at org.eclipse.jdt.internal.ui.refactoring.PullUpMethodPage.getNextPage(PullUpMethodPage.java:441)
	at org.eclipse.jface.wizard.WizardDialog.nextPressed(WizardDialog.java:751)
	at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:351)
	at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:660)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:928)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3348)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2968)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:820)
	at org.eclipse.jface.window.Window.open(Window.java:796)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:132)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:145)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startExtractSupertypeRefactoring(RefactoringExecutionStarter.java:343)
	at org.eclipse.jdt.internal.ui.actions.ExtractSuperTypeAction.run(ExtractSuperTypeAction.java:157)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:271)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)
	at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:229)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:234)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:539)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:928)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3348)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2968)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1914)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1878)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:149)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:177)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:280)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: java.lang.IllegalArgumentException: Start node is not a original child of the given list
	at org.eclipse.jdt.internal.core.dom.rewrite.RewriteEventStore.createRangeCopy(RewriteEventStore.java:582)
	at org.eclipse.jdt.core.dom.rewrite.ListRewrite.createTargetNode(ListRewrite.java:304)
	at org.eclipse.jdt.core.dom.rewrite.ListRewrite.createCopyTarget(ListRewrite.java:330)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor$PullUpAstNodeMapper.visit(PullUpRefactoringProcessor.java:232)
	at org.eclipse.jdt.core.dom.SuperMethodInvocation.accept0(SuperMethodInvocation.java:236)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
	at org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:135)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2536)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.copyBodyOfPulledUpMethod(PullUpRefactoringProcessor.java:941)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createNewMethodDeclarationNode(PullUpRefactoringProcessor.java:1254)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1103)
	at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:711)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.checkFinalConditions(ExtractSupertypeProcessor.java:218)
	at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:175)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:118)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
kentho_98 2007-01-11 12:49:31 EST
Eclipse Configuration Details:
*** Date: Thu Jan 11 10:41:25 MST 2007

*** Platform Details:

*** System properties:
awt.toolkit=sun.awt.windows.WToolkit
eclipse.buildId=M20060921-0945
eclipse.commands=-os
win32
-ws
win32
-arch
x86
-launcher
C:\eclipse\eclipse.exe
-name
Eclipse
-showsplash
600
-exitdata
540_74
-vm
C:\WINDOWS\system32\javaw.exe
eclipse.ee.install.verify=false
eclipse.product=org.eclipse.sdk.ide
eclipse.startTime=1168461502532
eclipse.vm=C:\WINDOWS\system32\javaw.exe
eclipse.vmargs=-Xms40m
-Xmx256m
-jar
C:\eclipse\startup.jar
eof=eof
file.encoding=Cp1252
file.encoding.pkg=sun.io
file.separator=\
java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment
java.awt.printerjob=sun.awt.windows.WPrinterJob
java.class.path=C:\eclipse\startup.jar
java.class.version=50.0
java.endorsed.dirs=C:\Program Files\Java\jre1.6.0\lib\endorsed
java.ext.dirs=C:\Program Files\Java\jre1.6.0\lib\ext;C:\WINDOWS\Sun\Java\lib\ext
java.home=C:\Program Files\Java\jre1.6.0
java.io.tmpdir=C:\DOCUME~1\ken\LOCALS~1\Temp\
java.library.path=C:\WINDOWS\system32;.;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\oracle\product\10.2.0\client_1\bin;C:\Program Files\Windows Resource Kits\Tools\;C:\Program Files\TortoiseCVS;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\Program Files\ATI Technologies\ATI Control Panel;C:\Program Files\Microsoft SQL Server\80\Tools\Binn\;C:\Program Files\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\Microsoft SQL Server\90\DTS\Binn\;C:\Program Files\Microsoft SQL Server\90\Tools\Binn\VSShell\Common7\IDE\;C:\Program Files\Microsoft Visual Studio 8\Common7\IDE\PrivateAssemblies\;C:\Program Files\Common Files\Compuware\NMShared;C:\Program Files\Common Files\Compuware\;C:\Program Files\Rational\common
java.runtime.name=Java(TM) SE Runtime Environment
java.runtime.version=1.6.0-b105
java.specification.name=Java Platform API Specification
java.specification.vendor=Sun Microsystems Inc.
java.specification.version=1.6
java.vendor=Sun Microsystems Inc.
java.vendor.url=http://java.sun.com/
java.vendor.url.bug=http://java.sun.com/cgi-bin/bugreport.cgi
java.version=1.6.0
java.vm.info=mixed mode, sharing
java.vm.name=Java HotSpot(TM) Client VM
java.vm.specification.name=Java Virtual Machine Specification
java.vm.specification.vendor=Sun Microsystems Inc.
java.vm.specification.version=1.0
java.vm.vendor=Sun Microsystems Inc.
java.vm.version=1.6.0-b105
line.separator=

org.osgi.framework.bootdelegation=*
org.osgi.framework.executionenvironment=OSGi/Minimum-1.0,OSGi/Minimum-1.1,JRE-1.1,J2SE-1.2,J2SE-1.3,J2SE-1.4,J2SE-1.5,JavaSE-1.6
org.osgi.framework.language=en
org.osgi.framework.os.name=WindowsXP
org.osgi.framework.os.version=5.1
org.osgi.framework.processor=x86
org.osgi.framework.system.packages=javax.accessibility,javax.activity,javax.crypto,javax.crypto.interfaces,javax.crypto.spec,javax.imageio,javax.imageio.event,javax.imageio.metadata,javax.imageio.plugins.bmp,javax.imageio.plugins.jpeg,javax.imageio.spi,javax.imageio.stream,javax.management,javax.management.loading,javax.management.modelmbean,javax.management.monitor,javax.management.openmbean,javax.management.relation,javax.management.remote,javax.management.remote.rmi,javax.management.timer,javax.naming,javax.naming.directory,javax.naming.event,javax.naming.ldap,javax.naming.spi,javax.net,javax.net.ssl,javax.print,javax.print.attribute,javax.print.attribute.standard,javax.print.event,javax.rmi,javax.rmi.CORBA,javax.rmi.ssl,javax.security.auth,javax.security.auth.callback,javax.security.auth.kerberos,javax.security.auth.login,javax.security.auth.spi,javax.security.auth.x500,javax.security.cert,javax.security.sasl,javax.sound.midi,javax.sound.midi.spi,javax.sound.sampled,javax.sound.sampled.spi,javax.sql,javax.sql.rowset,javax.sql.rowset.serial,javax.sql.rowset.spi,javax.swing,javax.swing.border,javax.swing.colorchooser,javax.swing.event,javax.swing.filechooser,javax.swing.plaf,javax.swing.plaf.basic,javax.swing.plaf.metal,javax.swing.plaf.multi,javax.swing.plaf.synth,javax.swing.table,javax.swing.text,javax.swing.text.html,javax.swing.text.html.parser,javax.swing.text.rtf,javax.swing.tree,javax.swing.undo,javax.transaction,javax.transaction.xa,javax.xml,javax.xml.datatype,javax.xml.namespace,javax.xml.parsers,javax.xml.transform,javax.xml.transform.dom,javax.xml.transform.sax,javax.xml.transform.stream,javax.xml.validation,javax.xml.xpath,org.ietf.jgss,org.omg.CORBA,org.omg.CORBA_2_3,org.omg.CORBA_2_3.portable,org.omg.CORBA.DynAnyPackage,org.omg.CORBA.ORBPackage,org.omg.CORBA.portable,org.omg.CORBA.TypeCodePackage,org.omg.CosNaming,org.omg.CosNaming.NamingContextExtPackage,org.omg.CosNaming.NamingContextPackage,org.omg.Dynamic,org.omg.DynamicAny,org.omg.DynamicAny.DynAnyFactoryPackage,org.omg.DynamicAny.DynAnyPackage,org.omg.IOP,org.omg.IOP.CodecFactoryPackage,org.omg.IOP.CodecPackage,org.omg.Messaging,org.omg.PortableInterceptor,org.omg.PortableInterceptor.ORBInitInfoPackage,org.omg.PortableServer,org.omg.PortableServer.CurrentPackage,org.omg.PortableServer.POAManagerPackage,org.omg.PortableServer.POAPackage,org.omg.PortableServer.portable,org.omg.PortableServer.ServantLocatorPackage,org.omg.SendingContext,org.omg.stub.java.rmi,org.w3c.dom,org.w3c.dom.bootstrap,org.w3c.dom.events,org.w3c.dom.ls,org.xml.sax,org.xml.sax.ext,org.xml.sax.helpers
org.osgi.framework.vendor=Eclipse
org.osgi.framework.version=1.3.0
org.osgi.supports.framework.extension=true
os.arch=x86
os.name=Windows XP
os.version=5.1
osgi.arch=x86
osgi.bundles=org.eclipse.equinox.common@2:start, org.eclipse.update.configurator@3:start, org.eclipse.core.runtime@start
osgi.bundlestore=C:\eclipse\configuration\org.eclipse.osgi\bundles
osgi.configuration.area=file:/C:/eclipse/configuration/
osgi.framework=file:/c:/eclipse/plugins/org.eclipse.osgi_3.2.1.R32x_v20060919.jar
osgi.framework.beginningstartlevel=1
osgi.framework.shape=jar
osgi.framework.version=3.2.1.R32x_v20060919
osgi.install.area=file:/C:/eclipse/
osgi.instance.area=file:/C:/dev/
osgi.instance.area.default=file:/C:/Documents and Settings/ken/workspace/
osgi.logfile=C:\dev\.metadata\.log
osgi.manifest.cache=C:\eclipse\configuration\org.eclipse.osgi\manifests
osgi.nl=en_US
osgi.os=win32
osgi.splashLocation=c:\eclipse\plugins\org.eclipse.platform_3.2.0.v20060601\splash.bmp
osgi.splashPath=platform:/base/plugins/org.eclipse.platform
osgi.syspath=c:\eclipse\plugins
osgi.ws=win32
path.separator=;
sun.arch.data.model=32
sun.boot.class.path=C:\Program Files\Java\jre1.6.0\lib\resources.jar;C:\Program Files\Java\jre1.6.0\lib\rt.jar;C:\Program Files\Java\jre1.6.0\lib\sunrsasign.jar;C:\Program Files\Java\jre1.6.0\lib\jsse.jar;C:\Program Files\Java\jre1.6.0\lib\jce.jar;C:\Program Files\Java\jre1.6.0\lib\charsets.jar;C:\Program Files\Java\jre1.6.0\classes
sun.boot.library.path=C:\Program Files\Java\jre1.6.0\bin
sun.cpu.endian=little
sun.cpu.isalist=
sun.desktop=windows
sun.io.unicode.encoding=UnicodeLittle
sun.java.launcher=SUN_STANDARD
sun.jnu.encoding=Cp1252
sun.management.compiler=HotSpot Client Compiler
sun.os.patch.level=Service Pack 2
user.country=US
user.dir=C:\eclipse
user.home=C:\Documents and Settings\ken
user.language=en
user.name=ken
user.timezone=America/Denver
user.variant=
kentho_98 2007-01-11 12:50:25 EST
*** Features:
org.eclipse.cdt (3.1.1.200609270800) ""Eclipse C/C++ Development Tools""
org.eclipse.emf (2.2.1.v200609210005) ""Eclipse Modeling Framework (EMF)""
org.eclipse.emf.ecore.sdo (2.2.0.v200609210005) ""EMF Service Data Objects (SDO)""
org.eclipse.gef (3.2.1.v20060921) ""Graphical Editing Framework""
org.eclipse.jdt (3.2.1.r321_v20060905-R4CM1Znkvre9wC-) ""Eclipse Java Development Tools""
org.eclipse.jdt.source (3.2.1.r321_v20060905-R4CM1Znkvre9wC-) ""Eclipse Java Development Tools SDK""
org.eclipse.jem (1.2.1.v20060815_M----6zXJJzKIRGVU) ""Java EMF Model""
org.eclipse.jst (1.5.1.v200609111510-kW-O_zxPud7GuJG) ""J2EE Standard Tools (JST)""
org.eclipse.pde (3.2.1.r321_v20060823-6vYLLdQ3Nk8DrFG) ""Eclipse Plug-in Development Environment""
org.eclipse.pde.source (3.2.1.r321_v20060823-6vYLLdQ3Nk8DrFG) ""Eclipse Plug-in Development Environment Developer Resources""
org.eclipse.platform (3.2.1.r321_v20060921-b_XVA-INSQSyMtx) ""Eclipse Platform""
org.eclipse.platform.source (3.2.1.r321_v20060921-b_XVA-INSQSyMtx) ""Eclipse Platform Plug-in Developer Resources""
org.eclipse.rcp (3.2.1.r321_v20060801-2ekW2BxmcpPUOoq) ""Eclipse RCP""
org.eclipse.rcp.source (3.2.1.r321_v20060801-2ekW2BxmcpPUOoq) ""Eclipse RCP Plug-in Developer Resources""
org.eclipse.sdk (3.2.1.r321_v20060801-tQ1w49KnTArT0FZ) ""Eclipse Project SDK""
org.eclipse.sdk.examples (3.1.100.v20060609m-JJxMVVx3k78TvON) ""Eclipse SDK Examples""
org.eclipse.ve (1.2.1.v20060817_M-zXJUB0fxM-0vSdc) ""Visual Editor""
org.eclipse.wst (1.5.1.v200609111500-X3TmmF3AeboB5EW) ""Web Standard Tools (WST)""
org.eclipse.xsd (2.2.1.v200609210005) ""XML Schema Infoset Model (XSD)""
kentho_98 2007-01-11 12:52:04 EST
*** Plug-in Registry:
com.ibm.etools.emf.event (3.0.0.v20060918_M) ""Event Model"" [Resolved]
com.ibm.icu (3.4.5) ""International Components for Unicode for Java (ICU4J)"" [Active]
com.ibm.icu.source (3.4.5) ""International Components for Unicode for Java (ICU4J) source plug-in"" [Resolved]
com.jcraft.jsch (0.1.28) ""JSch"" [Resolved]
org.apache.ant (1.6.5) ""Apache Ant"" [Resolved]
org.apache.axis (1.3.0.v200608161946) ""Apache Axis 1.3.0"" [Resolved]
org.apache.cactus (1.7.2.v200606181221) ""Cactus Resource Plug-in"" [Resolved]
org.apache.commons_logging (1.0.4.v200608011657) ""Apache commons logging Plug-in"" [Resolved]
org.apache.jakarta_log4j (1.2.8.v200607172048) ""Apache Jakarta log4j Plug-in"" [Resolved]
org.apache.lucene (1.4.103.v20060601) ""Apache Lucene"" [Resolved]
org.apache.wsil4j (1.0.0.v200608161946) ""Apache WSIL4J 1.0"" [Resolved]
org.apache.xerces (2.8.0.v200606131651) ""Xerces 2.8.0"" [Resolved]
org.eclipse.ant.core (3.1.100.v20060531) ""Ant Build Tool Core"" [Resolved]
org.eclipse.ant.ui (3.2.1.r321_v20060828) ""Ant UI"" [Resolved]
org.eclipse.cdt (3.1.1.200609270800) ""Eclipse C/C++ Development Tools"" [Resolved]
org.eclipse.cdt.core (3.1.1.200609270800) ""C/C++ Development Tools Core"" [Resolved]
org.eclipse.cdt.core.win32 (3.1.1.200609270800) ""C/C++ Development Tools Core for Windows"" [Resolved]
org.eclipse.cdt.debug.core (3.1.1.200609270800) ""C/C++ Development Tools Debug Model"" [Resolved]
org.eclipse.cdt.debug.mi.core (3.1.1.200609270800) ""C/C++ Development Tools GDB/MI CDI Debugger Core"" [Resolved]
org.eclipse.cdt.debug.mi.ui (3.1.1.200609270800) ""C/C++ Development Tools GDB/MI CDI Debugger UI"" [Resolved]
org.eclipse.cdt.debug.ui (3.1.1.200609270800) ""C/C++ Development Tools Debugger UI"" [Resolved]
org.eclipse.cdt.doc.user (3.1.1.200609270800) ""C/C++ Development User Guide"" [Resolved]
org.eclipse.cdt.launch (3.1.1.200609270800) ""C/C++ Development Tools Launching Support"" [Resolved]
org.eclipse.cdt.make.core (3.1.1.200609270800) ""C/C++ Standard make Build Core"" [Resolved]
org.eclipse.cdt.make.ui (3.1.1.200609270800) ""C/C++ Standard make Build UI"" [Active]
org.eclipse.cdt.managedbuilder.core (3.1.1.200609270800) ""C/C++ Managed Builder Core"" [Resolved]
org.eclipse.cdt.managedbuilder.gnu.ui (3.1.1.200609270800) ""GNU Managed Build Definitions"" [Resolved]
org.eclipse.cdt.managedbuilder.ui (3.1.1.200609270800) ""C/C++ Managed Builder UI"" [Active]
org.eclipse.cdt.refactoring (3.1.1.200609270800) ""C/C++ Refactoring"" [Resolved]
org.eclipse.cdt.ui (3.1.1.200609270800) ""C/C++ Development Tools UI"" [Resolved]
org.eclipse.compare (3.2.1.M20060711) ""Compare Support"" [Active]
org.eclipse.compare.examples (3.1.100.v20060609) ""Compare Example"" [Resolved]
org.eclipse.compare.examples.xml (3.1.100.v20060609) ""XML Compare Support"" [Resolved]
org.eclipse.core.boot (3.1.100.v20060603) ""Core Boot"" [Resolved]
org.eclipse.core.commands (3.2.0.I20060605-1400) ""Commands"" [Resolved]
org.eclipse.core.contenttype (3.2.0.v20060603) ""Eclipse Content Mechanism"" [Active]
org.eclipse.core.expressions (3.2.1.r321_v20060721) ""Expression Language"" [Active]
org.eclipse.core.filebuffers (3.2.1.r321_v20060721) ""File Buffers"" [Active]
org.eclipse.core.filesystem (1.0.0.v20060603) ""Core File Systems"" [Resolved]
org.eclipse.core.filesystem.win32.x86 (1.0.0.v20060603) ""Core File System for Windows"" [Resolved]
org.eclipse.core.jobs (3.2.0.v20060603) ""Eclipse Jobs Mechanism"" [Active]
org.eclipse.core.resources (3.2.1.R32x_v20060914) ""Core Resource Management"" [Active]
org.eclipse.core.resources.compatibility (3.2.0.v20060603) ""Core Resource Management Compatibility Fragment"" [Resolved]
org.eclipse.core.resources.win32 (3.2.0.v20060603) ""Core Resource Management Win32 Fragment"" [Resolved]
org.eclipse.core.runtime (3.2.0.v20060603) ""Core Runtime"" [Active]
org.eclipse.core.runtime.compatibility (3.1.100.v20060603) ""Core Runtime Plug-in Compatibility"" [Active]
org.eclipse.core.runtime.compatibility.auth (3.2.0.v20060601) ""Authorization Compatibility Plug-in"" [Active]
org.eclipse.core.runtime.compatibility.registry (3.2.1.R32x_v20060907) ""Eclipse Registry Compatibility Fragment"" [Resolved]
org.eclipse.core.variables (3.1.100.v20060605) ""Core Variables"" [Resolved]
org.eclipse.debug.core (3.2.1.v20060823) ""Debug Core"" [Active]
org.eclipse.debug.ui (3.2.1.v20060823) ""Debug UI"" [Active]
org.eclipse.draw2d (3.2.1.v20060921) ""Draw2d"" [Resolved]
org.eclipse.emf (2.2.0.v200609210005) ""Eclipse Modeling Framework (EMF)"" [Resolved]
org.eclipse.emf.ant (2.2.0.v200609210005) ""EMF Ant Tasks"" [Resolved]
org.eclipse.emf.codegen (2.2.1.v200609210005) ""EMF Template Code Generator"" [Resolved]
org.eclipse.emf.codegen.ecore (2.2.1.v200609210005) ""EMF Ecore Code Generation"" [Resolved]
org.eclipse.emf.codegen.ecore.ui (2.2.1.v200609210005) ""EMF Ecore Code Generation UI"" [Resolved]
org.eclipse.emf.codegen.ui (2.1.0.v200609210005) ""EMF Template Code Generator UI"" [Resolved]
org.eclipse.emf.common (2.2.1.v200609210005) ""EMF Common"" [Resolved]
org.eclipse.emf.common.ui (2.2.1.v200609210005) ""EMF Common UI"" [Resolved]
org.eclipse.emf.commonj.sdo (2.1.0.v200609210005) ""CommonJ SDO"" [Resolved]
org.eclipse.emf.converter (2.2.1.v200609210005) ""EMF Model Convert Support"" [Resolved]
org.eclipse.emf.ecore (2.2.1.v200609210005) ""EMF Ecore"" [Resolved]
org.eclipse.emf.ecore.change (2.2.0.v200609210005) ""EMF Ecore Change Model"" [Resolved]
org.eclipse.emf.ecore.change.edit (2.2.0.v200609210005) ""EMF Ecore Change Edit Support"" [Resolved]
org.eclipse.emf.ecore.edit (2.2.0.v200609210005) ""EMF Ecore Edit Support"" [Resolved]
org.eclipse.emf.ecore.editor (2.2.0.v200609210005) ""Sample Ecore Editor"" [Resolved]
org.eclipse.emf.ecore.sdo (2.2.0.v200609210005) ""EMF Service Data Objects (SDO)"" [Resolved]
org.eclipse.emf.ecore.sdo.edit (2.2.0.v200609210005) ""EMF Service Data Objects (SDO) Edit Support"" [Resolved]
org.eclipse.emf.ecore.sdo.editor (2.2.0.v200609210005) ""EMF Service Data Objects (SDO) Editor"" [Resolved]
org.eclipse.emf.ecore.xmi (2.2.1.v200609210005) ""EMF XMI"" [Resolved]
org.eclipse.emf.edit (2.2.1.v200609210005) ""EMF Edit"" [Resolved]
org.eclipse.emf.edit.ui (2.2.0.v200609210005) ""EMF Edit UI"" [Resolved]
org.eclipse.emf.exporter (2.2.0.v200609210005) ""EMF Model Export Support"" [Resolved]
org.eclipse.emf.importer (2.2.1.v200609210005) ""EMF Model Import Support"" [Resolved]
org.eclipse.emf.importer.ecore (2.2.0.v200609210005) ""EMF Ecore Importer"" [Resolved]
org.eclipse.emf.importer.java (2.2.1.v200609210005) ""EMF Annotated Java Importer"" [Resolved]
org.eclipse.emf.importer.rose (2.2.0.v200609210005) ""EMF Rose Importer"" [Resolved]
org.eclipse.emf.mapping (2.2.0.v200609210005) ""EMF Mapping"" [Resolved]
org.eclipse.emf.mapping.ecore2ecore (2.2.0.v200609210005) ""Ecore to Ecore Mapping"" [Resolved]
org.eclipse.emf.mapping.ecore2ecore.editor (2.2.0.v200609210005) ""Ecore to Ecore Mapping Editor"" [Resolved]
org.eclipse.emf.mapping.ecore2xml (2.2.0.v200609210005) ""Ecore to XML Mapping"" [Resolved]
org.eclipse.emf.mapping.ecore2xml.ui (2.2.0.v200609210005) ""Ecore to XML Mapping UI"" [Resolved]
org.eclipse.emf.mapping.ui (2.2.1.v200609210005) ""EMF Mapping UI"" [Resolved]
org.eclipse.emf.mapping.xsd2ecore (2.1.0.v200609210005) ""XSD to Ecore Mapping"" [Resolved]
org.eclipse.emf.mapping.xsd2ecore.editor (2.1.0.v200609210005) ""XSD to Ecore Mapping Editor"" [Resolved]
org.eclipse.equinox.common (3.2.0.v20060603) ""Common Eclipse Runtime"" [Active]
org.eclipse.equinox.preferences (3.2.1.R32x_v20060717) ""Eclipse Preferences Mechanism"" [Active]
org.eclipse.equinox.registry (3.2.1.R32x_v20060814) ""Extension Registry Support"" [Active]
org.eclipse.equinox.servlet.api (1.0.0.v20060601) ""Servlet API"" [Resolved]
org.eclipse.gef (3.2.1.v20060921) ""Graphical Editing Framework"" [Resolved]
org.eclipse.help (3.2.1.R321_v20060920) ""Help System Core"" [Active]
org.eclipse.help.appserver (3.1.100.v20060602) ""Help Application Server"" [Resolved]
org.eclipse.help.base (3.2.1.R321_v20060822) ""Help System Base"" [Resolved]
org.eclipse.help.examples.ex1 (3.1.100.v20060607) ""Online Help Sample"" [Resolved]
org.eclipse.help.ui (3.2.0.v20060602) ""Help System UI"" [Resolved]
org.eclipse.help.webapp (3.2.1.R321_v20060803) ""Help System Webapp"" [Resolved]
org.eclipse.jdt (3.2.1.r321_v20060823) ""Eclipse Java Development Tools"" [Resolved]
org.eclipse.jdt.apt.core (3.2.1.R32x_v20060822-2100) ""Java Annotation Processing Core"" [Active]
org.eclipse.jdt.apt.ui (3.2.1.R32x_v20060822-2100) ""Java Annotation Processing UI"" [Resolved]
org.eclipse.jdt.core (3.2.1.v_677_R32x) ""Java Development Tools Core"" [Active]
org.eclipse.jdt.core.manipulation (1.0.1.r321_v20060721) ""Java Code Manipulation Functionality"" [Active]
org.eclipse.jdt.debug (3.2.1.r321_v20060731) ""JDI Debug Model"" [Active]
org.eclipse.jdt.debug.ui (3.2.1.r321_v20060918) ""JDI Debug UI"" [Active]
org.eclipse.jdt.doc.isv (3.2.1.r321_v20060907) ""Eclipse JDT Plug-in Developer Guide"" [Resolved]
org.eclipse.jdt.doc.user (3.2.0.v20060605-1400) ""Eclipse Java Development User Guide"" [Resolved]
org.eclipse.jdt.junit (3.2.1.r321_v20060810) ""Java Development Tools JUnit support"" [Active]
org.eclipse.jdt.junit.runtime (3.2.1.r321_v20060721) ""Java Development Tools JUnit runtime support"" [Resolved]
org.eclipse.jdt.junit4.runtime (1.0.1.r321_v20060905) ""Java Development Tools JUnit4 runtime support"" [Resolved]
org.eclipse.jdt.launching (3.2.1.r321_v20060731) ""Java Development Tools Launching Support"" [Active]
org.eclipse.jdt.source (3.2.1.r321_v20060905-R4CM1Znkvre9wC-) ""Eclipse Java Development Tools SDK"" [Resolved]
org.eclipse.jdt.ui (3.2.1.r321_v20060907) ""Java Development Tools UI"" [Active]
org.eclipse.jdt.ui.examples.projects (3.1.101.r321_v20060721) ""Java Development Tools Example Projects"" [Resolved]
org.eclipse.jem (1.2.1.v20060918_M) ""Java EMF Model"" [Resolved]
org.eclipse.jem.beaninfo (1.2.0.v20060918_M) ""Java EMF Model BeanInfo (Introspection) Support"" [Resolved]
org.eclipse.jem.proxy (1.2.0.v20060918_M) ""Java EMF Model Proxy Support"" [Resolved]
org.eclipse.jem.ui (1.2.1.v20060918_M) ""Java EMF Model UI"" [Resolved]
org.eclipse.jem.util (1.2.1.v20060918_M) ""Java EMF Model Utilities"" [Resolved]
org.eclipse.jem.workbench (1.2.1.v20060918_M) ""Java EMF Model Workbench Support"" [Resolved]
org.eclipse.jface (3.2.1.M20060908-1000) ""JFace"" [Resolved]
org.eclipse.jface.databinding (1.0.0.I20060605-1400) ""JFace Data Binding"" [Resolved]
org.eclipse.jface.examples.databinding (1.0.0.I20060605-1400) ""JFace Data Binding Examples"" [Resolved]
org.eclipse.jface.text (3.2.1.r321_v20060810) ""JFace Text"" [Resolved]
org.eclipse.jst (1.0.1.v200605040115) ""J2EE Standard Tools (JST)"" [Resolved]
org.eclipse.jst.common.annotations.controller (1.1.1.v200609132124) ""Annotation Controller Plug-in"" [Resolved]
org.eclipse.jst.common.annotations.core (1.1.1.v200609132124) ""Annotation Core Plug-in"" [Resolved]
org.eclipse.jst.common.annotations.ui (1.1.1.v200609132124) ""Annotations UI Plug-in"" [Resolved]
org.eclipse.jst.common.frameworks (1.1.1.v200609132124) ""Integration Plug-in"" [Resolved]
org.eclipse.jst.common.project.facet.core (1.1.0.v200608141517) ""Project Facet Core (Java Support)"" [Resolved]
org.eclipse.jst.ejb.doc.user (1.0.203.v200609221649) ""EJB docs"" [Resolved]
org.eclipse.jst.ejb.ui (1.1.1.v200609132124) ""WTP EJB UI Plug-in"" [Resolved]
org.eclipse.jst.j2ee (1.1.1.v200609221510) ""J2EE Component"" [Resolved]
org.eclipse.jst.j2ee.core (1.1.1.v200609132124) ""J2EE Core Component"" [Resolved]
org.eclipse.jst.j2ee.doc.user (1.0.203.v200609182036) ""J2EE tools documentation"" [Resolved]
org.eclipse.jst.j2ee.ejb (1.1.1.v200609132124) ""EJB component Plug-in"" [Resolved]
org.eclipse.jst.j2ee.ejb.annotation.model (1.1.1.v200609140551) ""EJB Annotation Model Plug-in"" [Resolved]
org.eclipse.jst.j2ee.ejb.annotations.emitter (1.1.1.v200609140551) ""EJB Emitter Plug-in"" [Resolved]
org.eclipse.jst.j2ee.ejb.annotations.ui (1.1.1.v200609070230) ""EJB Annotations Ui Plug-in"" [Resolved]
org.eclipse.jst.j2ee.ejb.annotations.xdoclet (1.1.1.v200609141515) ""Xdoclet Annotations Plug-in"" [Resolved]
org.eclipse.jst.j2ee.infopop (1.0.202.v200609150300) ""J2EE tools infopops"" [Resolved]
org.eclipse.jst.j2ee.jca (1.1.1.v200609132124) ""JCA Plug-in"" [Resolved]
org.eclipse.jst.j2ee.jca.ui (1.1.1.v200609132124) ""WTP JCA UI Plug-in"" [Resolved]
org.eclipse.jst.j2ee.navigator.ui (1.1.1.v200609132124) ""J2EE Extensions to Common Navigator"" [Resolved]
org.eclipse.jst.j2ee.ui (1.1.1.v200609192150) ""WTP J2EE UI Plug-in"" [Resolved]
org.eclipse.jst.j2ee.web (1.1.1.v200609132124) ""Web Plug-in"" [Resolved]
org.eclipse.jst.j2ee.webservice (1.1.1.v200609132124) ""Web Service Plug-in"" [Resolved]
org.eclipse.jst.j2ee.webservice.ui (1.1.1.v200609132124) ""WTP Webservice UI Plug-in"" [Resolved]
org.eclipse.jst.j2ee.xdoclet.runtime (1.1.1.v200609140551) ""XDocletRuntime Plug-in"" [Resolved]
org.eclipse.jst.jsp.core (1.1.100.v200609201330) ""Structured Source JSP Model"" [Active]
org.eclipse.jst.jsp.ui (1.1.100.v200608142042) ""SSE JSP Source Editor"" [Active]
org.eclipse.jst.jsp.ui.infopop (1.0.2.v200605040115) ""JSP tools infopops"" [Resolved]
org.eclipse.jst.server.core (1.0.103.v20060904b) ""Java Server Support"" [Resolved]
org.eclipse.jst.server.generic.core (1.0.101.v200608301011) ""Generic Server Plugin"" [Resolved]
org.eclipse.jst.server.generic.jboss (1.5.1.v200609140551) ""JBoss Generic server definitions"" [Resolved]
org.eclipse.jst.server.generic.jonas (1.5.0.v200606130315) ""JOnAS Generic Server definitions"" [Resolved]
org.eclipse.jst.server.generic.oc4j (1.5.0.v200606130315) ""Oracle OC4J v10.1.3 DP4 Generic Server Definition Core Plug-in"" [Resolved]
org.eclipse.jst.server.generic.ui (1.0.100.v200608221634) ""Generic Server Plugin UI"" [Resolved]
org.eclipse.jst.server.generic.weblogic (1.5.1.v200609141504) ""Weblogic generic server definitions"" [Resolved]
org.eclipse.jst.server.installable (1.5.1.v20060726) ""Installable servers"" [Resolved]
org.eclipse.jst.server.tomcat.core (1.0.103.v20060904b) ""Apache Tomcat Support"" [Resolved]
org.eclipse.jst.server.tomcat.ui (1.0.103.v20060906) ""Apache Tomcat UI Support"" [Resolved]
org.eclipse.jst.server.ui (1.0.103.v20060809) ""Java Server UI Support"" [Active]
org.eclipse.jst.server.ui.doc.user (1.0.203.v200609221649) ""Server Tools documentation for J2EE Standard Tools"" [Resolved]
org.eclipse.jst.server.ui.infopop (1.0.2.v200605040115) ""Server Tools infopops for J2EE Standard Tools"" [Resolved]
org.eclipse.jst.server.websphere.core (1.0.101.v200609140551) ""WebSphere Generic Server Definition Core Plug-in"" [Resolved]
org.eclipse.jst.servlet.ui (1.1.1.v200609132124) ""WTP Servlet UI Plug-in"" [Resolved]
org.eclipse.jst.servlet.ui.infopop (1.0.201.v200606130315) ""Servlet infopop"" [Resolved]
org.eclipse.jst.ws (1.0.102.v200608302120) ""Web Services"" [Resolved]
org.eclipse.jst.ws.axis.consumption.core (1.0.102.v200608221651) ""Web service Axis Consumption Core"" [Resolved]
org.eclipse.jst.ws.axis.consumption.ui (1.0.102.v200608301709) ""Webservice Axis Consumption UI"" [Resolved]
org.eclipse.jst.ws.axis.creation.ui (1.0.102.v200609081903) ""Webservice Axis Creation UI"" [Resolved]
org.eclipse.jst.ws.axis.infopop (1.0.201.v200605152241) ""Web services Axis UI"" [Resolved]
org.eclipse.jst.ws.axis.ui.doc.user (1.0.203.v200609221649) ""Axis Web services documentation"" [Resolved]
org.eclipse.jst.ws.consumption (1.0.102.v200609220223) ""Web Services Consumption"" [Resolved]
org.eclipse.jst.ws.consumption.infopop (1.0.201.v200605152241) ""Web services UI"" [Resolved]
org.eclipse.jst.ws.consumption.ui (1.0.102.v200609132055) ""Web Services Consumption Graphical User Interface"" [Resolved]
org.eclipse.jst.ws.consumption.ui.doc.user (1.0.202.v200609221649) ""Web service consumption documentation"" [Resolved]
org.eclipse.jst.ws.creation.ejb.ui (1.0.0.v200606130315) ""Web Services Creation EJB Graphical User Interface"" [Resolved]
org.eclipse.jst.ws.creation.ui (1.0.102.v200609062128) ""Web Services Creation Graphical User Interface"" [Resolved]
org.eclipse.jst.ws.doc.user (1.0.203.v200609221649) ""Web Services UI"" [Resolved]
org.eclipse.jst.ws.infopop (1.0.201.v200605162034) ""Web services UI"" [Resolved]
org.eclipse.jst.ws.uddiregistry (1.0.100.v200608221651) ""Web Services Universal Description Discovery and Integration Registry"" [Resolved]
org.eclipse.jst.ws.ui (1.0.101.v200608302120) ""Web Services Graphical User Interface"" [Resolved]
org.eclipse.ltk.core.refactoring (3.2.1.r321_v20060823) ""Refactoring Core"" [Active]
org.eclipse.ltk.ui.refactoring (3.2.1.r321_v20060726) ""Refactoring UI"" [Active]
org.eclipse.osgi.services (3.1.100.v20060601) ""OSGi Release 3 Services"" [Resolved]
org.eclipse.osgi.util (3.1.100.v20060601) ""OSGi R3 Utility Classes"" [Resolved]
org.eclipse.pde (3.2.1.v20060810-0800) ""Eclipse Plug-in Development Environment"" [Resolved]
org.eclipse.pde.build (3.2.1.r321_v20060823) ""Plug-in Development Environment Build Support"" [Resolved]
org.eclipse.pde.core (3.2.1.v20060915-0800) ""Plug-in Development Core"" [Active]
org.eclipse.pde.doc.user (3.2.1.v20060816-0800) ""Eclipse Plug-in Development User Guide"" [Resolved]
org.eclipse.pde.junit.runtime (3.2.0.v20060605) ""PDE JUnit Plug-in Test"" [Resolved]
org.eclipse.pde.runtime (3.2.0.v20060605) ""Plug-in Development Environment Runtime"" [Active]
org.eclipse.pde.source (3.2.1.r321_v20060823-6vYLLdQ3Nk8DrFG) ""Eclipse Plug-in Development Environment Developer Resources"" [Resolved]
org.eclipse.pde.ui (3.2.1.v20060816-0800) ""Plug-in Development UI"" [Active]
org.eclipse.platform (3.2.0.v20060601) ""Eclipse Platform"" [Resolved]
org.eclipse.platform.doc.isv (3.2.1.r321_v2006030) ""Eclipse Platform Plug-in Developer Guide"" [Resolved]
org.eclipse.platform.doc.user (3.2.1.R32x_v200608101155) ""Eclipse Workbench User Guide"" [Resolved]
org.eclipse.platform.source (3.2.1.r321_v20060921-b_XVA-INSQSyMtx) ""Eclipse Platform Plug-in Developer Resources"" [Resolved]
org.eclipse.platform.source.win32.win32.x86 (3.2.1.r321_v20060921-b_XVA-INSQSyMtx) ""Eclipse Platform Plug-in Developer Resources"" [Resolved]
org.eclipse.rcp (3.2.0.v20060605) ""Eclipse RCP"" [Resolved]
org.eclipse.rcp.source (3.2.1.r321_v20060801-2ekW2BxmcpPUOoq) ""Eclipse RCP Plug-in Developer Resources"" [Resolved]
org.eclipse.rcp.source.win32.win32.x86 (3.2.1.r321_v20060801-2ekW2BxmcpPUOoq) ""Eclipse RCP Plug-in Developer Resources"" [Resolved]
org.eclipse.sdk (3.2.1.r321_v20060705) ""Eclipse Project SDK"" [Resolved]
org.eclipse.sdk.examples (3.1.100.v20060609m) ""Eclipse SDK Examples"" [Resolved]
org.eclipse.sdk.examples.source (3.1.100.v20060609m) ""Eclipse Platform Plug-in Developer Resources"" [Resolved]
org.eclipse.sdk.examples.source.win32.win32.x86 (3.1.100.v20060609m) ""Eclipse Platform Plug-in Developer Resources"" [Resolved]
org.eclipse.search (3.2.1.r321_v20060726) ""Search Support"" [Resolved]
org.eclipse.swt (3.2.1.v3235e) ""Standard Widget Toolkit"" [Resolved]
org.eclipse.swt.examples (3.1.100.v3232n) ""SWT Standalone Examples Plugin"" [Resolved]
org.eclipse.swt.examples.browser (3.1.100.v3232n) ""SWT Browser Example Plugin"" [Resolved]
org.eclipse.swt.examples.browser.demos (3.1.100.v3232n) ""SWT Browser Demos Plugin"" [Resolved]
org.eclipse.swt.examples.controls (3.1.100.v3232n) ""SWT Controls Example Plugin"" [Resolved]
org.eclipse.swt.examples.launcher (3.1.100.v3232n) ""SWT Launcher Example Plugin"" [Resolved]
org.eclipse.swt.examples.layouts (3.1.100.v3232n) ""SWT Layout Example Plugin"" [Resolved]
org.eclipse.swt.examples.ole.win32 (3.1.100.v3232n) ""SWT OLE Example Plugin (Win32)"" [Resolved]
org.eclipse.swt.examples.paint (3.1.100.v3232n) ""SWT Paint Example Plugin"" [Resolved]
org.eclipse.swt.win32.win32.x86 (3.2.1.v3235) ""Standard Widget Toolkit for Windows"" [Resolved]
org.eclipse.team.core (3.2.1.M20060711) ""Team Support Core"" [Active]
org.eclipse.team.cvs.core (3.2.1.M200608161750) ""CVS Team Provider Core"" [Resolved]
org.eclipse.team.cvs.ssh (3.2.0.I200606011710) ""CVS SSH Core"" [Resolved]
org.eclipse.team.cvs.ssh2 (3.2.0.I200606051140) ""CVS SSH2"" [Resolved]
org.eclipse.team.cvs.ui (3.2.1.M20060831) ""CVS Team Provider UI"" [Resolved]
org.eclipse.team.examples.filesystem (3.1.101.M20060711) ""Eclipse Team File System Example"" [Active]
org.eclipse.team.ui (3.2.1.M200608151725) ""Team Support UI"" [Active]
org.eclipse.text (3.2.0.v20060605-1400) ""Text"" [Resolved]
org.eclipse.tomcat (4.1.130.v20060601) ""Tomcat Wrapper"" [Resolved]
org.eclipse.ui (3.2.1.M20060913-0800) ""Eclipse UI"" [Active]
org.eclipse.ui.browser (3.2.0.v20060602) ""Browser Support"" [Resolved]
org.eclipse.ui.cheatsheets (3.2.1.R321_v20060720) ""Cheat Sheets"" [Resolved]
org.eclipse.ui.console (3.1.100.v20060605) ""Console"" [Active]
org.eclipse.ui.editors (3.2.1.r321_v20060721) ""Default Text Editor"" [Active]
org.eclipse.ui.examples.fieldassist (1.0.0) ""Field Assist Example"" [Resolved]
org.eclipse.ui.examples.javaeditor (3.1.100.v20060605-1400) ""JFace Text Example"" [Resolved]
org.eclipse.ui.examples.multipageeditor (3.2.0.I20060605-1400) ""Multi-Page Editor Example"" [Resolved]
org.eclipse.ui.examples.propertysheet (3.2.0.I20060605-1400) ""User File Editor"" [Resolved]
org.eclipse.ui.examples.readmetool (3.2.0.I20060605-1400) ""Readme File Editing Tool"" [Active]
org.eclipse.ui.examples.undo (3.2.0.I20060605-1400) ""Undo Example"" [Resolved]
org.eclipse.ui.examples.views.properties.tabbed.article (3.2.0.I20060605-1400) ""Tabbed Properties View Article Example"" [Resolved]
org.eclipse.ui.externaltools (3.1.101.r321_v20060802) ""External Tools"" [Active]
org.eclipse.ui.forms (3.2.0.v20060602) ""Eclipse Forms"" [Resolved]
org.eclipse.ui.ide (3.2.1.M20060915-1030) ""Eclipse IDE UI"" [Active]
org.eclipse.ui.intro (3.2.1.R321_v20060810) ""Welcome Framework"" [Resolved]
org.eclipse.ui.intro.universal (3.2.1.R321_v20060905) ""Universal Welcome"" [Resolved]
org.eclipse.ui.navigator (3.2.1.M20060913-0800) ""Common Navigator View"" [Resolved]
org.eclipse.ui.navigator.resources (3.2.1.M20060906-0800b) ""Navigator Workbench Components"" [Resolved]
org.eclipse.ui.presentations.r21 (3.2.0.I20060605-1400) ""R21 Presentation Plug-in"" [Resolved]
org.eclipse.ui.views (3.2.1.M20060906-0800) ""Views"" [Active]
org.eclipse.ui.views.properties.tabbed (3.2.1.M20060830-0800) ""Tabbed Properties View"" [Resolved]
org.eclipse.ui.win32 (3.2.0.I20060605-1400) ""Eclipse UI Win32 Enhancements"" [Resolved]
org.eclipse.ui.workbench (3.2.1.M20060906-0800) ""Workbench"" [Active]
org.eclipse.ui.workbench.compatibility (3.2.0.I20060605-1400) ""Workbench Compatibility"" [Resolved]
org.eclipse.ui.workbench.texteditor (3.2.0.v20060605-1400) ""Text Editor Framework"" [Active]
org.eclipse.update.configurator (3.2.1.v20092006) ""Install/Update Configurator"" [Active]
org.eclipse.update.core (3.2.1.v20092006) ""Install/Update Core"" [Active]
org.eclipse.update.core.win32 (3.2.1.v20092006) ""Install/Update Core for Windows"" [Resolved]
org.eclipse.update.scheduler (3.2.1.v20092006) ""Automatic Updates Scheduler"" [Active]
org.eclipse.update.ui (3.2.1.v20092006) ""Install/Update UI"" [Resolved]
org.eclipse.ve (1.2.0.v20060518_RC1) ""Visual Editor"" [Resolved]
org.eclipse.ve.cde (1.2.0.v20060918_M) ""Visual Editor Common Data Editor"" [Resolved]
org.eclipse.ve.doc (1.2.0.v20060824_M) ""Visual Editor for Java User Guide"" [Resolved]
org.eclipse.ve.java.core (1.2.1.v20060918_M) ""Visual Editor Java Core"" [Resolved]
org.eclipse.ve.jfc (1.2.1.v20060918_M) ""Visual Editor for Java Foundation Classes"" [Resolved]
org.eclipse.ve.propertysheet (1.2.0.v20060824_M) ""Visual Editor PropertySheet"" [Resolved]
org.eclipse.ve.swt (1.2.1.v20060918_M) ""Visual Editor for Standard Widget Toolkit"" [Resolved]
org.eclipse.wst (1.0.1.v200605040144) ""Web Standard Tools (WST)"" [Resolved]
org.eclipse.wst.command.env (1.0.102.v200608222020) ""Environment Command Framework (headless)"" [Resolved]
org.eclipse.wst.command.env.core (1.0.101.v200606130645) ""Environment Command Framework (core)"" [Resolved]
org.eclipse.wst.command.env.doc.user (1.5.0.v20060831345) ""Web services Axis Ant task documentation"" [Resolved]
org.eclipse.wst.command.env.infopop (1.0.2.v200605070230) ""Web services UI"" [Resolved]
org.eclipse.wst.command.env.ui (1.0.102.v200608222020) ""Environment Command Framework (GUI)"" [Resolved]
org.eclipse.wst.common.core (1.1.100.v200608220540) ""WST Common Core Plug-in"" [Resolved]
org.eclipse.wst.common.emf (1.1.1.v200609132124) ""EMF Utilities"" [Resolved]
org.eclipse.wst.common.emfworkbench.integration (1.1.1.v200609132124) ""EMF Workbench Edit Plug-in"" [Resolved]
org.eclipse.wst.common.environment (1.0.100.v200608251934) ""Enviornment Plug-in"" [Resolved]
org.eclipse.wst.common.frameworks (1.1.1.v200609132124) ""Common Frameworks"" [Resolved]
org.eclipse.wst.common.frameworks.ui (1.1.1.v200609132124) ""WTP UI Plug-in"" [Resolved]
org.eclipse.wst.common.infopop (1.0.1.v200605270041) ""Common WST infopops"" [Resolved]
org.eclipse.wst.common.modulecore (1.1.1.v200609161502) ""Modulecore Plug-in"" [Resolved]
org.eclipse.wst.common.project.facet.core (1.1.1.v200608112156) ""Project Facet Core"" [Active]
org.eclipse.wst.common.project.facet.ui (1.1.1.v200608112156) ""Project Facet UI"" [Resolved]
org.eclipse.wst.common.snippets (1.1.1.v200609140550) ""Snippets View"" [Resolved]
org.eclipse.wst.common.ui (1.1.100.v200608221521) ""Eclipse Base UI extensions"" [Resolved]
org.eclipse.wst.common.ui.properties (1.0.101.v200609140551) ""Common Properties UI"" [Resolved]
org.eclipse.wst.common.uriresolver (1.1.100.v200609200443) ""Common URI Resolver Framework"" [Resolved]
org.eclipse.wst.css.core (1.1.1.v200609140550) ""Structured Source CSS Model"" [Resolved]
org.eclipse.wst.css.ui (1.0.101.v200609140550) ""SSE CSS Source Editor"" [Resolved]
org.eclipse.wst.datatools.connection.ui.doc.user (1.0.203.v200608310305) ""Data documentation"" [Resolved]
org.eclipse.wst.datatools.data.ui.doc.user (1.0.203.v200608310305) ""Data tools data user interface documentation"" [Resolved]
org.eclipse.wst.datatools.fe.ui.doc.user (1.0.203.v200608310305) ""Data documentation"" [Resolved]
org.eclipse.wst.datatools.server.ui.doc.user (1.0.203.v200608310305) ""Database Explorer documentation"" [Resolved]
org.eclipse.wst.doc.user (1.0.203.v200608231821) ""Master User Doc TOC"" [Resolved]
org.eclipse.wst.dtd.core (1.1.1.v200609210600) ""Structured Source DTD Core"" [Resolved]
org.eclipse.wst.dtd.ui (1.0.101.v200608162201) ""SSE DTD Source Editor"" [Resolved]
org.eclipse.wst.dtd.ui.infopop (1.0.1.v200605040131) ""DTD Editor infopops"" [Resolved]
org.eclipse.wst.dtdeditor.doc.user (1.0.203.v200609221649) ""DTD Editor documentation"" [Resolved]
org.eclipse.wst.html.core (1.1.1.v200609210600) ""Structured Source HTML Model"" [Resolved]
org.eclipse.wst.html.standard.dtds (1.0.1.v200608220315) ""Known DTDs"" [Resolved]
org.eclipse.wst.html.ui (1.0.101.v200608142042) ""HTML UI Source Editor"" [Resolved]
org.eclipse.wst.html.ui.infopop (1.0.1.v200605040131) ""HTML editor infopops"" [Resolved]
org.eclipse.wst.internet.cache (1.0.102.v200608221746) ""Cache URI Resolver Plug-in"" [Resolved]
org.eclipse.wst.internet.monitor.core (1.0.103.v20060809) ""Monitor"" [Resolved]
org.eclipse.wst.internet.monitor.ui (1.0.103.v20060809) ""TCP/IP Monitor"" [Resolved]
org.eclipse.wst.internet.proxy (1.0.100.v200608221651) ""Internet Proxy Preferences"" [Active]
org.eclipse.wst.internet.proxy.infopop (1.0.0.v200605070230) ""Internet Proxy Infopops"" [Resolved]
org.eclipse.wst.javascript.core (1.0.1.v200609140550) ""Structured Source JavaScript Model"" [Resolved]
org.eclipse.wst.javascript.ui (1.0.1.v200609140551) ""SSE JavaScript Source Editor"" [Resolved]
org.eclipse.wst.javascript.ui.infopop (1.0.1.v200605040131) ""Javascript infopop"" [Resolved]
org.eclipse.wst.rdb.connection.ui (1.0.103.v200608282140) ""RDB Connection.ui"" [Resolved]
org.eclipse.wst.rdb.connection.ui.infopop (1.0.0.v200605040131) ""New Connection wizard infopops"" [Resolved]
org.eclipse.wst.rdb.core (1.1.113.v200609121919) ""RDB Core"" [Resolved]
org.eclipse.wst.rdb.core.ui (1.0.106.v200608212221) ""Core UI plugin"" [Resolved]
org.eclipse.wst.rdb.data.core (1.0.105.v200608142103) ""Data Core Plugin"" [Resolved]
org.eclipse.wst.rdb.data.ui (1.0.109.v200609051822) ""Data UI Plugin"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.db2.iseries (1.0.103.v200609221041) ""DB2 UDB iSeries Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.db2.luw (1.0.106.v200609122026) ""DB2 UDB Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.db2.zseries (1.0.103.v200609221041) ""DB2 UDB Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.derby (1.0.103.v200609221041) ""Derby Database Definition"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.generic.jdbc (1.0.101.v200605040131) ""DBDefinition Generic JDBC Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.informix (1.0.103.v200609122026) ""Informix Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.mysql (1.0.1.v200609221041) ""DBDefinition Mysql Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.oracle (1.0.102.v200609122026) ""Oracle Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.sqlserver (1.0.104.v200609221041) ""SQL Server Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.dbdefinition.sybase (1.0.104.v200609221041) ""Sybase Database Definition Plug-in"" [Resolved]
org.eclipse.wst.rdb.derby (1.0.105.v200608222044) ""RDB Derby Plug-in"" [Resolved]
org.eclipse.wst.rdb.derby.ui (1.0.102.v200608142103) ""RDB Derby Ui Plug-in"" [Resolved]
org.eclipse.wst.rdb.fe.ui (1.0.103.v200608212119) ""FE UI Plug-in"" [Resolved]
org.eclipse.wst.rdb.fe.ui.actions (1.0.102.v200608212119) ""FE Ui Actions Plug-in"" [Resolved]
org.eclipse.wst.rdb.fe.ui.infopop (1.0.0.v200605040131) ""Generate DDL wizard infopops"" [Resolved]
org.eclipse.wst.rdb.models.dbdefinition (1.0.101.v200606130645) ""DBDefinition Model"" [Resolved]
org.eclipse.wst.rdb.models.sql (1.0.103.v200607112303) ""SQLModel Plug-in"" [Resolved]
org.eclipse.wst.rdb.models.sql.edit (1.0.102.v200606130645) ""SQLModel Edit Plug-in"" [Resolved]
org.eclipse.wst.rdb.mysql (1.0.103.v200608222012) ""RDB Mysql Plug-in"" [Resolved]
org.eclipse.wst.rdb.outputview (1.0.106.v200608142103) ""Data Output Plug-in"" [Resolved]
org.eclipse.wst.rdb.outputview.infopop (1.0.0.v200605040131) ""Data Output view infopops"" [Resolved]
org.eclipse.wst.rdb.server.extensions (1.0.104.v200609181831) ""Server Explorer Extensions Plug-in"" [Resolved]
org.eclipse.wst.rdb.server.ui (1.0.108.v200609182107) ""Server Explorer plugin"" [Resolved]
org.eclipse.wst.rdb.server.ui.infopop (1.0.0.v200605040131) ""Server Explorer view infopops"" [Resolved]
org.eclipse.wst.rdb.sqleditor (1.0.105.v200609192136) ""SQL Source Editor Plugin"" [Resolved]
org.eclipse.wst.rdb.sqleditor.infopop (1.0.0.v200605040131) ""SQL infopops"" [Resolved]
org.eclipse.wst.rdb.sqlscrapbook (1.0.102.v200608220540) ""Sqlscrapbook Plug-in"" [Resolved]
org.eclipse.wst.server.core (1.0.103.v20060920) ""Server Core"" [Resolved]
org.eclipse.wst.server.ui (1.0.103.v20060920) ""Server UI"" [Resolved]
org.eclipse.wst.server.ui.doc.user (1.0.203.v200609221649) ""Server Tools documentation for Web Standard Tools"" [Resolved]
org.eclipse.wst.server.ui.infopop (1.0.3.v200609140551) ""Server Tools infopops for Web Standard Tools"" [Resolved]
org.eclipse.wst.sqleditor.doc.user (1.0.2.v200608310308) ""SQL Editor Documentation"" [Resolved]
org.eclipse.wst.sse.core (1.1.100.v200609182120) ""Structured Text Model"" [Active]
org.eclipse.wst.sse.doc.user (1.0.203.v200608300230) ""Structured text editor and snippets documentation"" [Resolved]
org.eclipse.wst.sse.ui (1.0.200.v200609211325) ""Structured Source Editor"" [Resolved]
org.eclipse.wst.sse.ui.infopop (1.0.101.v200605040131) ""SSE infopops"" [Resolved]
org.eclipse.wst.validation (1.1.1.v200609132124) ""Validation Framework"" [Resolved]
org.eclipse.wst.validation.infopop (1.0.201.v200606130645) ""WST validation infopop plug-in"" [Resolved]
org.eclipse.wst.validation.ui (1.1.1.v200609132124) ""Validation Framework UI"" [Resolved]
org.eclipse.wst.web (1.1.1.v200609132124) ""Simple Web Plug-in"" [Resolved]
org.eclipse.wst.web.ui (1.1.1.v200609132124) ""Simple Web UI Plug-in"" [Resolved]
org.eclipse.wst.web.ui.infopop (1.0.201.v200605070230) ""Static Web infopop"" [Resolved]
org.eclipse.wst.webtools.doc.user (1.0.203.v200609221649) ""Web tools documentation"" [Resolved]
org.eclipse.wst.ws (1.0.101.v200609062128) ""Web Services"" [Resolved]
org.eclipse.wst.ws.explorer (1.0.102.v200609132055) ""Web Services Explorer"" [Resolved]
org.eclipse.wst.ws.infopop (1.0.201.v200605152241) ""Web Services UI"" [Resolved]
org.eclipse.wst.ws.parser (1.0.101.v200609062128) ""Web Services Description Parser"" [Resolved]
org.eclipse.wst.ws.ui (1.0.101.v200608232209) ""Web Services UI"" [Resolved]
org.eclipse.wst.wsdl (1.0.101.v200609141945) ""WSDL Model"" [Resolved]
org.eclipse.wst.wsdl.ui (1.1.100.v200609220004) ""WSDL UI"" [Resolved]
org.eclipse.wst.wsdl.ui.doc.user (1.0.203.v200609221649) ""WSDL Editor Documentation"" [Resolved]
org.eclipse.wst.wsdl.validation (1.1.100.v200608100007) ""WSDL Validator"" [Resolved]
org.eclipse.wst.wsi (1.0.102.v200609101400) ""WSI Conformance Tools"" [Resolved]
org.eclipse.wst.wsi.ui (1.0.101.v20060850312) ""Soap Monitor"" [Resolved]
org.eclipse.wst.wsi.ui.doc.user (1.0.202.v200609221649) ""WS-I Validation Documentation"" [Resolved]
org.eclipse.wst.xml.core (1.1.1.v200609210600) ""Structured Source XML Model"" [Resolved]
org.eclipse.wst.xml.ui (1.0.200.v200609221505) ""XML UI Plugin"" [Resolved]
org.eclipse.wst.xml.ui.infopop (1.0.1.v200605040131) ""XML infopops"" [Resolved]
org.eclipse.wst.xmleditor.doc.user (1.0.203.v200609221649) ""XML editor"" [Resolved]
org.eclipse.wst.xsd.core (1.1.100.v200608112037) ""XSD Core Plugin"" [Resolved]
org.eclipse.wst.xsd.ui (1.1.100.v200609200602) ""XML Schema Editor"" [Resolved]
org.eclipse.wst.xsdeditor.doc.user (1.0.203.v200609221649) ""XML schema editor"" [Resolved]
org.eclipse.xsd (2.2.1.v200609210005) ""XML Schema Infoset Model (XSD)"" [Resolved]
org.eclipse.xsd.ecore.exporter (2.2.1.v200609210005) ""XML Schema Exporter for EMF"" [Resolved]
org.eclipse.xsd.ecore.importer (2.2.0.v200609210005) ""XML Schema Importer for EMF"" [Resolved]
org.eclipse.xsd.edit (2.2.1.v200609210005) ""XML Schema Edit Framework"" [Resolved]
org.eclipse.xsd.editor (2.2.0.v200609210005) ""XML Schema Editor"" [Resolved]
org.junit (3.8.1) ""JUnit Testing Framework"" [Resolved]
org.junit4 (4.1.0.1) ""JUnit Testing Framework Version 4"" [Resolved]
org.uddi4j (2.0.5.v200608231542) ""UDDI4J 2.0.5"" [Resolved]
org.wsdl4j (1.4.0.v200607181917) ""WSDL4J 1.4"" [Resolved]
system.bundle (3.2.1.R32x_v20060919) ""OSGi System Bundle"" [Active]
kentho_98 2007-01-11 12:59:03 EST
*** Current Install Configuration:
Install configuration:
 Last changed on Jan 2, 2007
 Location: file:/C:/eclipse/configuration/org.eclipse.update/platform.xml

 Configured sites:
  platform:/base/

 Configured features:
  ID: org.eclipse.wst.rdb_core.feature, Version: 1.5.1.v200608082030--3YIAAYAeEKFTFU
  ID: org.eclipse.jst.server_userdoc.feature, Version: 1.5.1.v200609111710--0842282A44386A
  ID: org.eclipse.sdk, Version: 3.2.1.r321_v20060705
  ID: org.eclipse.wst.web_userdoc.feature, Version: 1.5.1.v200609111705--1G955G5L9_7IAE
  ID: org.eclipse.wst, Version: 1.0.1.v200605040144
  ID: org.eclipse.jst.server_core.feature, Version: 1.5.1.v200608082030--2PD88P8UBJx787
  ID: org.eclipse.jst.web_userdoc.feature, Version: 1.5.1.v200609111710
  ID: org.apache.axis.feature, Version: 1.3.0.v200606071530--0842282_383A68
  ID: org.eclipse.xsd, Version: 2.2.1.v200609210005
  ID: org.eclipse.emf, Version: 2.2.0.v200609210005
  ID: org.eclipse.wst.rdb_userdoc.feature, Version: 1.5.1.v200609121915--4hNDDhDrSIDSDf
  ID: org.eclipse.wst.server_userdoc.feature, Version: 1.5.1.v200609111645--0842282A44386A
  ID: org.eclipse.wst.xml_userdoc.feature, Version: 1.5.1.v200609111545--3YIAAYAjJGDUPb
  ID: org.eclipse.wst.rdb_adapters.feature, Version: 1.5.1.v200608082030--Cq0bcpdJw4teC8
  ID: org.eclipse.wst.ws_userdoc.feature, Version: 1.5.1.v200609111650--2PD88P8XECCNKM
  ID: org.wsdl4j.feature, Version: 1.4.0.v200606071500--084228293_3A39
  ID: org.eclipse.jst.enterprise_ui.feature, Version: 1.5.1.v200608082030-pEBq_haA1H4sJf6
  ID: org.eclipse.wst.xml_core.feature, Version: 1.5.1.v200608082030--3YIAAYAjGLENFH
  ID: org.eclipse.wst.server_core.feature, Version: 1.5.1.v200608082030------1G955G5L7D
  ID: org.eclipse.wst.common_userdoc.feature, Version: 1.5.1.v200609111555
  ID: org.eclipse.wst.ws_core.feature, Version: 1.5.1.v200608082030--4hNDDhDvGTJSLf
  ID: org.eclipse.jst.enterprise_userdoc.feature, Version: 1.5.1.v200609111710--4hNDDhDwMTJbWt
  ID: org.apache.xerces.feature, Version: 2.8.0.v200605151647--08422828353873
  ID: org.eclipse.pde, Version: 3.2.1.v20060810-0800
  ID: org.eclipse.wst.xml_ui.feature, Version: 1.5.1.v200608300245-zkiCbzU5ZFWEixE
  ID: org.eclipse.jst.enterprise_core.feature, Version: 1.5.1.v200609051533--2PD88P8YAGDADJ
  ID: org.eclipse.emf.ecore.sdo, Version: 2.2.0.v200609210005
  ID: org.eclipse.jst, Version: 1.0.1.v200605040115
  ID: org.eclipse.jem, Version: 1.2.1.v20060918_M
  ID: org.apache.commons_logging.feature, Version: 1.0.4.v200606152055--0842282_233879
  ID: org.eclipse.wst.ws_ui.feature, Version: 1.5.1.v200608082030-hai7DnIyF_GCayN
  ID: org.eclipse.platform, Version: 3.2.0.v20060601
  ID: org.eclipse.jst.common_core.feature, Version: 1.5.1.v200608082030--0842282_363739
  ID: org.eclipse.wst.server_ui.feature, Version: 1.5.1.v200608082030-PGIEUH7RmGdKiHf
  ID: org.eclipse.cdt, Version: 3.1.1.200609270800
  ID: org.eclipse.rcp.source, Version: 3.2.1.r321_v20060801-2ekW2BxmcpPUOoq
  ID: org.eclipse.pde.source, Version: 3.2.1.r321_v20060823-6vYLLdQ3Nk8DrFG
  ID: org.eclipse.jst.server_adapters.feature, Version: 1.5.1.v200608082030--87cMN7NMTv4YPT
  ID: org.eclipse.ve, Version: 1.2.0.v20060518_RC1
  ID: org.eclipse.gef, Version: 3.2.1.v20060921
  ID: org.eclipse.jst.web_ui.feature, Version: 1.5.1.v200608082030--2PD88P8T_IB_EI
  ID: org.eclipse.jst.server_ui.feature, Version: 1.5.1.v200608082030-PGIEUCdEgCIEO8I
  ID: org.eclipse.sdk.examples, Version: 3.1.100.v20060609m
  ID: org.eclipse.jdt.source, Version: 3.2.1.r321_v20060905-R4CM1Znkvre9wC-
  ID: org.eclipse.wst.rdb_ui.feature, Version: 1.5.1.v200608082030-FTMjwT_hp-I8hlV
  ID: org.eclipse.jst.web_core.feature, Version: 1.5.1.v200608082030--87cMN7NRVeVWXd
  ID: org.eclipse.rcp, Version: 3.2.0.v20060605
  ID: org.apache.wsil4j.feature, Version: 1.0.0.v200606071530--0842282_383A68
  ID: org.eclipse.wst.web_core.feature, Version: 1.5.1.v200608082030--4hNDDhDvKRFXQM
  ID: org.eclipse.wst.common_ui.feature, Version: 1.5.1.v200608082030-qKHiTHoXWmGI9-6
  ID: org.eclipse.jdt, Version: 3.2.1.r321_v20060823
  ID: org.uddi4j.feature, Version: 2.0.5.v200609140515--0842282_453764
  ID: org.eclipse.wst.common_core.feature, Version: 1.5.1.v200608082030--AXrVWXWxl-k3-4
  ID: org.eclipse.wst.web_ui.feature, Version: 1.5.1.v200609111705-zjf2SqQuQ3wGZss
  ID: org.eclipse.platform.source, Version: 3.2.1.r321_v20060921-b_XVA-INSQSyMtx
  ID: org.apache.jakarta_log4j.feature, Version: 1.2.8.v200605300321--0842282939426_

 Configured plug-ins:
  file:/C:/eclipse/plugins/com.ibm.etools.emf.event_3.0.0.v20060918_M.jar
  file:/C:/eclipse/plugins/com.ibm.icu.source_3.4.5/
  file:/C:/eclipse/plugins/com.ibm.icu_3.4.5.jar
  file:/C:/eclipse/plugins/com.jcraft.jsch_0.1.28.jar
  file:/C:/eclipse/plugins/org.apache.ant_1.6.5/
  file:/C:/eclipse/plugins/org.apache.axis_1.3.0.v200608161946/
  file:/C:/eclipse/plugins/org.apache.cactus_1.7.2.v200606181221/
  file:/C:/eclipse/plugins/org.apache.commons_logging_1.0.4.v200608011657/
  file:/C:/eclipse/plugins/org.apache.jakarta_log4j_1.2.8.v200607172048/
  file:/C:/eclipse/plugins/org.apache.lucene_1.4.103.v20060601/
  file:/C:/eclipse/plugins/org.apache.wsil4j_1.0.0.v200608161946/
  file:/C:/eclipse/plugins/org.apache.xerces_2.8.0.v200606131651/
  file:/C:/eclipse/plugins/org.eclipse.ant.core_3.1.100.v20060531.jar
  file:/C:/eclipse/plugins/org.eclipse.ant.ui_3.2.1.r321_v20060828.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.core.win32_3.1.1.200609270800/
  file:/C:/eclipse/plugins/org.eclipse.cdt.core_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.debug.core_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.debug.mi.core_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.debug.mi.ui_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.debug.ui_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.doc.user_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.launch_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.make.core_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.make.ui_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.managedbuilder.core_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.managedbuilder.gnu.ui_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.managedbuilder.ui_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.refactoring_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt.ui_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.cdt_3.1.1.200609270800.jar
  file:/C:/eclipse/plugins/org.eclipse.compare.examples.xml_3.1.100.v20060609/
  file:/C:/eclipse/plugins/org.eclipse.compare.examples_3.1.100.v20060609/
  file:/C:/eclipse/plugins/org.eclipse.compare_3.2.1.M20060711.jar
  file:/C:/eclipse/plugins/org.eclipse.core.boot_3.1.100.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.commands_3.2.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.core.contenttype_3.2.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.expressions_3.2.1.r321_v20060721.jar
  file:/C:/eclipse/plugins/org.eclipse.core.filebuffers_3.2.1.r321_v20060721.jar
  file:/C:/eclipse/plugins/org.eclipse.core.filesystem.win32.x86_1.0.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.filesystem_1.0.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.jobs_3.2.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.resources.compatibility_3.2.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.resources.win32_3.2.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.resources_3.2.1.R32x_v20060914.jar
  file:/C:/eclipse/plugins/org.eclipse.core.runtime.compatibility.auth_3.2.0.v20060601.jar
  file:/C:/eclipse/plugins/org.eclipse.core.runtime.compatibility.registry_3.2.1.R32x_v20060907/
  file:/C:/eclipse/plugins/org.eclipse.core.runtime.compatibility_3.1.100.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.runtime_3.2.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.core.variables_3.1.100.v20060605.jar
  file:/C:/eclipse/plugins/org.eclipse.debug.core_3.2.1.v20060823.jar
  file:/C:/eclipse/plugins/org.eclipse.debug.ui_3.2.1.v20060823.jar
  file:/C:/eclipse/plugins/org.eclipse.draw2d_3.2.1.v20060921.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ant_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.codegen.ecore.ui_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.codegen.ecore_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.codegen.ui_2.1.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.codegen_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.common.ui_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.commonj.sdo_2.1.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.common_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.converter_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.change.edit_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.change_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.editor_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.edit_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.sdo.editor_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.sdo.edit_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.sdo_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore.xmi_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.ecore_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.edit.ui_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.edit_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.exporter_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.importer.ecore_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.importer.java_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.importer.rose_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.importer_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.ecore2ecore.editor_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.ecore2ecore_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.ecore2xml.ui_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.ecore2xml_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.ui_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.xsd2ecore.editor_2.1.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping.xsd2ecore_2.1.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf.mapping_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.emf_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.equinox.common_3.2.0.v20060603.jar
  file:/C:/eclipse/plugins/org.eclipse.equinox.preferences_3.2.1.R32x_v20060717.jar
  file:/C:/eclipse/plugins/org.eclipse.equinox.registry_3.2.1.R32x_v20060814.jar
  file:/C:/eclipse/plugins/org.eclipse.equinox.servlet.api_1.0.0.v20060601.jar
  file:/C:/eclipse/plugins/org.eclipse.gef_3.2.1.v20060921.jar
  file:/C:/eclipse/plugins/org.eclipse.help.appserver_3.1.100.v20060602.jar
  file:/C:/eclipse/plugins/org.eclipse.help.base_3.2.1.R321_v20060822.jar
  file:/C:/eclipse/plugins/org.eclipse.help.examples.ex1_3.1.100.v20060607.jar
  file:/C:/eclipse/plugins/org.eclipse.help.ui_3.2.0.v20060602.jar
  file:/C:/eclipse/plugins/org.eclipse.help.webapp_3.2.1.R321_v20060803/
  file:/C:/eclipse/plugins/org.eclipse.help_3.2.1.R321_v20060920.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.apt.core_3.2.1.R32x_v20060822-2100.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.apt.ui_3.2.1.R32x_v20060822-2100.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.core.manipulation_1.0.1.r321_v20060721.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.core_3.2.1.v_677_R32x.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.debug.ui_3.2.1.r321_v20060918.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.debug_3.2.1.r321_v20060731/
  file:/C:/eclipse/plugins/org.eclipse.jdt.doc.isv_3.2.1.r321_v20060907.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.doc.user_3.2.0.v20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.junit.runtime_3.2.1.r321_v20060721/
  file:/C:/eclipse/plugins/org.eclipse.jdt.junit4.runtime_1.0.1.r321_v20060905.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.junit_3.2.1.r321_v20060810/
  file:/C:/eclipse/plugins/org.eclipse.jdt.launching_3.2.1.r321_v20060731.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt.source_3.2.1.r321_v20060905-R4CM1Znkvre9wC-/
  file:/C:/eclipse/plugins/org.eclipse.jdt.ui.examples.projects_3.1.101.r321_v20060721/
  file:/C:/eclipse/plugins/org.eclipse.jdt.ui_3.2.1.r321_v20060907.jar
  file:/C:/eclipse/plugins/org.eclipse.jdt_3.2.1.r321_v20060823.jar
  file:/C:/eclipse/plugins/org.eclipse.jem.beaninfo_1.2.0.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.jem.proxy_1.2.0.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.jem.ui_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.jem.util_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.jem.workbench_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.jem_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.jface.databinding_1.0.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.jface.examples.databinding_1.0.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.jface.text_3.2.1.r321_v20060810.jar
  file:/C:/eclipse/plugins/org.eclipse.jface_3.2.1.M20060908-1000.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.common.annotations.controller_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.common.annotations.core_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.common.annotations.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.common.frameworks_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.common.project.facet.core_1.1.0.v200608141517.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ejb.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ejb.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.core_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.doc.user_1.0.203.v200609182036.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.ejb.annotation.model_1.1.1.v200609140551.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.ejb.annotations.emitter_1.1.1.v200609140551.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.ejb.annotations.ui_1.1.1.v200609070230.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.ejb.annotations.xdoclet_1.1.1.v200609141515.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.ejb_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.infopop_1.0.202.v200609150300.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.jca.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.jca_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.navigator.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.ui_1.1.1.v200609192150.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.webservice.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.webservice_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.web_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee.xdoclet.runtime_1.1.1.v200609140551.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.j2ee_1.1.1.v200609221510.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.jsp.core_1.1.100.v200609201330.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.jsp.ui.infopop_1.0.2.v200605040115.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.jsp.ui_1.1.100.v200608142042.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.core_1.0.103.v20060904b.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.generic.core_1.0.101.v200608301011.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.generic.jboss_1.5.1.v200609140551/
  file:/C:/eclipse/plugins/org.eclipse.jst.server.generic.jonas_1.5.0.v200606130315/
  file:/C:/eclipse/plugins/org.eclipse.jst.server.generic.oc4j_1.5.0.v200606130315/
  file:/C:/eclipse/plugins/org.eclipse.jst.server.generic.ui_1.0.100.v200608221634.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.generic.weblogic_1.5.1.v200609141504/
  file:/C:/eclipse/plugins/org.eclipse.jst.server.installable_1.5.1.v20060726.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.tomcat.core_1.0.103.v20060904b.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.tomcat.ui_1.0.103.v20060906.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.ui.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.ui.infopop_1.0.2.v200605040115.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.ui_1.0.103.v20060809.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.server.websphere.core_1.0.101.v200609140551/
  file:/C:/eclipse/plugins/org.eclipse.jst.servlet.ui.infopop_1.0.201.v200606130315.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.servlet.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.axis.consumption.core_1.0.102.v200608221651.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.axis.consumption.ui_1.0.102.v200608301709.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.axis.creation.ui_1.0.102.v200609081903.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.axis.infopop_1.0.201.v200605152241.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.axis.ui.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.consumption.infopop_1.0.201.v200605152241.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.consumption.ui.doc.user_1.0.202.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.consumption.ui_1.0.102.v200609132055.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.consumption_1.0.102.v200609220223/
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.creation.ejb.ui_1.0.0.v200606130315.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.creation.ui_1.0.102.v200609062128.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.infopop_1.0.201.v200605162034.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.uddiregistry_1.0.100.v200608221651.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws.ui_1.0.101.v200608302120.jar
  file:/C:/eclipse/plugins/org.eclipse.jst.ws_1.0.102.v200608302120.jar
  file:/C:/eclipse/plugins/org.eclipse.jst_1.0.1.v200605040115.jar
  file:/C:/eclipse/plugins/org.eclipse.ltk.core.refactoring_3.2.1.r321_v20060823.jar
  file:/C:/eclipse/plugins/org.eclipse.ltk.ui.refactoring_3.2.1.r321_v20060726.jar
  file:/C:/eclipse/plugins/org.eclipse.osgi.services_3.1.100.v20060601.jar
  file:/C:/eclipse/plugins/org.eclipse.osgi.util_3.1.100.v20060601.jar
  file:/C:/eclipse/plugins/org.eclipse.osgi_3.2.1.R32x_v20060919.jar
  file:/C:/eclipse/plugins/org.eclipse.pde.build_3.2.1.r321_v20060823/
  file:/C:/eclipse/plugins/org.eclipse.pde.core_3.2.1.v20060915-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.pde.doc.user_3.2.1.v20060816-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.pde.junit.runtime_3.2.0.v20060605.jar
  file:/C:/eclipse/plugins/org.eclipse.pde.runtime_3.2.0.v20060605.jar
  file:/C:/eclipse/plugins/org.eclipse.pde.source_3.2.1.r321_v20060823-6vYLLdQ3Nk8DrFG/
  file:/C:/eclipse/plugins/org.eclipse.pde.ui_3.2.1.v20060816-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.pde_3.2.1.v20060810-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.platform.doc.isv_3.2.1.r321_v2006030.jar
  file:/C:/eclipse/plugins/org.eclipse.platform.doc.user_3.2.1.R32x_v200608101155.jar
  file:/C:/eclipse/plugins/org.eclipse.platform.source.win32.win32.x86_3.2.1.r321_v20060921-b_XVA-INSQSyMtx/
  file:/C:/eclipse/plugins/org.eclipse.platform.source_3.2.1.r321_v20060921-b_XVA-INSQSyMtx/
  file:/C:/eclipse/plugins/org.eclipse.platform_3.2.0.v20060601/
  file:/C:/eclipse/plugins/org.eclipse.rcp.source.win32.win32.x86_3.2.1.r321_v20060801-2ekW2BxmcpPUOoq/
  file:/C:/eclipse/plugins/org.eclipse.rcp.source_3.2.1.r321_v20060801-2ekW2BxmcpPUOoq/
  file:/C:/eclipse/plugins/org.eclipse.rcp_3.2.0.v20060605.jar
  file:/C:/eclipse/plugins/org.eclipse.sdk.examples.source.win32.win32.x86_3.1.100.v20060609m/
  file:/C:/eclipse/plugins/org.eclipse.sdk.examples.source_3.1.100.v20060609m/
  file:/C:/eclipse/plugins/org.eclipse.sdk.examples_3.1.100.v20060609m/
  file:/C:/eclipse/plugins/org.eclipse.sdk_3.2.1.r321_v20060705/
  file:/C:/eclipse/plugins/org.eclipse.search_3.2.1.r321_v20060726.jar
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.browser.demos_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.browser_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.controls_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.launcher_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.layouts_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.ole.win32_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples.paint_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.examples_3.1.100.v3232n/
  file:/C:/eclipse/plugins/org.eclipse.swt.win32.win32.x86_3.2.1.v3235.jar
  file:/C:/eclipse/plugins/org.eclipse.swt_3.2.1.v3235e.jar
  file:/C:/eclipse/plugins/org.eclipse.team.core_3.2.1.M20060711.jar
  file:/C:/eclipse/plugins/org.eclipse.team.cvs.core_3.2.1.M200608161750.jar
  file:/C:/eclipse/plugins/org.eclipse.team.cvs.ssh2_3.2.0.I200606051140.jar
  file:/C:/eclipse/plugins/org.eclipse.team.cvs.ssh_3.2.0.I200606011710.jar
  file:/C:/eclipse/plugins/org.eclipse.team.cvs.ui_3.2.1.M20060831.jar
  file:/C:/eclipse/plugins/org.eclipse.team.examples.filesystem_3.1.101.M20060711/
  file:/C:/eclipse/plugins/org.eclipse.team.ui_3.2.1.M200608151725.jar
  file:/C:/eclipse/plugins/org.eclipse.text_3.2.0.v20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.tomcat_4.1.130.v20060601/
  file:/C:/eclipse/plugins/org.eclipse.ui.browser_3.2.0.v20060602.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.cheatsheets_3.2.1.R321_v20060720.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.console_3.1.100.v20060605.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.editors_3.2.1.r321_v20060721.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.fieldassist_1.0.0.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.javaeditor_3.1.100.v20060605-1400/
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.multipageeditor_3.2.0.I20060605-1400/
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.propertysheet_3.2.0.I20060605-1400/
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.readmetool_3.2.0.I20060605-1400/
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.undo_3.2.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.examples.views.properties.tabbed.article_3.2.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.externaltools_3.1.101.r321_v20060802.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.forms_3.2.0.v20060602.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.ide_3.2.1.M20060915-1030.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.intro.universal_3.2.1.R321_v20060905/
  file:/C:/eclipse/plugins/org.eclipse.ui.intro_3.2.1.R321_v20060810.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.navigator.resources_3.2.1.M20060906-0800b.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.navigator_3.2.1.M20060913-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.presentations.r21_3.2.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.views.properties.tabbed_3.2.1.M20060830-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.views_3.2.1.M20060906-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.win32_3.2.0.I20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.workbench.compatibility_3.2.0.I20060605-1400/
  file:/C:/eclipse/plugins/org.eclipse.ui.workbench.texteditor_3.2.0.v20060605-1400.jar
  file:/C:/eclipse/plugins/org.eclipse.ui.workbench_3.2.1.M20060906-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.ui_3.2.1.M20060913-0800.jar
  file:/C:/eclipse/plugins/org.eclipse.update.configurator_3.2.1.v20092006.jar
  file:/C:/eclipse/plugins/org.eclipse.update.core.win32_3.2.1.v20092006.jar
  file:/C:/eclipse/plugins/org.eclipse.update.core_3.2.1.v20092006.jar
  file:/C:/eclipse/plugins/org.eclipse.update.scheduler_3.2.1.v20092006.jar
  file:/C:/eclipse/plugins/org.eclipse.update.ui_3.2.1.v20092006.jar
  file:/C:/eclipse/plugins/org.eclipse.ve.cde_1.2.0.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.ve.doc_1.2.0.v20060824_M.jar
  file:/C:/eclipse/plugins/org.eclipse.ve.java.core_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.ve.jfc_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.ve.propertysheet_1.2.0.v20060824_M.jar
  file:/C:/eclipse/plugins/org.eclipse.ve.swt_1.2.1.v20060918_M.jar
  file:/C:/eclipse/plugins/org.eclipse.ve_1.2.0.v20060518_RC1.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.command.env.core_1.0.101.v200606130645.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.command.env.doc.user_1.5.0.v20060831345.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.command.env.infopop_1.0.2.v200605070230.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.command.env.ui_1.0.102.v200608222020.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.command.env_1.0.102.v200608222020/
  file:/C:/eclipse/plugins/org.eclipse.wst.common.core_1.1.100.v200608220540.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.emfworkbench.integration_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.emf_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.environment_1.0.100.v200608251934.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.frameworks.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.frameworks_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.infopop_1.0.1.v200605270041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.modulecore_1.1.1.v200609161502.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.project.facet.core_1.1.1.v200608112156.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.project.facet.ui_1.1.1.v200608112156.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.snippets_1.1.1.v200609140550.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.ui.properties_1.0.101.v200609140551.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.ui_1.1.100.v200608221521.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.common.uriresolver_1.1.100.v200609200443.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.css.core_1.1.1.v200609140550.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.css.ui_1.0.101.v200609140550.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.datatools.connection.ui.doc.user_1.0.203.v200608310305.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.datatools.data.ui.doc.user_1.0.203.v200608310305.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.datatools.fe.ui.doc.user_1.0.203.v200608310305.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.datatools.server.ui.doc.user_1.0.203.v200608310305.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.doc.user_1.0.203.v200608231821.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.dtd.core_1.1.1.v200609210600.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.dtd.ui.infopop_1.0.1.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.dtd.ui_1.0.101.v200608162201.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.dtdeditor.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.html.core_1.1.1.v200609210600.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.html.standard.dtds_1.0.1.v200608220315.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.html.ui.infopop_1.0.1.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.html.ui_1.0.101.v200608142042.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.internet.cache_1.0.102.v200608221746.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.internet.monitor.core_1.0.103.v20060809.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.internet.monitor.ui_1.0.103.v20060809.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.internet.proxy.infopop_1.0.0.v200605070230.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.internet.proxy_1.0.100.v200608221651.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.javascript.core_1.0.1.v200609140550.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.javascript.ui.infopop_1.0.1.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.javascript.ui_1.0.1.v200609140551.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.connection.ui.infopop_1.0.0.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.connection.ui_1.0.103.v200608282140.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.core.ui_1.0.106.v200608212221/
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.core_1.1.113.v200609121919.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.data.core_1.0.105.v200608142103.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.data.ui_1.0.109.v200609051822.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.db2.iseries_1.0.103.v200609221041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.db2.luw_1.0.106.v200609122026.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.db2.zseries_1.0.103.v200609221041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.derby_1.0.103.v200609221041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.generic.jdbc_1.0.101.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.informix_1.0.103.v200609122026.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.mysql_1.0.1.v200609221041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.oracle_1.0.102.v200609122026.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.sqlserver_1.0.104.v200609221041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.dbdefinition.sybase_1.0.104.v200609221041.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.derby.ui_1.0.102.v200608142103.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.derby_1.0.105.v200608222044.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.fe.ui.actions_1.0.102.v200608212119.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.fe.ui.infopop_1.0.0.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.fe.ui_1.0.103.v200608212119.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.models.dbdefinition_1.0.101.v200606130645.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.models.sql.edit_1.0.102.v200606130645.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.models.sql_1.0.103.v200607112303.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.mysql_1.0.103.v200608222012.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.outputview.infopop_1.0.0.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.outputview_1.0.106.v200608142103/
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.server.extensions_1.0.104.v200609181831/
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.server.ui.infopop_1.0.0.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.server.ui_1.0.108.v200609182107.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.sqleditor.infopop_1.0.0.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.sqleditor_1.0.105.v200609192136/
  file:/C:/eclipse/plugins/org.eclipse.wst.rdb.sqlscrapbook_1.0.102.v200608220540.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.server.core_1.0.103.v20060920.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.server.ui.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.server.ui.infopop_1.0.3.v200609140551.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.server.ui_1.0.103.v20060920.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.sqleditor.doc.user_1.0.2.v200608310308.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.sse.core_1.1.100.v200609182120.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.sse.doc.user_1.0.203.v200608300230.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.sse.ui.infopop_1.0.101.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.sse.ui_1.0.200.v200609211325.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.validation.infopop_1.0.201.v200606130645.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.validation.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.validation_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.web.ui.infopop_1.0.201.v200605070230.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.web.ui_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.webtools.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.web_1.1.1.v200609132124.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.ws.explorer_1.0.102.v200609132055/
  file:/C:/eclipse/plugins/org.eclipse.wst.ws.infopop_1.0.201.v200605152241.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.ws.parser_1.0.101.v200609062128.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.ws.ui_1.0.101.v200608232209.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsdl.ui.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsdl.ui_1.1.100.v200609220004.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsdl.validation_1.1.100.v200608100007.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsdl_1.0.101.v200609141945.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsi.ui.doc.user_1.0.202.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsi.ui_1.0.101.v20060850312.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.wsi_1.0.102.v200609101400.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.ws_1.0.101.v200609062128.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xml.core_1.1.1.v200609210600.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xml.ui.infopop_1.0.1.v200605040131.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xml.ui_1.0.200.v200609221505.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xmleditor.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xsd.core_1.1.100.v200608112037.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xsd.ui_1.1.100.v200609200602.jar
  file:/C:/eclipse/plugins/org.eclipse.wst.xsdeditor.doc.user_1.0.203.v200609221649.jar
  file:/C:/eclipse/plugins/org.eclipse.wst_1.0.1.v200605040144.jar
  file:/C:/eclipse/plugins/org.eclipse.xsd.ecore.exporter_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.xsd.ecore.importer_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.xsd.editor_2.2.0.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.xsd.edit_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.eclipse.xsd_2.2.1.v200609210005.jar
  file:/C:/eclipse/plugins/org.junit4_4.1.0.1/
  file:/C:/eclipse/plugins/org.junit_3.8.1/
  file:/C:/eclipse/plugins/org.uddi4j_2.0.5.v200608231542/
  file:/C:/eclipse/plugins/org.wsdl4j_1.4.0.v200607181917/
Tobias Widmer 2007-04-25 09:51:17 EDT
Fixed in JDT UI HEAD

An additional issue related to the generation of the constructor has been fixed as well.
Benno Baumgartner 2007-05-02 11:07:10 EDT
start verification...
Benno Baumgartner 2007-05-02 11:08:48 EDT
verified in I20070502-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=98475,98475,P3,JDT,UI,martinae,RESO,FIXE,[convert anonymous] forgets to add imports [refactoring],2007/2/16,compile error,0,1,anonymous class,convert anonymous to nested class,nan,"Bug 98475 - [convert anonymous] forgets to add imports [refactoring]
Martin Aeschlimann 2005-06-06 04:08:04 EDT
20050606

use the 'convert anonymous to nested' refactoring on the following code. The
result has unresolvable references to Vector and HashMap.


public class B {
	void foo() {
		new A(null, null) {			
		};
	}	
}

// A.java
import java.util.HashMap;
import java.util.Vector;

class A {
	public A(Vector v, HashMap m) {
	}
}
Martin Aeschlimann 2007-02-16 04:21:03 EST
this got fixed in 3.3
Martin Aeschlimann 2007-02-16 04:21:19 EST
fixed in 3.3.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=169608,169608,P3,JDT,UI,markus.kell.r,VERI,FIXE,[Use supertype] refactoring causes infinite loop with self-referential generic types,2007/1/15,exception,1,1,java generics,Use supertype wherever possible,Incorrect Type Resolving,"Bug 169608 - [Use supertype] refactoring causes infinite loop with self-referential generic types
Ian Robertson 2007-01-04 18:28:59 EST
Build ID: M20060921-0945

Steps To Reproduce:
1. Create A.java with body
  public class A<T extends A<T>> {}
2. Create B.java with body
  public class B<T extends B<T>> extends A<B<T>> {}
3. Create C.java with body:
  public class C extends B<C> {}
4. While in C.java, attempt the ""Use supertype where possible"" refactoring, and select B<T> as the ""supertype to use instead of C"".

A dialog box pops up informing that ""An unexpected exception occurred while performing the refactoring.  See the error log for more details"".


More information:
The error log shows a java.lang.reflect.InvocationTargetException with a root cause of java.lang.StackOverflowError.  The stack overflow stems from an infinite loop of the following seven stack frames:

	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment.createParameterizedType(TypeEnvironment.java:365)
	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment.create(TypeEnvironment.java:182)
	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.HierarchyType.initialize(HierarchyType.java:37)
	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ParameterizedType.initialize(ParameterizedType.java:31)
	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment.createParameterizedType(TypeEnvironment.java:365)
	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment.create(TypeEnvironment.java:182)
	at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.ParameterizedType.initialize(ParameterizedType.java:37)


Placing a breakpoint at org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment [line: 365] - createParameterizedType(ITypeBinding), and displaying the value of the binding variable, I see it toggling between B<C> and A<B<C>>.

It appears that the jdt is getting tripped up because B<C> extends A<B<C>>, which in turn is parameterized by B<C>.
Ian Robertson 2007-01-04 18:31:09 EST
Created attachment 56430 [details]
A simple project which can be used to exhibit the bug.

To reproduce this bug, you can open this project, goto C.java, and attempt the ""Use supertype where possible"" refactoring.
Olivier Thomann 2007-01-04 22:06:50 EST
Move to JDT/UI
Martin Aeschlimann 2007-01-09 06:37:10 EST
Markus, can you have a quick look? This might be a 3.2.2 candidate (deadline today...)
Markus Keller 2007-01-09 12:15:05 EST
Created attachment 56637 [details]
Fix for HEAD

(In reply to comment #0)
> It appears that the jdt is getting tripped up because B<C> extends A<B<C>>,
> which in turn is parameterized by B<C>.

That was indeed the problem.

The fix is basically in TypeEnvironment#createParameterizedType(..). It uses the same pattern as in #createCaptureType(..) to break possible loops safely.
Markus Keller 2007-01-09 13:46:39 EST
Released ""Fix for HEAD"" to HEAD and also to R3_2_maintenance.
Dani Megert 2007-01-15 05:26:48 EST
Starting verification...
Dani Megert 2007-01-15 06:05:39 EST
Verified using M20070112-1200.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=11664,11664,P3,JDT,UI,akiezun,RESO,FIXE,inline temp: incorrect on multi-declarations [refactoring],2006/11/13,compile error,0,1,joint variable declaration,inline local variable,nan,"Bug 11664 - inline temp: incorrect on multi-declarations [refactoring]
Adam Kiezun 2002-03-19 13:16:10 EST
package p;
class A{
	int i(){
		int i= 0, j= 1;
		return i;
	}
}

trying to inline i or j gives incorrect results
Adam Kiezun 2002-05-07 09:19:43 EDT
for now - it's changed so that it does not generate compile errors (20020502)
(by not trying to delete the declaration)
Adam Kiezun 2002-06-09 12:26:37 EDT
LATER
Adam Kiezun 2002-07-18 10:24:46 EDT
needs ast rewriting
Adam Kiezun 2002-08-28 12:04:59 EDT
reop
Adam Kiezun 2002-09-05 09:38:30 EDT
back to 'later'
Adam Kiezun 2003-04-25 10:40:04 EDT
closing - no action planned
Martin Aeschlimann 2006-11-13 10:13:48 EST
reopen
Martin Aeschlimann 2006-11-13 10:14:21 EST
fixed and tests added > 20061113
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=53857,53857,P3,JDT,UI,markus.kell.r,RESO,FIXE,[rename] rename refactoring confused by syntax error,2006/8/3,exception,0,1,nan,rename class,nan,"Bug 53857 - [rename] rename refactoring confused by syntax error
Felix Pahl 2004-03-05 10:01:40 EST
Build id: 200312182000

Test case (with syntax error):

public class Bug {
  void test ()
  {
    new Object () {
      public void yes ()
      {
        System.out.println (""hello world"");
      }
    };
    System.out.println (""hello world"");

    Object object = null;
    Object o = new Object ()
  }
}

1. Select ""object"" and run Refactor:Rename...
   I get a NullPointerException in the Error log; no changes are made.
2. Select ""test"" and run Refactor:Rename...
   You get a meaningful error message.
   Now select ""yes"".
   ""Refactor:Rename..."" is unavailable in the context menu.
   If you run it using the keyboard, you get a different,
   less helpful error message.
   It seems there shouldn't be a difference between the two methods.
   If anything, I would expect ""yes"" to be less affected than ""test""
   since the syntax error is in the latter.
Martin Aeschlimann 2006-08-03 11:46:25 EDT
works in 3.2
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=137363,137363,P3,JDT,UI,markus.kell.r,RESO,FIXE,[change method signature] Change method signature (visibility) refactor moves annotation,2006/8/3,behavior change,0,1,annotation,change method signature,nan,"Bug 137363 - [change method signature] Change method signature (visibility) refactor moves annotation
kyle Cacciatore 2006-04-18 16:14:27 EDT
When changing the method signature, specifically changing the method visibility, an annotation is moved into the method signature. For example:

@Override
private void testThis()
{}

becomes:

public @Override void testThis()
{}

which doesn't change the interpretation in this case, but maybe in others it might.
Olivier Thomann 2006-04-18 16:15:46 EDT
Moving to JDT/UI
Martin Aeschlimann 2006-08-03 09:53:22 EDT
works in 3.2
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=105654,105654,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] Convert Local Variable to Field has problems with arrays,2006/7/10,compile error,0,1,nan,convert local variable ,nan,"Bug 105654 - [refactoring] Convert Local Variable to Field has problems with arrays
Adrian Stabiszewski 2005-08-01 04:32:32 EDT
When promoting an array with predefined values to a field JDT generates illegal
java code. Example:

public class Test
{
  public void test()
  {
     String[] test = {""1"", ""2"" };
  }
}

becomes:

public class Test
{
  private String[] test;

  public void test()
  {
     test = {""1"", ""2"" };
  }
}

BTW: This also happens when using the quick fix ""Split variable declaration"".
Olivier Thomann 2005-08-01 13:28:37 EDT
Move to JDT/UI
Tobias Widmer 2006-03-10 11:09:09 EST
Fixed in HEAD > 20060310
Benno Baumgartner 2006-07-10 11:23:38 EDT
*** Bug 133063 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=110594,110594,P3,JDT,UI,markus.kell.r,RESO,FIXE,[refactoring] CCE in Infer type argument refactoring,2006/7/4,exception,0,1,java generics,Infer Type Arguments,nan,"Bug 110594 - [refactoring] CCE in Infer type argument refactoring
Martin Aeschlimann 2005-09-26 10:22:28 EDT
3.1.1

I started to infer some type arguments myself, but then realized that the
refactoring might do this better.
However, on my already modified (but compiling code) the refactoring failed with
a ClassCastException

- get jdt.core from the 3.2 stream (I20050922), set 5.0 comoliance, change PDE
target location to a M2 build
- replace ASTNode with the attached file
- run ' Infer type argument ' on the 'dom' source folder in jdt.core

java.lang.ClassCastException:
org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.StandardType
	at
org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.RawType.initialize(RawType.java:30)
	at
org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment.createRawType(TypeEnvironment.java:388)
	at
org.eclipse.jdt.internal.corext.refactoring.typeconstraints.types.TypeEnvironment.create(TypeEnvironment.java:177)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsTCModel.createTType(InferTypeArgumentsTCModel.java:299)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsTCModel.getBoxedType(InferTypeArgumentsTCModel.java:309)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsTCModel.makeTypeVariable(InferTypeArgumentsTCModel.java:375)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsConstraintCreator.endVisit(InferTypeArgumentsConstraintCreator.java:124)
	at
org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.endVisit(HierarchicalASTVisitor.java:707)
	at org.eclipse.jdt.core.dom.SimpleType.accept0(SimpleType.java:138)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
	at
org.eclipse.jdt.core.dom.VariableDeclarationStatement.accept0(VariableDeclarationStatement.java:271)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:501)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:299)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring$2.run(InferTypeArgumentsRefactoring.java:194)
	at
org.eclipse.core.internal.runtime.InternalPlatform.run(InternalPlatform.java:1044)
	at org.eclipse.core.runtime.Platform.run(Platform.java:783)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring$1.acceptAST(InferTypeArgumentsRefactoring.java:183)
	at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:691)
	at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:455)
	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:664)
	at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring.checkFinalConditions(InferTypeArgumentsRefactoring.java:178)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Martin Aeschlimann 2005-09-26 10:23:23 EDT
Created attachment 27511 [details]
updated ASTNode.java
Markus Keller 2005-09-26 13:25:38 EDT
Self-contained example:

package dom;
import java.util.AbstractList;
import java.util.Iterator;
public class ASTNode {
	abstract class NodeList<E extends ASTNode> extends AbstractList<E> {
		abstract class Cursor implements Iterator {
			
		}
	}
	final void acceptChildren(ASTNode.NodeList children) {
		NodeList.Cursor cursor;
	}
}

The problem is that the reference NodeList.Cursor is raw, but its
typeDeclaration is not generic as expected, but a standard type. I'll
investigate, but I don't think that's for 3.1.1.
Markus Keller 2005-09-27 07:29:55 EDT
An even smaller example:

public class NodeList<E> {
    class Cursor { } // type declaration is a standard type
    {
        NodeList.Cursor cursor; // NodeList.Cursor is raw!
        NodeList<String>.Cursor c2; // NodeList<String>.Cursor is standard type
    }
}

TTypes currently assume that the type declaration of a raw type is a generic
type, which is not the case here. I think that's against the current spec:
    For parameterized types and raw types, getTypeDeclaration() returns the
    binding for the corresponding generic type.

We have to sort out whether the spec or the implementation should be corrected.
Markus Keller 2006-07-03 09:23:23 EDT
*** Bug 134761 has been marked as a duplicate of this bug. ***
Markus Keller 2006-07-04 05:45:45 EDT
Fixed CCE in HEAD.

Treating non-generic member type of generic type like other non-generic types for now. Opened bug 149541 for the full fix.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=140580,140580,P3,JDT,UI,tobias_widmer,RESO,FIXE,Exception thrown while refactoring Extract Superclass,2006/5/12,crash,1,1,nan,extract superclass,ast rewrite issue,"Bug 140580 - Exception thrown while refactoring Extract Superclass
icemank 2006-05-08 10:42:35 EDT
An exception is thrown while trying to extract a superclass.
The existing class has no errors and there are no other problems in the project or workspace.

java.lang.IllegalArgumentException: Start node is not a original child of the given list
at org.eclipse.jdt.internal.core.dom.rewrite.RewriteEventStore.createRangeCopy(RewriteEventStore.java:582)
at org.eclipse.jdt.core.dom.rewrite.ListRewrite.createTargetNode(ListRewrite.java:304)
at org.eclipse.jdt.core.dom.rewrite.ListRewrite.createCopyTarget(ListRewrite.java:330)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor$PullUpAstNodeMapper.visit(PullUpRefactoringProcessor.java:232)
at org.eclipse.jdt.core.dom.SuperMethodInvocation.accept0(SuperMethodInvocation.java:236)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
at org.eclipse.jdt.core.dom.CastExpression.accept0(CastExpression.java:162)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
at org.eclipse.jdt.core.dom.Assignment.accept0(Assignment.java:311)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
at org.eclipse.jdt.core.dom.ExpressionStatement.accept0(ExpressionStatement.java:143)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2536)
at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.copyBodyOfPulledUpMethod(PullUpRefactoringProcessor.java:941)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createNewMethodDeclarationNode(PullUpRefactoringProcessor.java:1254)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1103)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:711)
at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.checkFinalConditions(ExtractSupertypeProcessor.java:206)
at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:175)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:118)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
java.lang.IllegalArgumentException: Start node is not a original child of the given list
at org.eclipse.jdt.internal.core.dom.rewrite.RewriteEventStore.createRangeCopy(RewriteEventStore.java:582)
at org.eclipse.jdt.core.dom.rewrite.ListRewrite.createTargetNode(ListRewrite.java:304)
at org.eclipse.jdt.core.dom.rewrite.ListRewrite.createCopyTarget(ListRewrite.java:330)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor$PullUpAstNodeMapper.visit(PullUpRefactoringProcessor.java:232)
at org.eclipse.jdt.core.dom.SuperMethodInvocation.accept0(SuperMethodInvocation.java:236)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
at org.eclipse.jdt.core.dom.CastExpression.accept0(CastExpression.java:162)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
at org.eclipse.jdt.core.dom.Assignment.accept0(Assignment.java:311)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2513)
at org.eclipse.jdt.core.dom.ExpressionStatement.accept0(ExpressionStatement.java:143)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2536)
at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.copyBodyOfPulledUpMethod(PullUpRefactoringProcessor.java:941)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createNewMethodDeclarationNode(PullUpRefactoringProcessor.java:1254)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1103)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:711)
at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.checkFinalConditions(ExtractSupertypeProcessor.java:206)
at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:175)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:118)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Olivier Thomann 2006-05-08 10:44:17 EDT
Could you please confirm that you are using RC3? If not, please provide the build id.
Could you also please provide your test case with steps to reproduce?
Thanks.
icemank 2006-05-08 11:52:17 EDT
I am pretty sure it is RC3.
The Eclipse build ID is I20060505-1306
Olivier Thomann 2006-05-08 11:54:52 EDT
Fine. Would you have a test case with steps to reproduce?
icemank 2006-05-08 21:50:17 EDT
It's kind of tough to create a reproducible test case.
The class in question is part of a fairly large project with a lot of dependencies, and I did the extraction manually in the end.
However, while trying to reproduce the problem I ran into another bug with the same refactoring.
To reproduce, try to extract a superclass from the attached class and select ALL methods exposed by the source class. The exception message is below.

java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:350)
at org.eclipse.jface.wizard.WizardDialog.run(WizardDialog.java:851)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:545)
at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:154)
at org.eclipse.jdt.internal.ui.refactoring.PullUpMemberPage.performFinish(PullUpMemberPage.java:889)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:611)
at org.eclipse.jface.wizard.WizardDialog.finishPressed(WizardDialog.java:680)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog.finishPressed(RefactoringWizardDialog.java:97)
at org.eclipse.jface.wizard.WizardDialog.buttonPressed(WizardDialog.java:355)
at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:660)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:928)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3348)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2968)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:820)
at org.eclipse.jface.window.Window.open(Window.java:796)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:132)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:67)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:145)
at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startExtractSupertypeRefactoring(RefactoringExecutionStarter.java:343)
at org.eclipse.jdt.internal.ui.actions.ExtractSuperTypeAction.run(ExtractSuperTypeAction.java:141)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:267)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:499)
at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:539)
at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:928)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3348)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2968)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1914)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1878)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:419)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:95)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:78)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:177)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:336)
at org.eclipse.core.launcher.Main.basicRun(Main.java:280)
at org.eclipse.core.launcher.Main.run(Main.java:977)
at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: java.lang.IllegalArgumentException: Document does not match the AST
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.handleException(ASTRewriteAnalyzer.java:3267)
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.getPosAfterLeftBrace(ASTRewriteAnalyzer.java:1010)
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.visit(ASTRewriteAnalyzer.java:1421)
at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:466)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.internalRewriteAST(ASTRewrite.java:255)
at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.rewriteAST(ASTRewrite.java:244)
at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.attachChange(CompilationUnitRewrite.java:192)
at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:162)
at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:147)
at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.registerChanges(ExtractSupertypeProcessor.java:1050)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1196)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:711)
at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.checkFinalConditions(ExtractSupertypeProcessor.java:206)
at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:175)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:118)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Caused by: org.eclipse.core.runtime.CoreException: End Of File
at org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner.readNext(TokenScanner.java:92)
at org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner.readNext(TokenScanner.java:111)
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.getPosAfterLeftBrace(ASTRewriteAnalyzer.java:1005)
... 19 more
Root exception:
java.lang.IllegalArgumentException: Document does not match the AST
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.handleException(ASTRewriteAnalyzer.java:3267)
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.getPosAfterLeftBrace(ASTRewriteAnalyzer.java:1010)
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.visit(ASTRewriteAnalyzer.java:1421)
at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:466)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2466)
at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.internalRewriteAST(ASTRewrite.java:255)
at org.eclipse.jdt.core.dom.rewrite.ASTRewrite.rewriteAST(ASTRewrite.java:244)
at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.attachChange(CompilationUnitRewrite.java:192)
at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:162)
at org.eclipse.jdt.internal.corext.refactoring.structure.CompilationUnitRewrite.createChange(CompilationUnitRewrite.java:147)
at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.registerChanges(ExtractSupertypeProcessor.java:1050)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.createChangeManager(PullUpRefactoringProcessor.java:1196)
at org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoringProcessor.checkFinalConditions(PullUpRefactoringProcessor.java:711)
at org.eclipse.jdt.internal.corext.refactoring.structure.ExtractSupertypeProcessor.checkFinalConditions(ExtractSupertypeProcessor.java:206)
at org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:175)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:118)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1737)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Caused by: org.eclipse.core.runtime.CoreException: End Of File
at org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner.readNext(TokenScanner.java:92)
at org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner.readNext(TokenScanner.java:111)
at org.eclipse.jdt.internal.core.dom.rewrite.ASTRewriteAnalyzer.getPosAfterLeftBrace(ASTRewriteAnalyzer.java:1005)
... 19 more
icemank 2006-05-08 21:51:11 EDT
Created attachment 40676 [details]
Class file for test
Olivier Thomann 2006-05-08 22:00:59 EDT
I tried, but I could not reproduce.
Martin,

Any idea how this is possible? Timing issue?
icemank 2006-05-08 22:22:49 EDT
I don't know if it makes a difference, but I have been reusing the same workspace as I have progressed from 3.1 to 3.2M1 through 3.2RC6.
I have a common extensions area in which I have installed several features and plugins.
Everytime I download a new build, I put it in its own directory, start Eclipse and add the extensions location to the configuration. Then I restart and proceed as usual.
In the test case I earlier attached, the refactoring works fine if I select only 2 of the 3 methods. It only fails if I select all 3 methods.
My configuration:
*** Features:
JDepend4Eclipse (1.0.2) ""JDepend4Eclipse Plug-in""
net.sf.colorer (0.7.1) ""Eclipse Colorer""
net.sf.eclipsensis (0.9.3) ""EclipseNSIS""
net.sf.eclipsensis.installoptions (0.9.3) ""EclipseNSIS InstallOptions Editor""
net.sf.eclipsensis.source (0.9.4) ""EclipseNSIS Source Plug-in""
net.sf.eclipsensis.utilities (0.9.0) ""EclipseNSIS Utilities""
net.sourceforge.ehep (0.2.1) ""Ehep Plug-in""
net.sourceforge.pmd.eclipse (3.1.0) ""PMD UI Plugin""
net.trajano.eclipse.platform (3.1.0.2) ""Eclipse Platform Extensions""
org.eclipse.cdt (3.0.0) ""Eclipse C/C++ Development Tools""
org.eclipse.cdt.sdk (3.0.2) ""Eclipse C/C++ Development Tools SDK""
org.eclipse.cdt.source (3.0.2) ""Eclipse C/C++ Development Tools (Source)""
org.eclipse.emf (2.1.1) ""Eclipse Modeling Framework (EMF)""
org.eclipse.emf.doc (2.1.1) ""Eclipse Modeling Framework (EMF) Programmers Guide""
org.eclipse.emf.ecore.sdo (2.1.1) ""EMF Service Data Objects (SDO)""
org.eclipse.emf.ecore.sdo.doc (2.1.1) ""EMF Service Data Objects (SDO) Programmers Guide""
org.eclipse.emf.ecore.sdo.source (2.1.1) ""EMF Service Data Objects (SDO) Source""
org.eclipse.emf.source (2.1.1) ""Eclipse Modeling Framework (EMF) Source""
org.eclipse.gef (3.2.0.I20060405) ""Graphical Editing Framework""
org.eclipse.gef.examples (3.1.0) ""GEF Examples""
org.eclipse.gef.sdk (3.1.1) ""Graphical Editing Framework Developer Resources""
org.eclipse.gef.source (3.1.1) ""Graphical Editing Framework Developer Resources""
org.eclipse.jdt (3.2.0.v20060428-0010-F7snp5ffnngadgn) ""Eclipse Java Development Tools""
org.eclipse.jdt.source (3.2.0.v20060428-0010-F7snp5ffnngadgn) ""Eclipse Java Development Tools SDK""
org.eclipse.jem (1.1.0.1) ""Java EMF Model""
org.eclipse.jem.sdk (1.1.0.1) ""Java EMF Model SDK""
org.eclipse.jem.source (1.1.0.1) ""Java EMF Model Source""
org.eclipse.pde (3.2.0.v20060427-2000-zXJJzJsJooHgIHo) ""Eclipse Plug-in Development Environment""
org.eclipse.pde.source (3.2.0.v20060427-2000-zXJJzJsJooHgIHo) ""Eclipse Plug-in Development Environment Developer Resources""
org.eclipse.platform (3.2.0.v20060503-1530-7gOepm_tjppfKda) ""Eclipse Platform""
org.eclipse.platform.source (3.2.0.v20060503-1530-7gOepm_tjppfKda) ""Eclipse Platform Plug-in Developer Resources""
org.eclipse.rcp (3.2.0.v20060427-2000-SVDNgOq2-4-Z3TS) ""Eclipse RCP""
org.eclipse.rcp.source (3.2.0.v20060427-2000-SVDNgOq2-4-Z3TS) ""Eclipse RCP Plug-in Developer Resources""
org.eclipse.sdk (3.2.0.v20060404-K4HZsoFkY7ar-Lr) ""Eclipse Project SDK""
org.eclipse.tptp.monitoring.source (4.0.1) ""TPTP Monitoring Source""
org.eclipse.tptp.platform.analysis.engine.source (4.0.0) ""TPTP Analysis Engine Source""
org.eclipse.tptp.platform.analysis.source (4.0.0) ""TPTP Analysis Feature Source""
org.eclipse.tptp.platform.core.source (4.0.1) ""TPTP Core Source""
org.eclipse.tptp.platform.lta.source (4.0.0) ""TPTP Log and Trace Analyzer Source""
org.eclipse.tptp.platform.probekit.source (4.0.1) ""TPTP ProbeKit Source""
org.eclipse.tptp.platform.report.source (4.0.0) ""TPTP Charting Service Source""
org.eclipse.tptp.platform.samples.source (4.0.0) ""TPTP Platform Samples Source""
org.eclipse.tptp.platform.statistical.ui.source (4.0.0) ""TPTP Statistical UI Source""
org.eclipse.tptp.platform.trace.source (4.0.0) ""TPTP Platform Trace Source""
org.eclipse.tptp.test.samples.source (4.0.0) ""TPTP Test Samples Source""
org.eclipse.tptp.test.source (4.0.1) ""TPTP Test Source""
org.eclipse.tptp.test.tools.source (4.0.0) ""TPTP Test Tools Source""
org.eclipse.tptp.trace.source (4.0.0) ""TPTP Trace Source""
org.eclipse.ve (1.2.0.v20060407_S) ""Visual Editor""
org.eclipse.ve.sdk (1.1.0.1) ""Visual Editor SDK""
org.eclipse.ve.source (1.1.0.1) ""Visual Editor Source""
org.eclipse.xsd (2.1.1) ""XML Schema Infoset Model (XSD)""
org.eclipse.xsd.doc (2.1.1) ""XML Schema Infoset Model (XSD) Programmers Guide""
org.eclipse.xsd.source (2.1.1) ""XML Schema Infoset Model (XSD) Source""

*** Plug-in Registry:
ch.graftec.classcycle.plugin.ClassyclePlugin (1.1.1) ""ClassyclePlugin"" [Resolved]
com.beust.j15 (1.0.0) ""J15 Plug-in"" [Resolved]
com.ibm.etools.emf.event (3.0.0.1) ""Event Model"" [Installed]
com.ibm.etools.emf.event (3.0.0.3) ""Event Model"" [Resolved]
com.ibm.icu (3.4.4.1) ""International Components for Unicode for Java (ICU4J)"" [Active]
com.ibm.icu.source (3.4.4.1) ""International Components for Unicode for Java (ICU4J) source plug-in"" [Resolved]
com.jcraft.jsch (0.1.28) ""JSch"" [Resolved]
com.kyrsoft.stmemmon (1.1) ""Status Memory Monitor"" [Active]
com.objfac.xmleditor (2.0.72) ""XMLBuddy"" [Resolved]
de.kyrsoft.memmonitor (1.4) ""Memmonitor Plug-in"" [Resolved]
de.loskutov.eclipse.jdepend (1.0.2) ""JDepend4Eclipse Plug-in"" [Resolved]
EditorViewer (0.1.6) ""EditorViewer Plug-in"" [Resolved]
edu.stanford.suif.keepresident (0.1.0) ""KeepResident Plug-in"" [Active]
ksource.eclipse.util.serialversion (1.0.0) ""SerialVersion Plug-in"" [Resolved]
net.amduat.eclipse.team.cvs.sspi (1.0.0) ""CVS SSPI Plug-in"" [Active]
net.amduat.eclipse.team.cvs.sspi.win32 (1.0.0) ""CVS SSPI Win32 Fragment"" [Resolved]
net.sf.colorer (0.7.1) ""Eclipse Colorer"" [Resolved]
net.sf.eclipsensis (0.9.3) ""EclipseNSIS"" [Installed]
net.sf.eclipsensis (0.9.4) ""EclipseNSIS"" [Resolved]
net.sf.eclipsensis.installoptions (0.9.3) ""EclipseNSIS InstallOptions Editor"" [Installed]
net.sf.eclipsensis.installoptions (0.9.4) ""EclipseNSIS InstallOptions Editor"" [Resolved]
net.sf.eclipsensis.source (0.9.4) ""EclipseNSIS Source Plug-in"" [Resolved]
net.sf.eclipsensis.update (0.9.4) ""EclipseNSIS Update"" [Active]
net.sf.eclipsensis.utilities (0.5.0) ""EclipseNSIS Utilities"" [Installed]
net.sf.eclipsensis.utilities (0.9.0) ""EclipseNSIS Utilities"" [Resolved]
net.sf.jarsigner (0.5.0) ""JARSigner Plug-in"" [Installed]
net.sf.jarsigner (0.9.0) ""JARSigner Plug-in"" [Resolved]
net.sf.jnigen (0.5.0) ""JNIGen Plug-in"" [Installed]
net.sf.jnigen (0.9.0) ""JNIGen Plug-in"" [Resolved]
net.sourceforge.ehep (0.2.1) ""Ehep Plug-in"" [Resolved]
net.sourceforge.pmd.core (3.2.0) ""PMD Core Engine Plugin"" [Resolved]
net.sourceforge.pmd.eclipse (3.1.0) ""PMD UI Plugin"" [Resolved]
net.trajano.eclipse.platform (3.1.0.2) ""Eclipse Platform Extensions"" [Resolved]
net.trajano.eclipse.platform.core (3.1.0.2) ""Eclipse Platform Extensions Core"" [Active]
net.trajano.eclipse.platform.doc (3.1.0.2) ""Eclipse Platform Extensions Plug-in Users Guide"" [Resolved]
org.apache.ant (1.6.5) ""Apache Ant"" [Resolved]
org.apache.lucene (1.4.103.v20060426) ""Apache Lucene"" [Resolved]
org.eclipse.ant.core (3.1.100.v20060502) ""Ant Build Tool Core"" [Resolved]
org.eclipse.ant.ui (3.2.0.v20060426) ""Ant UI"" [Resolved]
org.eclipse.cdt (3.0.0) ""Eclipse C/C++ Development Tools"" [Installed]
org.eclipse.cdt (3.0.2) ""Eclipse C/C++ Development Tools"" [Installed]
org.eclipse.cdt (3.1.0.200604070500) ""Eclipse C/C++ Development Tools"" [Resolved]
org.eclipse.cdt.core (3.0.0) ""C/C++ Development Tools Core"" [Installed]
org.eclipse.cdt.core (3.0.2) ""C/C++ Development Tools Core"" [Installed]
org.eclipse.cdt.core (3.1.0.200604070500) ""C/C++ Development Tools Core"" [Resolved]
org.eclipse.cdt.core.win32 (3.1.0.200604070500) ""C/C++ Development Tools Core for Windows"" [Resolved]
org.eclipse.cdt.core.win32 (3.0.0) ""fragmentName.win32"" [Installed]
org.eclipse.cdt.core.win32 (3.0.2) ""fragmentName.win32"" [Installed]
org.eclipse.cdt.debug.core (3.0.0) ""C/C++ Development Tools Debug Model"" [Installed]
org.eclipse.cdt.debug.core (3.0.2) ""C/C++ Development Tools Debug Model"" [Installed]
org.eclipse.cdt.debug.core (3.1.0.200604070500) ""C/C++ Development Tools Debug Model"" [Resolved]
org.eclipse.cdt.debug.mi.core (3.0.0) ""C/C++ Development Tools GDB/MI CDI Debugger Core"" [Installed]
org.eclipse.cdt.debug.mi.core (3.0.2) ""C/C++ Development Tools GDB/MI CDI Debugger Core"" [Installed]
org.eclipse.cdt.debug.mi.core (3.1.0.200604070500) ""C/C++ Development Tools GDB/MI CDI Debugger Core"" [Resolved]
org.eclipse.cdt.debug.mi.ui (3.0.0) ""C/C++ Development Tools GDB/MI CDI Debugger UI"" [Installed]
org.eclipse.cdt.debug.mi.ui (3.0.2) ""C/C++ Development Tools GDB/MI CDI Debugger UI"" [Installed]
org.eclipse.cdt.debug.mi.ui (3.1.0.200604070500) ""C/C++ Development Tools GDB/MI CDI Debugger UI"" [Resolved]
org.eclipse.cdt.debug.ui (3.0.0) ""C/C++ Development Tools Debugger UI"" [Installed]
org.eclipse.cdt.debug.ui (3.0.2) ""C/C++ Development Tools Debugger UI"" [Installed]
org.eclipse.cdt.debug.ui (3.1.0.200604070500) ""C/C++ Development Tools Debugger UI"" [Resolved]
org.eclipse.cdt.doc.isv (3.0.0) ""C/C++ Plugin Developer Guide"" [Installed]
org.eclipse.cdt.doc.isv (3.0.2) ""C/C++ Plugin Developer Guide"" [Resolved]
org.eclipse.cdt.doc.user (3.0.0) ""C/C++ Development User Guide"" [Installed]
org.eclipse.cdt.doc.user (3.0.2) ""C/C++ Development User Guide"" [Installed]
org.eclipse.cdt.doc.user (3.1.0.200604070500) ""C/C++ Development User Guide"" [Resolved]
org.eclipse.cdt.launch (3.0.0) ""C/C++ Development Tools Launching Support"" [Installed]
org.eclipse.cdt.launch (3.0.2) ""C/C++ Development Tools Launching Support"" [Installed]
org.eclipse.cdt.launch (3.1.0.200604070500) ""C/C++ Development Tools Launching Support"" [Resolved]
org.eclipse.cdt.make.core (3.0.0) ""C/C++ Standard make Build Core"" [Installed]
org.eclipse.cdt.make.core (3.0.2) ""C/C++ Standard make Build Core"" [Installed]
org.eclipse.cdt.make.core (3.1.0.200604070500) ""C/C++ Standard make Build Core"" [Resolved]
org.eclipse.cdt.make.ui (3.0.0) ""C/C++ Standard make Build UI"" [Installed]
org.eclipse.cdt.make.ui (3.0.2) ""C/C++ Standard make Build UI"" [Installed]
org.eclipse.cdt.make.ui (3.1.0.200604070500) ""C/C++ Standard make Build UI"" [Active]
org.eclipse.cdt.managedbuilder.core (3.0.0) ""C/C++ Managed Builder Core"" [Installed]
org.eclipse.cdt.managedbuilder.core (3.0.2) ""C/C++ Managed Builder Core"" [Installed]
org.eclipse.cdt.managedbuilder.core (3.1.0.200604070500) ""C/C++ Managed Builder Core"" [Resolved]
org.eclipse.cdt.managedbuilder.gnu.ui (3.0.0) ""GNU Managed Build Definitions"" [Installed]
org.eclipse.cdt.managedbuilder.gnu.ui (3.0.2) ""GNU Managed Build Definitions"" [Installed]
org.eclipse.cdt.managedbuilder.gnu.ui (3.1.0.200604070500) ""GNU Managed Build Definitions"" [Resolved]
org.eclipse.cdt.managedbuilder.ui (3.0.0) ""C/C++ Managed Builder UI"" [Installed]
org.eclipse.cdt.managedbuilder.ui (3.0.2) ""C/C++ Managed Builder UI"" [Installed]
org.eclipse.cdt.managedbuilder.ui (3.1.0.200604070500) ""C/C++ Managed Builder UI"" [Active]
org.eclipse.cdt.refactoring (3.0.0) ""C/C++ Refactoring"" [Installed]
org.eclipse.cdt.refactoring (3.0.2) ""C/C++ Refactoring"" [Installed]
org.eclipse.cdt.refactoring (3.1.0.200604070500) ""C/C++ Refactoring"" [Resolved]
org.eclipse.cdt.sdk (3.0.0) ""Eclipse C/C++ Development Tools SDK"" [Resolved]
org.eclipse.cdt.sdk (3.0.2) ""Eclipse C/C++ Development Tools SDK"" [Resolved]
org.eclipse.cdt.source (3.0.0) ""Eclipse C/C++ Development Tools (Source)"" [Installed]
org.eclipse.cdt.source (3.0.2) ""Eclipse C/C++ Development Tools (Source)"" [Resolved]
org.eclipse.cdt.source.win32.win32.x86 (3.0.2) ""Eclipse C/C++ Development Tools (Source)"" [Resolved]
org.eclipse.cdt.source.win32.win32.x86 (3.0.0) ""pluginName"" [Installed]
org.eclipse.cdt.ui (3.0.0) ""C/C++ Development Tools UI"" [Installed]
org.eclipse.cdt.ui (3.0.2) ""C/C++ Development Tools UI"" [Installed]
org.eclipse.cdt.ui (3.1.0.200604070500) ""C/C++ Development Tools UI"" [Resolved]
org.eclipse.compare (3.2.0.v20060426) ""Compare Support"" [Active]
org.eclipse.core.boot (3.1.100.v20060418) ""Core Boot"" [Resolved]
org.eclipse.core.commands (3.2.0.I20060504-0800) ""Commands"" [Resolved]
org.eclipse.core.contenttype (3.2.0.v20060426) ""Eclipse Content Mechanism"" [Active]
org.eclipse.core.expressions (3.2.0.v20060427-1600) ""Expression Language"" [Active]
org.eclipse.core.filebuffers (3.2.0.v20060427-1600) ""File Buffers"" [Active]
org.eclipse.core.filesystem (1.0.0.v20060411) ""Core File Systems"" [Resolved]
org.eclipse.core.filesystem.win32.x86 (1.0.0.v20051114) ""Core File System for Windows"" [Resolved]
org.eclipse.core.jobs (3.2.0.v20060426) ""Eclipse Jobs Mechanism"" [Active]
org.eclipse.core.resources (3.2.0.v20060426) ""Core Resource Management"" [Active]
org.eclipse.core.resources.compatibility (3.2.0.v20060426) ""Core Resource Management Compatibility Fragment"" [Resolved]
org.eclipse.core.resources.win32 (3.2.0.v20060426) ""Core Resource Management Win32 Fragment"" [Resolved]
org.eclipse.core.runtime (3.2.0.v20060504-1200) ""Core Runtime"" [Active]
org.eclipse.core.runtime.compatibility (3.1.100.v20060504-1200) ""Core Runtime Plug-in Compatibility"" [Active]
org.eclipse.core.runtime.compatibility.auth (3.2.0.v20060426) ""Authorization Compatibility Plug-in"" [Active]
org.eclipse.core.runtime.compatibility.registry (3.2.0.v20060426) ""Eclipse Registry Compatibility Fragment"" [Resolved]
org.eclipse.core.variables (3.1.100.v20060504c) ""Core Variables"" [Resolved]
org.eclipse.datatools.connectivity (0.7.0.200602241) ""Data Tools Connectivity Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.db.derby (0.9.0.200604051) ""Derby Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.db.generic (0.7.0.200602241) ""Generic DB Connectivity Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.db.generic.ui (0.7.0.200602241) ""Generic DB UI Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.dbdefinition.db2.luw (0.7.0.200602241) ""DB2 UDB Database Definition Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.dbdefinition.derby (0.7.0.200602241) ""IBM Cloudscape Database Definition"" [Resolved]
org.eclipse.datatools.connectivity.dbdefinition.mysql (0.7.0.200602241) ""DBDefinition Generic JDBC Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.dbdefinition.oracle (0.7.0.200602241) ""Oracle Database Definition Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.dbdefinition.sybase (0.7.0.200602241) ""Sybase Database Definition Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.derby (0.9.0.200604051) ""RDB Derby Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.oda (3.0.1.200604061) ""DTP Open Data Access"" [Resolved]
org.eclipse.datatools.connectivity.oda.consumer (3.0.0.200604071) ""DTP ODA Consumer Helper Component Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.oda.design (3.0.0.200604071) ""DTP ODA Design Session Model"" [Resolved]
org.eclipse.datatools.connectivity.oda.design.ui (3.0.1.200604051) ""DTP ODA Designer UI Framework Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.oda.flatfile (3.0.0.200604071) ""DTP ODA Flat File Run-time Driver"" [Resolved]
org.eclipse.datatools.connectivity.oda.flatfile.ui (3.0.0.200604071) ""DTP ODA Flat File Designer"" [Resolved]
org.eclipse.datatools.connectivity.oda.profile (3.0.0.200604071) ""DTP ODA Connection Profile Framework Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.sqm.core (0.9.0.200604051) ""RDB Core"" [Resolved]
org.eclipse.datatools.connectivity.sqm.core.ui (0.7.0.200603071) ""Core UI plugin"" [Resolved]
org.eclipse.datatools.connectivity.sqm.server.ui (0.7.0.2006003081) ""Server Explorer plugin"" [Resolved]
org.eclipse.datatools.connectivity.ui (0.7.0.200602241) ""Data Tools Connectivity UI Plug-in"" [Resolved]
org.eclipse.datatools.connectivity.ui.dse (0.7.0.200602241) ""DTP Data Source Explorer Plug-in"" [Resolved]
org.eclipse.datatools.doc.isv (0.9.0.200604071) ""Data Tools Documentation Plug-in"" [Resolved]
org.eclipse.datatools.modelbase.dbdefinition (0.7.0.200602241) ""DBDefinition Model"" [Resolved]
org.eclipse.datatools.modelbase.derby (0.7.0.200603061) ""Derby Model Plug-in"" [Resolved]
org.eclipse.datatools.modelbase.edit (0.7.0.200602241) ""SQLModel Edit Plug-in"" [Resolved]
org.eclipse.datatools.modelbase.sql (0.7.0.200602241) ""SQLModel Plug-in"" [Resolved]
org.eclipse.datatools.modelbase.sql.query (0.7.0.200602241) ""SQL Query Model Plugin"" [Resolved]
org.eclipse.datatools.modelbase.sql.xml.query (0.7.0.200602241) ""SQL XML Query Model Plugin"" [Resolved]
org.eclipse.datatools.source (0.9.0.200604071) ""Data Tools Platform Source Code"" [Resolved]
org.eclipse.datatools.sqltools.common.ui (0.9.0.200603301) ""Eclipse Data Tools Platform SQL Tools Common UI Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.db.derby (0.9.0.200603301) ""Eclipse Data Tools Platform Derby SQL Tools Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.db.generic (0.9.0.200603301) ""Generic Database Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.debugger.core (0.9.0.200603301) ""Eclipse Data Tools Platform SQL Debugger Framework"" [Resolved]
org.eclipse.datatools.sqltools.editor.core (0.9.0.200603301) ""DTP SQL Editor Core Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.parsers.sql (0.7.0.200602241) ""SQL Parser Plugin"" [Resolved]
org.eclipse.datatools.sqltools.parsers.sql.lexer (0.7.0.200602241) ""Lexer Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.parsers.sql.query (0.7.0.200602241) ""SQL Query Parser Plugin"" [Resolved]
org.eclipse.datatools.sqltools.parsers.sql.xml.query (0.7.0.200602241) ""SQL XML Query Parser Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.plan (0.9.0.200603301) ""SQL Execution Plan View Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.result (0.9.0.200603301) ""SQL Results View Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.routineeditor (0.9.0.200603301) ""DTP SQL Tools Routine Editor Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.sql (0.9.0.200603301) ""Eclipse Data Tools Platform SQL Core Plug-in"" [Resolved]
org.eclipse.datatools.sqltools.sqleditor (0.9.0.200603301) ""Eclipse Data Tools Platform SQL Editor"" [Resolved]
org.eclipse.datatools.sqltools.sqlscrapbook (0.9.0.200603301) ""Sqlscrapbook Plug-in"" [Resolved]
org.eclipse.debug.core (3.2.0.v20060505) ""Debug Core"" [Active]
org.eclipse.debug.ui (3.2.0.v20060505) ""Debug UI"" [Active]
org.eclipse.draw2d (3.0.1) ""Draw2d"" [Resolved]
org.eclipse.draw2d (3.1.1) ""Draw2d"" [Resolved]
org.eclipse.draw2d (3.2.0.I20060405) ""Draw2d"" [Resolved]
org.eclipse.draw2d.doc.isv (3.1.1) ""Draw2D Documentation"" [Installed]
org.eclipse.draw2d.doc.isv (3.2.0.I20060405) ""Draw2D Documentation"" [Resolved]
org.eclipse.emf (2.1.1) ""Eclipse Modeling Framework (EMF)"" [Resolved]
org.eclipse.emf (2.2.0.v200604060931) ""Eclipse Modeling Framework (EMF)"" [Resolved]
org.eclipse.emf.ant (2.1.0) ""EMF Ant Tasks"" [Installed]
org.eclipse.emf.ant (2.2.0.v200604060931) ""EMF Ant Tasks"" [Resolved]
org.eclipse.emf.codegen (2.1.0) ""EMF Template Code Generator"" [Installed]
org.eclipse.emf.codegen (2.2.0.v200604060931) ""EMF Template Code Generator"" [Resolved]
org.eclipse.emf.codegen.ecore (2.1.0) ""EMF Ecore Code Generation"" [Installed]
org.eclipse.emf.codegen.ecore (2.2.0.v200604060931) ""EMF Ecore Code Generation"" [Resolved]
org.eclipse.emf.codegen.ecore.ui (2.1.0) ""EMF Ecore Code Generation UI"" [Installed]
org.eclipse.emf.codegen.ecore.ui (2.2.0.v200604060931) ""EMF Ecore Code Generation UI"" [Resolved]
org.eclipse.emf.codegen.ui (2.1.0) ""EMF Template Code Generator UI"" [Installed]
org.eclipse.emf.codegen.ui (2.1.0.v200604060931) ""EMF Template Code Generator UI"" [Resolved]
org.eclipse.emf.common (2.1.0) ""EMF Common"" [Resolved]
org.eclipse.emf.common (2.2.0.v200604060931) ""EMF Common"" [Active]
org.eclipse.emf.common.ui (2.1.0) ""EMF Common UI"" [Resolved]
org.eclipse.emf.common.ui (2.2.0.v200604060931) ""EMF Common UI"" [Resolved]
org.eclipse.emf.commonj.sdo (2.1.0) ""CommonJ SDO"" [Resolved]
org.eclipse.emf.converter (2.2.0.v200604060931) ""EMF Model Convert Support"" [Resolved]
org.eclipse.emf.doc (2.1.1) ""Eclipse Modeling Framework (EMF) Programmers Guide"" [Resolved]
org.eclipse.emf.ecore (2.1.0) ""EMF Ecore"" [Installed]
org.eclipse.emf.ecore (2.2.0.v200604060931) ""EMF Ecore"" [Active]
org.eclipse.emf.ecore.change (2.1.0) ""EMF Ecore Change Model"" [Installed]
org.eclipse.emf.ecore.change (2.2.0.v200604060931) ""EMF Ecore Change Model"" [Resolved]
org.eclipse.emf.ecore.change.edit (2.1.0) ""EMF Ecore Change Edit Support"" [Installed]
org.eclipse.emf.ecore.change.edit (2.1.0.v200604060931) ""EMF Ecore Change Edit Support"" [Resolved]
org.eclipse.emf.ecore.edit (2.1.1) ""EMF Ecore Edit Support"" [Installed]
org.eclipse.emf.ecore.edit (2.2.0.v200604060931) ""EMF Ecore Edit Support"" [Resolved]
org.eclipse.emf.ecore.editor (2.1.0) ""Sample Ecore Editor"" [Installed]
org.eclipse.emf.ecore.editor (2.2.0.v200604060931) ""Sample Ecore Editor"" [Resolved]
org.eclipse.emf.ecore.sdo (2.1.1) ""EMF Service Data Objects (SDO)"" [Resolved]
org.eclipse.emf.ecore.sdo.doc (2.1.1) ""EMF Service Data Objects (SDO) Programmers Guide"" [Resolved]
org.eclipse.emf.ecore.sdo.edit (2.1.0) ""EMF Service Data Objects (SDO) Edit Support"" [Resolved]
org.eclipse.emf.ecore.sdo.editor (2.1.0) ""EMF Service Data Objects (SDO) Editor"" [Resolved]
org.eclipse.emf.ecore.sdo.source (2.1.1) ""EMF Service Data Objects (SDO) Source"" [Resolved]
org.eclipse.emf.ecore.xmi (2.1.0) ""EMF XMI"" [Installed]
org.eclipse.emf.ecore.xmi (2.2.0.v200604060931) ""EMF XMI"" [Resolved]
org.eclipse.emf.edit (2.1.1) ""EMF Edit"" [Installed]
org.eclipse.emf.edit (2.2.0.v200604060931) ""EMF Edit"" [Resolved]
org.eclipse.emf.edit.ui (2.1.0) ""EMF Edit UI"" [Resolved]
org.eclipse.emf.edit.ui (2.2.0.v200604060931) ""EMF Edit UI"" [Resolved]
org.eclipse.emf.exporter (2.2.0.v200604060931) ""EMF Model Export Support"" [Resolved]
org.eclipse.emf.importer (2.1.0) ""EMF Model Import Support"" [Installed]
org.eclipse.emf.importer (2.2.0.v200604060931) ""EMF Model Import Support"" [Resolved]
org.eclipse.emf.importer.ecore (2.1.0) ""EMF Ecore Importer"" [Installed]
org.eclipse.emf.importer.ecore (2.2.0.v200604060931) ""EMF Ecore Importer"" [Resolved]
org.eclipse.emf.importer.java (2.1.1) ""EMF Annotated Java Importer"" [Installed]
org.eclipse.emf.importer.java (2.2.0.v200604060931) ""EMF Annotated Java Importer"" [Resolved]
org.eclipse.emf.importer.rose (2.1.1) ""EMF Rose Importer"" [Installed]
org.eclipse.emf.importer.rose (2.2.0.v200604060931) ""EMF Rose Importer"" [Resolved]
org.eclipse.emf.mapping (2.1.0) ""EMF Mapping"" [Installed]
org.eclipse.emf.mapping (2.2.0.v200604060931) ""EMF Mapping"" [Resolved]
org.eclipse.emf.mapping.ecore2ecore (2.1.0) ""Ecore to Ecore Mapping"" [Installed]
org.eclipse.emf.mapping.ecore2ecore (2.2.0.v200604060931) ""Ecore to Ecore Mapping"" [Resolved]
org.eclipse.emf.mapping.ecore2ecore.editor (2.1.0) ""Ecore to Ecore Mapping Editor"" [Installed]
org.eclipse.emf.mapping.ecore2ecore.editor (2.2.0.v200604060931) ""Ecore to Ecore Mapping Editor"" [Resolved]
org.eclipse.emf.mapping.ecore2xml (2.1.0) ""Ecore to XML Mapping"" [Installed]
org.eclipse.emf.mapping.ecore2xml (2.2.0.v200604060931) ""Ecore to XML Mapping"" [Resolved]
org.eclipse.emf.mapping.ecore2xml.ui (2.1.1) ""Ecore to XML Mapping UI"" [Installed]
org.eclipse.emf.mapping.ecore2xml.ui (2.2.0.v200604060931) ""Ecore to XML Mapping UI"" [Resolved]
org.eclipse.emf.mapping.ui (2.1.0) ""EMF Mapping UI"" [Resolved]
org.eclipse.emf.mapping.ui (2.2.0.v200604060931) ""EMF Mapping UI"" [Resolved]
org.eclipse.emf.mapping.xsd2ecore (2.1.0) ""XSD to Ecore Mapping"" [Resolved]
org.eclipse.emf.mapping.xsd2ecore.editor (2.1.0) ""XSD to Ecore Mapping Editor"" [Resolved]
org.eclipse.emf.source (2.1.1) ""Eclipse Modeling Framework (EMF) Source"" [Resolved]
org.eclipse.equinox.common (3.2.0.v20060504-1200) ""Common Eclipse Runtime"" [Active]
org.eclipse.equinox.preferences (3.2.0.v20060504-0600) ""Eclipse Preferences Mechanism"" [Active]
org.eclipse.equinox.registry (3.2.0.v20060503) ""Extension Registry Support"" [Active]
org.eclipse.ftp (1.0.0) ""Ftp Plug-in"" [Resolved]
org.eclipse.gef (3.0.1) ""Graphical Editing Framework"" [Installed]
org.eclipse.gef (3.1.1) ""Graphical Editing Framework"" [Installed]
org.eclipse.gef (3.2.0.I20060405) ""Graphical Editing Framework"" [Resolved]
org.eclipse.gef.doc.isv (3.1.1) ""Graphical Editing Framework Documentation"" [Installed]
org.eclipse.gef.doc.isv (3.2.0.I20060405) ""Graphical Editing Framework Documentation"" [Resolved]
org.eclipse.gef.examples.flow (3.0.1) ""GEF Flow Editor Example"" [Installed]
org.eclipse.gef.examples.flow (3.1.0) ""GEF Flow Editor Example"" [Installed]
org.eclipse.gef.examples.flow (3.2.0.I20060405) ""GEF Flow Editor Example"" [Resolved]
org.eclipse.gef.examples.logic (3.0.0) ""GEF Logic Editor Example"" [Installed]
org.eclipse.gef.examples.logic (3.1.0) ""GEF Logic Editor Example"" [Installed]
org.eclipse.gef.examples.logic (3.2.0.I20060405) ""GEF Logic Editor Example"" [Resolved]
org.eclipse.gef.examples.shapes (3.1.0) ""GEF Shape Editor Example"" [Installed]
org.eclipse.gef.examples.shapes (3.2.0.I20060405) ""GEF Shape Editor Example"" [Resolved]
org.eclipse.gef.examples.source (3.1.0) ""GEF Examples"" [Installed]
org.eclipse.gef.examples.source (3.2.0.I20060405) ""GEF Examples"" [Resolved]
org.eclipse.gef.examples.text (3.1.0) ""GEF Text Editor Example"" [Installed]
org.eclipse.gef.examples.text (3.2.0.I20060405) ""GEF Text Editor Example"" [Resolved]
org.eclipse.gef.source (3.1.1) ""Graphical Editing Framework Developer Resources"" [Installed]
org.eclipse.gef.source (3.2.0.I20060405) ""Graphical Editing Framework Developer Resources"" [Resolved]
org.eclipse.help (3.2.0.v20060503) ""Help System Core"" [Active]
org.eclipse.help.appserver (3.1.100.v20060503) ""Help Application Server"" [Resolved]
org.eclipse.help.base (3.2.0.v20060504) ""Help System Base"" [Resolved]
org.eclipse.help.ui (3.2.0.v20060504) ""Help System UI"" [Resolved]
org.eclipse.help.webapp (3.2.0.v20060504) ""Help System Webapp"" [Resolved]
org.eclipse.hyades.analysis.engine (4.0.0) ""Hyades Analysis Engine"" [Installed]
org.eclipse.hyades.execution (4.0.0) ""TPTP Platform Execution Plug-In"" [Resolved]
org.eclipse.hyades.execution.correlation (4.0.0) ""Hyades Runtime Correlation Engine"" [Resolved]
org.eclipse.hyades.execution.trace (4.0.0) ""Hyades Execution Trace"" [Installed]
org.eclipse.hyades.logging.adapter (4.0.1) ""TPTP Monitoring Project Generic Log Adapter"" [Installed]
org.eclipse.hyades.logging.adapter.ui (4.0.0) ""Generic Adapter UI"" [Installed]
org.eclipse.hyades.logging.core (4.0.0) ""Hyades Logging Agent, Common Base Events and Logging Facility Support"" [Installed]
org.eclipse.hyades.logging.core.sample (4.0.0) ""Sample for Hyades Logging Agent, Common Base Events and Logging Facility Support"" [Resolved]
org.eclipse.hyades.logging.parsers (4.0.0) ""TPTP Monitoring Project Log File Parsers"" [Installed]
org.eclipse.hyades.perfmon (4.0.0) ""Perfmon StatCon Module"" [Resolved]
org.eclipse.hyades.probekit (4.0.1) ""Hyades Probekit"" [Resolved]
org.eclipse.hyades.probekit.doc.user (4.0.0) ""Probekit User Documentation"" [Resolved]
org.eclipse.hyades.probekit.ui (4.0.1) ""Probe Editor"" [Resolved]
org.eclipse.hyades.resources.database (4.0.0) ""Hyades Core Resource Extensions"" [Resolved]
org.eclipse.hyades.sdb (4.0.0) ""Symptom Database tool"" [Installed]
org.eclipse.hyades.statistical.ui (4.0.1) ""Statistical Analysis"" [Installed]
org.eclipse.hyades.test.core (4.0.0) ""TPTP Test Core Plug-In"" [Installed]
org.eclipse.hyades.test.doc.user (4.0.0) ""Test Tools user documentation"" [Resolved]
org.eclipse.hyades.test.tools.core (4.0.1) ""TPTP Test Tools Core Plug-In"" [Installed]
org.eclipse.hyades.test.tools.ui (4.0.1) ""TPTP Test Tools UI Plug-In"" [Installed]
org.eclipse.hyades.test.ui (4.0.1) ""TPTP Test UI Plug-In"" [Installed]
org.eclipse.hyades.trace.sample (4.0.0) ""Samples for the TPTP Monitoring Tools Plugins"" [Installed]
org.eclipse.hyades.trace.ui (4.0.0) ""Hyades Trace Core UI"" [Resolved]
org.eclipse.hyades.trace.views (4.0.0) ""Hyades Trace Views Plugin"" [Resolved]
org.eclipse.hyades.ui (4.0.1) ""Hyades UI"" [Resolved]
org.eclipse.jdt (3.2.0.v20060427-2000) ""Eclipse Java Development Tools"" [Resolved]
org.eclipse.jdt.apt.core (3.2.0.v20060503-2020) ""Java Annotation Processing Core"" [Active]
org.eclipse.jdt.apt.ui (3.2.0.v20060503-2020) ""Java Annotation Processing UI"" [Resolved]
org.eclipse.jdt.core (3.2.0.v_665) ""Java Development Tools Core"" [Active]
org.eclipse.jdt.core.manipulation (1.0.0.v20060427-1600) ""Java Code Manipulation Functionality"" [Resolved]
org.eclipse.jdt.debug (3.2.0.v20060505) ""JDI Debug Model"" [Active]
org.eclipse.jdt.debug.ui (3.2.0.v20060504c) ""JDI Debug UI"" [Active]
org.eclipse.jdt.doc.isv (3.2.0.v20060427-1600) ""Eclipse JDT Plug-in Developer Guide"" [Resolved]
org.eclipse.jdt.doc.user (3.2.0.v20060505-0010) ""Eclipse Java Development User Guide"" [Resolved]
org.eclipse.jdt.junit (3.2.0.v20060505-1236) ""Java Development Tools JUnit support"" [Active]
org.eclipse.jdt.junit.runtime (3.2.0.v20060505-1236) ""Java Development Tools JUnit runtime support"" [Resolved]
org.eclipse.jdt.junit4.runtime (1.0.0.v20060505-1236) ""Java Development Tools JUnit4 runtime support"" [Resolved]
org.eclipse.jdt.launching (3.2.0.v20060504c) ""Java Development Tools Launching Support"" [Active]
org.eclipse.jdt.source (3.2.0.v20060428-0010-F7snp5ffnngadgn) ""Eclipse Java Development Tools SDK"" [Resolved]
org.eclipse.jdt.ui (3.2.0.v20060505-1236) ""Java Development Tools UI"" [Active]
org.eclipse.jem (1.1.0.1) ""Java EMF Model"" [Installed]
org.eclipse.jem (1.2.0.v20060405_I) ""Java EMF Model"" [Resolved]
org.eclipse.jem.beaninfo (1.1.0.1) ""Java EMF Model BeanInfo (Introspection) Support"" [Installed]
org.eclipse.jem.beaninfo (1.2.0.v20060405_I) ""Java EMF Model BeanInfo (Introspection) Support"" [Resolved]
org.eclipse.jem.proxy (1.1.0.1) ""Java EMF Model Proxy Support"" [Installed]
org.eclipse.jem.proxy (1.2.0.v20060405_I) ""Java EMF Model Proxy Support"" [Active]
org.eclipse.jem.sdk (1.1.0) ""Java EMF Model SDK"" [Resolved]
org.eclipse.jem.source (1.1.0.1) ""Java EMF Model Source"" [Resolved]
org.eclipse.jem.ui (1.1.0.1) ""Java EMF Model UI"" [Installed]
org.eclipse.jem.ui (1.2.0.v20060227_S) ""Java EMF Model UI"" [Resolved]
org.eclipse.jem.util (1.1.0.1) ""Java EMF Model Utilities"" [Installed]
org.eclipse.jem.util (1.2.0.v20060227_S) ""Java EMF Model Utilities"" [Active]
org.eclipse.jem.workbench (1.1.0.1) ""Java EMF Model Workbench Support"" [Installed]
org.eclipse.jem.workbench (1.2.0.v20060405_I) ""Java EMF Model Workbench Support"" [Resolved]
org.eclipse.jface (3.2.0.I20060505-1200) ""JFace"" [Resolved]
org.eclipse.jface.databinding (1.0.0.I20060412-0800) ""JFace Data Binding"" [Resolved]
org.eclipse.jface.text (3.2.0.v20060505-0010) ""JFace Text"" [Resolved]
org.eclipse.ltk.core.refactoring (3.2.0.v20060505-1236) ""Refactoring Core"" [Active]
org.eclipse.ltk.ui.refactoring (3.2.0.v20060505-1236) ""Refactoring UI"" [Active]
org.eclipse.osgi.services (3.1.100.v20060426) ""OSGi Release 3 Services"" [Resolved]
org.eclipse.osgi.util (3.1.100.v20060426) ""OSGi R3 Utility Classes"" [Resolved]
org.eclipse.pde (3.2.0.v20060504-0800a) ""Eclipse Plug-in Development Environment"" [Resolved]
org.eclipse.pde.build (3.2.0.v20060505a) ""Plug-in Development Environment Build Support"" [Resolved]
org.eclipse.pde.core (3.2.0.v20060505-0010) ""Plug-in Development Core"" [Active]
org.eclipse.pde.doc.user (3.2.0.v20060504-1200) ""Eclipse Plug-in Development User Guide"" [Resolved]
org.eclipse.pde.junit.runtime (3.2.0.v20060504-0800) ""PDE JUnit Plug-in Test"" [Resolved]
org.eclipse.pde.runtime (3.2.0.v20060504-0800) ""Plug-in Development Environment Runtime"" [Active]
org.eclipse.pde.source (3.2.0.v20060427-2000-zXJJzJsJooHgIHo) ""Eclipse Plug-in Development Environment Developer Resources"" [Resolved]
org.eclipse.pde.ui (3.2.0.v20060505-0011) ""Plug-in Development UI"" [Resolved]
org.eclipse.platform (3.2.0.v20060505) ""Eclipse Platform"" [Active]
org.eclipse.platform.doc.isv (3.2.0.v20060503a) ""Eclipse Platform Plug-in Developer Guide"" [Resolved]
org.eclipse.platform.doc.user (3.2.0.v20060503) ""Eclipse Workbench User Guide"" [Resolved]
org.eclipse.platform.source (3.2.0.v20060503-1530-7gOepm_tjppfKda) ""Eclipse Platform Plug-in Developer Resources"" [Resolved]
org.eclipse.platform.source.win32.win32.x86 (3.2.0.v20060503-1530-7gOepm_tjppfKda) ""Eclipse Platform Plug-in Developer Resources"" [Resolved]
org.eclipse.rcp (3.2.0.v20060428-0010) ""Eclipse RCP"" [Resolved]
org.eclipse.rcp.source (3.2.0.v20060427-2000-SVDNgOq2-4-Z3TS) ""Eclipse RCP Plug-in Developer Resources"" [Resolved]
org.eclipse.rcp.source.win32.win32.x86 (3.2.0.v20060427-2000-SVDNgOq2-4-Z3TS) ""Eclipse RCP Plug-in Developer Resources"" [Resolved]
org.eclipse.sdk (3.2.0.v20060503) ""Eclipse Project SDK"" [Resolved]
org.eclipse.search (3.2.0.v20060427-1600) ""Search Support"" [Resolved]
org.eclipse.swt (3.2.0.v3232e) ""Standard Widget Toolkit"" [Resolved]
org.eclipse.swt.sleak (1.0.0) ""Sleak Tool"" [Resolved]
org.eclipse.swt.win32.win32.x86 (3.2.0.v3232) ""Standard Widget Toolkit for Windows"" [Resolved]
org.eclipse.target (1.0.0) ""Target Plug-in"" [Resolved]
org.eclipse.target.ftp (1.0.0) ""Ftp Plug-in"" [Resolved]
org.eclipse.target.ide (1.0.0) ""Target IDE Plug-in"" [Resolved]
org.eclipse.target.iofile (1.0.0) ""I/O File Plug-in"" [Resolved]
org.eclipse.target.webdav (1.0.0) ""Target WebDAV Plug-in"" [Resolved]
org.eclipse.team.core (3.2.0.I200605031640) ""Team Support Core"" [Active]
org.eclipse.team.cvs.core (3.2.0.I200605031640) ""CVS Team Provider Core"" [Active]
org.eclipse.team.cvs.ssh (3.2.0.I200603291800) ""CVS SSH Core"" [Resolved]
org.eclipse.team.cvs.ssh2 (3.2.0.I200604261810) ""CVS SSH2"" [Active]
org.eclipse.team.cvs.ui (3.2.0.I200605042000) ""CVS Team Provider UI"" [Active]
org.eclipse.team.ui (3.2.0.I200605031640) ""Team Support UI"" [Active]
org.eclipse.text (3.2.0.v20060427-1600) ""Text"" [Resolved]
org.eclipse.tomcat (4.1.130.v20060417) ""Tomcat Wrapper"" [Resolved]
org.eclipse.tptp.monitoring.doc.user (4.0.0) ""TPTP Monitoring Tools Documentation"" [Resolved]
org.eclipse.tptp.monitoring.logui (4.0.0) ""Logui Plug-in"" [Installed]
org.eclipse.tptp.monitoring.source (4.0.1) ""TPTP Monitoring Source"" [Resolved]
org.eclipse.tptp.platform.agentcontroller (4.0.1) ""TPTP Agent Controller"" [Resolved]
org.eclipse.tptp.platform.agentcontroller.doc.user (4.0.0) ""Agent Controller documentation"" [Resolved]
org.eclipse.tptp.platform.analysis.engine.source (4.0.0) ""TPTP Analysis Engine Source"" [Resolved]
org.eclipse.tptp.platform.analysis.examples (4.0.1) ""TPTP Static Analysis Examples Plug-in"" [Resolved]
org.eclipse.tptp.platform.analysis.metrics (4.0.0) ""Metrics Plug-in"" [Resolved]
org.eclipse.tptp.platform.analysis.source (4.0.1) ""TPTP Analysis Feature Source"" [Resolved]
org.eclipse.tptp.platform.analysis.static.doc.user (4.0.1) ""Static Analysis User Documentation"" [Resolved]
org.eclipse.tptp.platform.analysis.static.engine (4.0.0) ""TPTP Static Analysis Engine Plugin"" [Resolved]
org.eclipse.tptp.platform.analysis.static.engine.ui (4.0.0) ""TPTP Static Analysis Engine UI Plugin"" [Resolved]
org.eclipse.tptp.platform.analysis.static.util (4.0.0) ""TPTP Static Analysis Utilities Plugin"" [Resolved]
org.eclipse.tptp.platform.analysis.static.util.ui (4.0.1) ""TPTP Analysis UI Utilities Plugin"" [Resolved]
org.eclipse.tptp.platform.collection.framework (4.0.0) ""TPTP Collection Framework"" [Installed]
org.eclipse.tptp.platform.core.source (4.0.1) ""TPTP Core Source"" [Resolved]
org.eclipse.tptp.platform.doc.user (4.0.0) ""TPTP Platform Project Documentation"" [Resolved]
org.eclipse.tptp.platform.log.views (4.0.0) ""Hyades Logging Sequence Diagrams"" [Installed]
org.eclipse.tptp.platform.lta.source (4.0.0) ""TPTP Log and Trace Analyzer Source"" [Resolved]
org.eclipse.tptp.platform.models (4.0.0) ""Hyades Models"" [Resolved]
org.eclipse.tptp.platform.probekit.source (4.0.1) ""TPTP ProbeKit Source"" [Resolved]
org.eclipse.tptp.platform.report.core (4.0.0) ""TPTP Report Framework"" [Installed]
org.eclipse.tptp.platform.report.source (4.0.0) ""TPTP Charting Service Source"" [Resolved]
org.eclipse.tptp.platform.report.ui (4.0.0) ""TPTP Report UI"" [Installed]
org.eclipse.tptp.platform.samples.source (4.0.0) ""TPTP Platform Samples Source"" [Resolved]
org.eclipse.tptp.platform.statistical.ui.source (4.0.1) ""TPTP Statistical UI Source"" [Resolved]
org.eclipse.tptp.platform.trace.source (4.0.0) ""TPTP Platform Trace Source"" [Resolved]
org.eclipse.tptp.test.samples (4.0.0) ""TPTP Test Tools UI Plug-In"" [Installed]
org.eclipse.tptp.test.samples.source (4.0.0) ""TPTP Test Samples Source"" [Resolved]
org.eclipse.tptp.test.source (4.0.1) ""TPTP Test Source"" [Resolved]
org.eclipse.tptp.test.tools.source (4.0.1) ""TPTP Test Tools Source"" [Resolved]
org.eclipse.tptp.trace.source (4.0.0) ""TPTP Trace Source"" [Resolved]
org.eclipse.ui (3.2.0.I20060505-1200) ""Eclipse UI"" [Active]
org.eclipse.ui.browser (3.2.0.v20060417) ""Browser Support"" [Resolved]
org.eclipse.ui.cheatsheets (3.2.0.v20060503) ""Cheat Sheets"" [Resolved]
org.eclipse.ui.console (3.1.100.v20060504c) ""Console"" [Active]
org.eclipse.ui.editors (3.2.0.v20060504-0800) ""Default Text Editor"" [Active]
org.eclipse.ui.externaltools (3.1.100.v20060425) ""External Tools"" [Active]
org.eclipse.ui.forms (3.2.0.v20060504) ""Eclipse Forms"" [Resolved]
org.eclipse.ui.ide (3.2.0.I20060504-0800) ""Eclipse IDE UI"" [Active]
org.eclipse.ui.intro (3.2.0.v20060503) ""Welcome Framework"" [Resolved]
org.eclipse.ui.intro.universal (3.2.0.v20060504) ""Universal Welcome"" [Resolved]
org.eclipse.ui.navigator (3.2.0.I20060504-1600) ""Common Navigator View"" [Resolved]
org.eclipse.ui.navigator.resources (3.2.0.I20060427-0800) ""Navigator Workbench Components"" [Resolved]
org.eclipse.ui.presentations.r21 (3.2.0.I20060412-0800) ""R21 Presentation Plug-in"" [Resolved]
org.eclipse.ui.views (3.2.0.I20060413-1200) ""Views"" [Active]
org.eclipse.ui.views.properties.tabbed (3.2.0.I20060427-0800) ""Tabbed Properties View"" [Resolved]
org.eclipse.ui.win32 (3.2.0.I20060412-0800) ""Eclipse UI Win32 Enhancements"" [Resolved]
org.eclipse.ui.workbench (3.2.0.I20060505-1200) ""Workbench"" [Active]
org.eclipse.ui.workbench.compatibility (3.2.0.I20060207-0800) ""Workbench Compatibility"" [Resolved]
org.eclipse.ui.workbench.texteditor (3.2.0.v20060504-0800) ""Text Editor Framework"" [Active]
org.eclipse.update.configurator (3.1.100.v20060505) ""Install/Update Configurator"" [Active]
org.eclipse.update.core (3.1.100.v20060504a) ""Install/Update Core"" [Active]
org.eclipse.update.core.win32 (3.1.100.v20051205) ""Install/Update Core for Windows"" [Resolved]
org.eclipse.update.scheduler (3.1.100.v20060504) ""Automatic Updates Scheduler"" [Active]
org.eclipse.update.ui (3.1.100.v20060504a) ""Install/Update UI"" [Resolved]
org.eclipse.ve (1.1.0) ""Visual Editor"" [Resolved]
org.eclipse.ve (1.2.0.v20060227_S) ""Visual Editor"" [Resolved]
org.eclipse.ve.cde (1.1.0.1) ""Visual Editor Common Data Editor"" [Installed]
org.eclipse.ve.cde (1.2.0.v20060227_S) ""Visual Editor Common Data Editor"" [Resolved]
org.eclipse.ve.doc (1.1.0) ""Visual Editor for Java User Guide"" [Installed]
org.eclipse.ve.doc (1.2.0.v20060227_S) ""Visual Editor for Java User Guide"" [Resolved]
org.eclipse.ve.java.core (1.1.0.1) ""Visual Editor Java Core"" [Installed]
org.eclipse.ve.java.core (1.2.0.v20060406_I) ""Visual Editor Java Core"" [Active]
org.eclipse.ve.jfc (1.1.0.1) ""Visual Editor for Java Foundation Classes"" [Installed]
org.eclipse.ve.jfc (1.2.0.v20060405_I) ""Visual Editor for Java Foundation Classes"" [Resolved]
org.eclipse.ve.propertysheet (1.1.0.1) ""Visual Editor PropertySheet"" [Resolved]
org.eclipse.ve.propertysheet (1.2.0.v20060227_S) ""Visual Editor PropertySheet"" [Resolved]
org.eclipse.ve.sdk (1.1.0) ""Visual Editor SDK"" [Resolved]
org.eclipse.ve.source (1.1.0.1) ""Visual Editor Source"" [Resolved]
org.eclipse.ve.swt (1.1.0.1) ""Visual Editor for Standard Widget Toolkit"" [Installed]
org.eclipse.ve.swt (1.2.0.v20060406_I) ""Visual Editor for Standard Widget Toolkit"" [Active]
org.eclipse.webdav (3.0.0) ""WebDAV Client"" [Resolved]
org.eclipse.xsd (2.1.1) ""XML Schema Infoset Model (XSD)"" [Resolved]
org.eclipse.xsd.doc (2.1.0) ""XML Schema Infoset Model (XSD) Programmers Guide"" [Installed]
org.eclipse.xsd.doc (2.1.1) ""XML Schema Infoset Model (XSD) Programmers Guide"" [Resolved]
org.eclipse.xsd.ecore.importer (2.1.0) ""XML Schema Importer for EMF"" [Resolved]
org.eclipse.xsd.edit (2.1.0) ""XML Schema Edit Framework"" [Resolved]
org.eclipse.xsd.editor (2.1.0) ""XML Schema Editor"" [Resolved]
org.eclipse.xsd.source (2.1.0) ""XML Schema Infoset Model (XSD) Source"" [Installed]
org.eclipse.xsd.source (2.1.1) ""XML Schema Infoset Model (XSD) Source"" [Resolved]
org.junit (3.8.1) ""JUnit Testing Framework"" [Resolved]
org.junit4 (4.1.0) ""JUnit Testing Framework Version 4"" [Resolved]
ru.nlmk.eclipse.plugins.profiler (0.5.33) ""Profiler Plug-in"" [Resolved]
ru.nlmk.eclipseutilplugins (1.0.0) ""Utils Plug-in"" [Active]
system.bundle (3.2.0.v20060505) ""OSGi System Bundle"" [Active]
uky.article.imageviewer (1.0.0) ""image viewer Plug-in"" [Resolved]
Martin Aeschlimann 2006-05-09 04:09:05 EDT
Looks more like a bug in pull up.
Tobias Widmer 2006-05-09 04:42:19 EDT
I am not able to reproduce this on 3.2 RC2. Could you please give detailed steps (which version you are using and which members to you extract)?
Tobias Widmer 2006-05-09 04:46:25 EDT
Sorry, I missed the comments above...

Strange enough, it only happens on RC3 if all members are selected
Tobias Widmer 2006-05-10 06:15:07 EDT
Created attachment 40919 [details]
patch
Tobias Widmer 2006-05-10 06:16:06 EDT
Martin, this may be a 3.2 RC4 candidate.
Martin Aeschlimann 2006-05-10 06:21:58 EDT
Can you explain the patch? Why would the working copy have a differeny content and why would reconcile be required?
And how is this related to the AST rewrite error?
Tobias Widmer 2006-05-10 07:00:11 EDT
In order to let Extract Superclass reuse the functionality provided by Pull Up and Use Supertype, we create working copies for the declaring type (the input of the refactoring) and all types on the same level of the type hierarchy (thus those having a common proper ancestor)

So those working copies can have a different content than the ones on disk. In the method registerChanges() we assemble the resulting change from the layer change (ie. adding extends clause) and the pull up/use supertype changes in a MultiStateCompilationUnitChange.

If the content of the working copies is not reset, the ast rewriter finds a cu which is not in sync with the ast anymore.

But I cannot explain why this only fails with an exception if all members are selected.
Tobias Widmer 2006-05-12 06:44:09 EDT
Created attachment 41296 [details]
simplified patch

This patch tries to recreate the handle using the private working copy owner and additionally ensures that the working copy has been created before resolving the rest of the handles in the refactoring arguments
Tobias Widmer 2006-05-12 07:01:27 EDT
Comment on attachment 41296 [details]
simplified patch

This is the wrong bug...
Martin Aeschlimann 2006-05-12 12:50:11 EDT
Created attachment 41330 [details]
new patch
Philipe Mulet 2006-05-12 12:59:49 EDT
+1 for 3.2RC4
Martin Aeschlimann 2006-05-12 15:29:03 EDT
Created attachment 41364 [details]
latest patch

Better approach. The problem is that the AST rewrite is applied on a modified document. This is not allowed; the patch is a workaround that avoids that the rewriter gets in an invalid state.

Tested by Markus, me and Tobias. Existing tests all pass.
Darin Wright 2006-05-12 15:32:44 EDT
+1 for RC4
Martin Aeschlimann 2006-05-12 15:35:55 EDT
latest patch released for RC4
Dani Megert 2006-05-12 15:37:44 EDT
+1 for 3.2 RC4.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=138320,138320,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] CCE in Change method signature,2006/5/12,crash,0,1,input options,rename method,nan,"Bug 138320 - [refactoring] CCE in Change method signature
Tobias Widmer 2006-04-25 06:05:31 EDT
N20060423-0010

Steps to reproduce:

- Use CMS to rename a method

ChangeSignatureRefactoring$ReferenceUpdate(ChangeSignatureRefactoring$OccurrenceUpdate).getTightSourceRangeComputer() line: 1674
ChangeSignatureRefactoring$ReferenceUpdate(ChangeSignatureRefactoring$OccurrenceUpdate).changeMethodName() line: 1657
ChangeSignatureRefactoring$ReferenceUpdate.updateNode() line: 1689
ChangeSignatureRefactoring$DeclarationUpdate.addDelegate() line: 1855
ChangeSignatureRefactoring$DeclarationUpdate.updateNode() line: 1833
ChangeSignatureRefactoring.createChangeManager(IProgressMonitor, RefactoringStatus) line: 1277
ChangeSignatureRefactoring.checkFinalConditions(IProgressMonitor) line: 812
CheckConditionsOperation.run(IProgressMonitor) line: 83
CreateChangeOperation.run(IProgressMonitor) line: 118
UIPerformChangeOperation(PerformChangeOperation).run(IProgressMonitor) line: 189
Workspace.run(IWorkspaceRunnable, ISchedulingRule, int, IProgressMonitor) line: 1737
WorkbenchRunnableAdapter.run(IProgressMonitor) line: 87
ModalContext$ModalContextThread.run() line: 113
Markus Keller 2006-04-26 14:15:54 EDT
Useful steps:

Change signature of abs(): change name & have delegate checkboxes checked:

public class Try {
	void abc() {}
	void ref() {
		abc();
	}
}
Markus Keller 2006-04-26 15:03:33 EDT
Fixed in HEAD and added regression test.
Johannes Rieken 2006-05-12 09:12:44 EDT
verifying for I20060512-0010
Johannes Rieken 2006-05-12 09:16:29 EDT
verified
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=44419,44419,P2,JDT,UI,dirk_baeumer,VERI,FIXE,inline method: arguments need to be parentized [refactoring],2006/5/10,behavior change,0,1,arithmetic expression,inline method,nan,"Bug 44419 - inline method: arguments need to be parentized [refactoring]
Martin Aeschlimann 2003-10-08 08:33:58 EDT
20031008
	protected long fValue1= getValue(1 + 3);
	
	private long getValue(int i) {
		return System.currentTimeMillis() * i;
	}
results in:

        protected long fValue1= System.currentTimeMillis() * 1 + 3;
David Mandelin 2005-04-05 19:21:49 EDT
The method body also needs to be parenthesized. The refactoring didn't work for
me on this example:

    if (!isString(s)) ...
    
    boolean isString(Object o) {
        return o instanceof String;
    }

I got

    if (!s instanceof String) ...

which is even a type error.
Dirk Baeumer 2006-04-07 05:14:11 EDT
Fixed for RC1.

The problematic thing with this bug was that it introduced a semantic shift hard to spot.
Dirk Baeumer 2006-04-07 05:16:50 EDT
Setting to fixed
Markus Keller 2006-04-07 13:46:28 EDT
*** Bug 135115 has been marked as a duplicate of this bug. ***
Johannes Rieken 2006-04-27 04:28:44 EDT
verified for 20060426
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=108030,108030,P2,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Move instance method inserts argument at wrong position,2006/5/10,compile error,0,1,nan,move method,nan,"Bug 108030 - [refactoring] Move instance method inserts argument at wrong position
Markus Keller 2005-08-25 14:36:54 EDT
I20050823-0800

class A {
    B fB;
    
    public void doit(String doitArg) {
        subroutine(1.2f);
    }
    
    public void subroutine(float subArg) {
        subsub();
    }

    public void subsub() {
        
    }
    
}

class B {
    
}

- move doit(..) to fB
  -> compiles
- move subroutine(..) to fB
  -> does not compile since subroutine's new parameter  A a is at first position
but the argument at the call site is at the second position

Please fix and add a second test case where methods have 2 or more parameters.
Tobias Widmer 2005-08-26 05:02:59 EDT
Filed related bug 108088
Tobias Widmer 2006-04-26 09:13:44 EDT
Fixed by fix for 36032

Added regression test MoveInstanceMethodTests#test36
Johannes Rieken 2006-05-10 03:49:11 EDT
verifying for RC3
Johannes Rieken 2006-05-10 03:54:30 EDT
verified
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=77438,77438,P3,JDT,UI,tobias_widmer,RESO,FIXE,Pull up: static reference not adapted [refactoring] [pull up],2006/4/20,compile error,0,1,nan,pull up field,nan,"Bug 77438 - Pull up: static reference not adapted [refactoring] [pull up]
Dirk Baeumer 2004-11-01 19:06:55 EST
I200410260800

package p1;

public class Super {
}

------------------------------------------------------

package p1;

public class A extends Super {
	public static final int VALUE= 10;
}

-------------------------------------------------------

package p2;

import p1.A;

public class B {
	int field= A.VALUE;
}

Pull up VALUE from A to Super. Observe that A.VALUE isn't corrected to Super.VALUE.
Dirk Baeumer 2004-11-01 19:15:56 EST
Time permitted for 3.1. Tobias, how expensive would this be.
Tobias Widmer 2004-11-03 06:26:34 EST
The references to a member to pull up are computed anyway, to determine 
whether a member is referenced from other members which are not pulled up.
Since this information is cached, we could use the search results and modify 
the static references.
Tobias Widmer 2006-04-20 04:50:18 EDT
This is fixed in N20060418-0010 and greater
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=120432,120432,P3,JDT,UI,tobias_widmer,RESO,FIXE,"[refactoring] ""Move Member Type to New File"" crashes when going back after an error",2006/4/12,crash,0,1,inner class,move member type to new file,nan,"Bug 120432 - [refactoring] ""Move Member Type to New File""  crashes when going back after an error
Michael Schierl 2005-12-12 14:36:42 EST
This bug might be related to bug 40647 which has been closed. But since my stack trace is different, I'll open a new one.

Take this class:

package movebug;

public class Outer {
	private int field;
	private class Inner {
		public Inner() {
			field++;
		}
	}
}


- right click the Inner class
- do refactor -> move member type to new file
- say OK
- See that there are problems. (field ""field"" is too private).
- Select back.
- Select preview.
- Boom.

Alternatively, select ok instead of preview.


rest below is log file

!SESSION 2005-12-12 20:23:24.37 ------------------------------------------------
eclipse.buildId=M20050929-0840
java.version=1.5.0_05
java.vendor=Sun Microsystems Inc.
BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_DE
Command-line arguments:  -os win32 -ws win32 -arch x86

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2005-12-12 20:25:10.890
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:293)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:573)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:416)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed(RefactoringWizardDialog2.java:447)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:445)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:584)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:809)
	at org.eclipse.jface.window.Window.open(Window.java:787)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:275)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:154)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:843)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3080)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2713)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1699)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1663)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:367)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:278)
	at org.eclipse.core.launcher.Main.run(Main.java:973)
	at org.eclipse.core.launcher.Main.main(Main.java:948)
Caused by: org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: null argument;
	at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:108)
	at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:86)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.findTypeDeclaration(MoveInnerToTopRefactoring.java:406)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createNewSource(MoveInnerToTopRefactoring.java:1020)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:839)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:743)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: null argument;
	at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:108)
	at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:86)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.findTypeDeclaration(MoveInnerToTopRefactoring.java:406)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createNewSource(MoveInnerToTopRefactoring.java:1020)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:839)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:743)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Martin Aeschlimann 2005-12-12 15:36:05 EST
can you investigate if we can and should fix this for M4?
Tobias Widmer 2005-12-13 05:42:56 EST
*** This bug has been marked as a duplicate of 101863 ***
Michael Schierl 2005-12-13 08:39:04 EST
hmm? 

101863 is marked as fixed for 3.1.1

*This* bug has been found in 3.1.1. How can they be duplicates?

(or should I reopen 101863 since that fix did not fix it completely?)
Tobias Widmer 2005-12-13 09:24:43 EST
Oops, my mistake...
Tobias Widmer 2005-12-13 09:26:58 EST
The bug manifests itself only if pressing back. Fixing this would require some rewriting, which is probably not for M4
Tobias Widmer 2006-04-12 04:39:30 EDT
Fixed in HEAD > 20060412
"
50139 â [refactoring] [inline] inline static method fails to qualify access to field,50139,P3,JDT,UI,dirk_baeumer,RESO,FIXE,[refactoring] [inline] inline static method fails to qualify access to field,2006/4/7,compile error,0,1,static method,inline method,nan,
https://bugs.eclipse.org/bugs/show_bug.cgi?id=98856,98856,P3,JDT,UI,dirk_baeumer,RESO,FIXE,[refactoring] Inlining method results in compiler errors.,2006/4/7,compile error,0,1,nan,inline method,nan,"Bug 98856 - [refactoring] Inlining method results in compiler errors.
Brian Miller 2005-06-07 18:52:55 EDT
Inline the method Derived.routeOrder(...) and see that the incremental 
compiler marks many lines as erroneous (red x).  Source file attached.  I'm 
using RC1.
Brian Miller 2005-06-07 18:53:44 EDT
Created attachment 22575 [details]
Bug.java
Brian Miller 2005-06-14 12:29:29 EDT
Same problem in RC2.
Dirk Baeumer 2005-06-14 13:51:27 EDT
True, and it will very likely stay in 3.1
Dirk Baeumer 2006-04-05 14:22:03 EDT
Might be related to bug 50139.
Brian Miller 2006-04-05 14:38:18 EDT
Still broken in 3.2M6.

This bug involves inlining an instance method.  Bug 50139 regards inlining a static method.
Dirk Baeumer 2006-04-07 05:54:57 EDT
Smaller test case:

public class Bug {
	
	class Inner {
		String field;
	}
	
	Inner inner;
	String string;
	
	static void foo() {
		Bug b= new Bug();
		b.bar();
	}
	
	void bar() {
		inner.field= ""Eclipse"";
		string= ""Eclipse"";
	}
}
Dirk Baeumer 2006-04-07 06:56:46 EDT
Fixed for RC1.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=123356,123356,P3,JDT,UI,dirk_baeumer,RESO,FIXE,[inline refactoring] Method inlining breaks runtime behavior.,2006/4/7,behavior change,0,1,nan,inline method,nan,"Bug 123356 - [inline refactoring] Method inlining breaks runtime behavior.
Brian Miller 2006-01-10 19:11:14 EST
This program runs fine as is.  But if the add(x,y) method is inlined, then the resulting logic compiles but throws an NPE at runtime.

public class Bug {
    static String[]field;
    public static void main(String[]args){
        add((field=args).length,field.hashCode());
    }
    static int add(int x, int y){
        return y+x;
    }
}
Dirk Baeumer 2006-04-04 14:14:13 EDT
Fixed for RC1.

Test case added. Fix is to evaluate the arguments and store them into temporary locals to ensure that the evaluation of the args is happening in the correct order. This only happens if var assigments like in the example happen.
Dirk Baeumer 2006-04-07 05:16:34 EDT
Setting to fixed.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97213,97213,P3,JDT,UI,tobias_widmer,RESO,FIXE,"Push [refactoring] Down into java14 project does not convert static imports, varargs",2006/4/6,compile error,0,1,varargs,push down method,nan,"Bug 97213 - Push [refactoring] Down into java14 project does not convert static imports, varargs
Tom Hofmann 2005-05-30 06:37:18 EDT
3.1-RC1 test pass

- have the sources below
- pushdown stat() to Subtype
- pushed down method uses varargs albeit in Java14 project
- pushed down CU does not get the import to Math.abs

--------- SuperType.java (Java 5 project) -----
package com.superclass;





import static java.lang.Math.*;



public class SuperType<ELEM extends Number> {

	int stat(Integer j) {

		return min(j, 42, 52, abs(32));

	}



	int min(int head, int... tail) {

		int min= head;

		for (int i : tail)

			min= min(i,min);

		return min;

	}



}
----------- SubType.java (Java 1.4 project) ------
package com.example;



import com.superclass.SuperType;





public class SubType extends SuperType {

}
-----------------------------------

Alternatively, push down min() along with stat(). Note that the vararg signature
and new for loop are both kept in source, resulting in errors.

I guess it is ok not to convert the language constructs, but we might want to
issue a warning.
Dirk Baeumer 2005-05-30 17:26:40 EDT
Annoying, but not critical for 3.1
Tobias Widmer 2006-04-06 11:07:26 EDT
Added warning messages to Pull Up and Push Down

Fixed in HEAD > 20060406
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=109280,109280,P3,JDT,UI,dirk_baeumer,RESO,FIXE,[refactoring] [extract method] Extract Method fails to send a required parameter,2006/4/3,compiler error,0,1,nan,extract method,fail to pass all parameters of original signature,"Bug 109280 - [refactoring] [extract method] Extract Method fails to send a required parameter
Ran Ettinger 2005-09-12 07:45:11 EDT
Applying the Extract Method refactoring to the following selection results in 
a new method that fails to compile.

Original program:

  private int f(boolean b1, boolean b2) {
    int n = 0;
    int i = 0;
    // Extract Method from here
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    // to here
    return n;
  }

Applying Extract Method on the selected code (signalled by the comments)
results with the following code: 

  private int f(boolean b1, boolean b2) {
    int n = 0;
    int i = 0;
    n = newMethod(b1, b2, n);
    return n;
  }

  private int newMethod(boolean b1, boolean b2, int n) {
    int i;
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    return n;
  }

Problem: Eclipse did not identify that the local variable i should be sent as 
a parameter. The program doesn't compile anymore, because in the statement n = 
n + i; in the new method, ""the local variable i may not have been initialized"".

I expected the refactored source to look like this:
 
  private int f(boolean b1, boolean b2) {
    int n = 0;
    int i = 0;
    n = newMethod(b1, b2, n, i);
    return n;
  }

  private int newMethod(boolean b1, boolean b2, int n, int i) {
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    return n;
  }
Dirk Baeumer 2005-09-12 08:19:55 EDT
Sending i to the method is actually not needed since i isn't changed at read
outside of the refactored code. So the correct extract method has to look like this

  private int newMethod(boolean b1, boolean b2, int n) {
    int i= 0;
    if (b1)
      i = 1;
    if (b2)
      n = n + i;
    return n;
  }
Dirk Baeumer 2006-04-03 09:49:26 EDT
Not passing i is only possible in the given case. If i is initialized with a construct that more complicated than a constant then it might not be possible to initialize the new local in the extracted method correctly. Reasons may be: code not visible since the body is generated in an outer class; reordering of statements which might break semantic. So the right thing to do here is to pass i.
Dirk Baeumer 2006-04-03 09:58:02 EDT
Fixed for RC1.
Dirk Baeumer 2006-04-03 12:04:13 EDT
*** Bug 116033 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=127665,127665,P3,JDT,UI,markus.kell.r,RESO,FIXE,Introduce Indirection refactoring results in compile error,2006/4/3,compile error,0,1,nan,introduce indirection,nan,"Bug 127665 - Introduce Indirection refactoring results in compile error
Dani Megert 2006-02-14 06:33:42 EST
I20060214-0010

0. create Java project 'P'
1. add Test.java:
public class Test {
	int foo() {
		return 1;
	}
	int useFoo() {
		return foo();
	}
}
class TestO extends Test {
	int useFoo() {
		return foo();
	}
}
2. select foo() in TestO.useFoo()
3. Refactor > Introduce Indirection

==> creates source with compile error:
public class Test {
	protected int foo() {
		return 1;
	}
	int useFoo() {
		return TestO.foo(this);
	}
}
class TestO extends Test {
	/*
	 * @see Test#foo()
	 * @since 3.2
	 */
	public static int foo(Test test) {
		return test.foo();
	}

	int useFoo() {
		return TestO.foo(Test.this);
	}
}
Markus Keller 2006-04-03 10:15:20 EDT
Fixed.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=48231,48231,P3,JDT,UI,markus.kell.r,VERI,FIXE,extract local variable could be smarter and introduce a block [refactoring] [extract local],2006/3/28,behavior change,0,1,nan,extract local variable,nan,"Bug 48231 - extract local variable could be smarter and introduce a block [refactoring] [extract local]
Erich Gamma 2003-12-07 11:32:06 EST
In the folowing code code snippet extract the expression a[i]
	public void testFoo() {
		int a[]= new int[20];
		
		for (int i= 0; i < a.length; i++) 
			System.out.println(a[i]);
	}

You get the error message that i cannot be resolved (this message is 
confusing). Then when I say proceed, incorrect code is generated:

	public void testFoo() {
		int a[]= new int[20];
		
		int j= a[i];
		for (int i= 0; i < a.length; i++) 
			System.out.println(j);
	}

The code I would have expected is:

	public void testFoo() {
		int a[]= new int[20];
		
		for (int i= 0; i < a.length; i++) {
		        int j= a[i];
			System.out.println(j);
                }
	}

This means the refactoring should be smart enough to introduce the local 
variable in the correct scope and to also introduce a new block.
Markus Keller 2004-08-11 11:55:14 EDT
*** Bug 71762 has been marked as a duplicate of this bug. ***
Rafael Chaves 2004-11-03 16:20:55 EST
Similar problem:

Enumeration e = <...>
while (e.hasMoreElements())
  System.out.println(e.nextElement()); << extract local variable

results in this:

Enumeration e = <...>
Object nextElement = e.nextElement();
while (e.hasMoreElements())
  System.out.println(nextElement);

The main problem is that this does not cause any compiler error, it is just a
logic error, so it may not be easy to catch.
Dirk Baeumer 2004-11-04 04:48:17 EST
I got tricked by this lately as well.

Markus, can we do something here.
Markus Keller 2005-06-22 08:44:37 EDT
Moving to 3.2.
Markus Keller 2005-12-14 11:22:59 EST
*** Bug 120811 has been marked as a duplicate of this bug. ***
Markus Keller 2006-03-21 04:16:38 EST
*** Bug 131556 has been marked as a duplicate of this bug. ***
Markus Keller 2006-03-21 04:35:10 EST
*** Bug 102134 has been marked as a duplicate of this bug. ***
Markus Keller 2006-03-21 04:37:32 EST
*** Bug 132047 has been marked as a duplicate of this bug. ***
Markus Keller 2006-03-21 04:45:47 EST
Fixed in HEAD.
Markus Keller 2006-03-22 05:03:06 EST
*** Bug 38105 has been marked as a duplicate of this bug. ***
Tobias Widmer 2006-03-28 10:07:34 EST
Verified using I20060328-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=118063,118063,P3,JDT,UI,tobias_widmer,RESO,FIXE,Duplicate public modifier on refactor move method,2006/3/16,compile error,0,1,nan,move method,nan,"Bug 118063 - Duplicate public modifier on refactor move method
John Arthorne 2005-11-25 10:21:15 EST
Build id: I20051122-0800

1) Start with these two CUs in different packages:

package p1;
class C {
}

package p2;
public class A {
	protected static void foo(int args) {}
	protected static void foo(int args, int moreArgs) {}
	private void bar() {
		foo(5);
		foo(5, 5);
	}
}

2) Select the two ""foo"" methods in the content outline, and choose Refactor > Move
3) Select p1.C as the destination
4) Click Finish on the refactoring.

-> The resulting code in C.java has compile errors:

package p1;
class C {
	public static void foo(int args) {}
	public public static void foo(int args, int moreArgs) {}
}

""Duplicate modifier for the method foo in type C""
John Arthorne 2006-01-19 09:41:53 EST
Still found in I20060118-0800.
Tobias Widmer 2006-03-16 14:09:27 EST
Fixed in HEAD > 20060316
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=131348,131348,P3,JDT,UI,tobias_widmer,RESO,FIXE,Pull up refactoring allows pulling fields into an interface,2006/3/10,compile error,0,1,nan,pull up field,overly weak precondition,"Bug 131348 - Pull up refactoring allows pulling fields into an interface
John Arthorne 2006-03-10 11:55:07 EST
I20060307-1315

Start with these two CUs:

public interface I {
}
public class C implements I {
	boolean value;
}

Select the ""value"" field, and run the ""Pull Up"" refactoring.  Select ""I"" as the destination of the refactoring.  No warnings are presented, but of course a non-final field doesn't make sense in an interface.  After the refactoring there is a compile error in ""I"".  The refactoring shouldn't allow  non-final fields to be pulled up (or at least warn against it).
Tobias Widmer 2006-03-10 12:13:14 EST
Fixed in HEAD > 20060310
John Arthorne 2006-03-10 12:17:45 EST
Wow, that was fast! ;)
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97521,97521,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] [move] Move method to generic type,2006/3/3,incorrect warning message ,0,1,java generics,move method,nan,"Bug 97521 - [refactoring] [move] Move method to generic type
David Saff 2005-05-31 11:18:22 EDT
In RC1, given code:

public class A {
	<T> void foo(B<T> b) {
		
	}
}

class B<T> {
	
}

Select ""foo"", and ""move method"".  b is offered as a target, but if selected, the
user is told: ""This method could not be moved to the specified target, since the
target is a generic entity"".  Ideally, the move would be allowed, since the type
parameters on the method and class match.  Failing that, would it be possible to
not offer b in the first place?
Dirk Baeumer 2005-05-31 13:39:48 EDT
Not critical for 3.1. Nice 3.2 candidate.
Tobias Widmer 2006-03-03 06:21:31 EST
Fixed in HEAD > 20060303
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=127661,127661,P3,JDT,UI,markus.kell.r,VERI,FIXE,Refactoring: status not updated upon changes in Introduce Indirection dialog,2006/2/16,incorrect warning message,0,1,nan,Introduce Indirection,nan,"Bug 127661 - Refactoring: status not updated upon changes in Introduce Indirection dialog
Dani Megert 2006-02-14 06:17:22 EST
I20060214-0010

Status not updated upon changes in Introduce Indirection dialog when using the 'Browse...' button or selecting a class from the drop down.

Test Case:
1. add CU Test.java with following source:
public class Test {
	int foo() {
		return 2;
	}
	int useFoo() {
		return foo();
	}
}
class P {}

2. select foo() in useFoo()
3. Refactor > Introduce Indirection
   ==> warning about duplicate foo()
4. use Browse... and select 'P'
==> warning stays.

Same if another class is selected from the drop down.
Martin Aeschlimann 2006-02-14 12:38:06 EST
if it's a trivial fix we should do it for M5
Martin Aeschlimann 2006-02-15 02:24:35 EST
for M5
Dani Megert 2006-02-15 03:21:29 EST
*** Bug 127981 has been marked as a duplicate of this bug. ***
Markus Keller 2006-02-15 07:11:05 EST
Fixed
Benno Baumgartner 2006-02-16 04:47:32 EST
verified in I20060216-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=127556,127556,P3,JDT,UI,tobias_widmer,VERI,FIXE,AssertionFailedException refactoring class to a new file,2006/2/16,exception,1,1,inner class,Move Member Type to New File,ast rewrite issue,"Bug 127556 - AssertionFailedException refactoring class to a new file
Tod Creasey 2006-02-13 16:13:17 EST
I got the following errors refactoring to a new file

STEPS
1) Load the attached project
2) Open NewAction
3) Select the private class Fred
4) Select Refactor -> Move Member Type to New File
5) Select OK (enter nothing in the dialog)

!ENTRY org.eclipse.ltk.core.refactoring 4 2 2006-02-13 16:11:57.375
!MESSAGE Problems occurred when invoking code from plug-in: ""org.eclipse.ltk.core.refactoring"".
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: assertion failed: 
	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:107)
	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:93)
	at org.eclipse.ltk.internal.core.refactoring.RefactoringSessionTransformer.createArgument(RefactoringSessionTransformer.java:183)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryManager.transformDescriptor(RefactoringHistoryManager.java:459)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryManager.addRefactoringDescriptor(RefactoringHistoryManager.java:705)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistorySerializer.processHistoryNotification(RefactoringHistorySerializer.java:106)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistorySerializer.historyNotification(RefactoringHistorySerializer.java:72)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$3.run(RefactoringHistoryService.java:217)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$RefactoringDescriptorStack.push(RefactoringHistoryService.java:210)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$RefactoringDescriptorStack.access$0(RefactoringHistoryService.java:202)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$RefactoringOperationHistoryListener.historyNotification(RefactoringHistoryService.java:379)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyListeners(DefaultOperationHistory.java:876)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyDone(DefaultOperationHistory.java:939)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.closeOperation(DefaultOperationHistory.java:1330)
	at org.eclipse.ltk.internal.core.refactoring.UndoManager2.changePerformed(UndoManager2.java:149)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:239)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1733)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1715)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:280)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.access$1(UIPerformChangeOperation.java:1)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$1.run(UIPerformChangeOperation.java:66)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$2.run(UIPerformChangeOperation.java:84)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3264)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2910)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:156)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:317)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:304)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:545)
	at org.eclipse.ltk.internal.ui.refactoring.ErrorWizardPage.performFinish(ErrorWizardPage.java:167)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:611)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:446)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:498)
	at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:645)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:811)
	at org.eclipse.jface.window.Window.open(Window.java:789)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:132)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:145)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:304)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:105)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:267)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:492)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:530)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:480)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:392)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1899)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1863)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:417)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:99)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)

!ENTRY org.eclipse.ltk.core.refactoring 4 10000 2006-02-13 16:11:57.390
!MESSAGE Internal Error
!STACK 0
org.eclipse.core.runtime.AssertionFailedException: assertion failed: 
	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:107)
	at org.eclipse.core.runtime.Assert.isTrue(Assert.java:93)
	at org.eclipse.ltk.internal.core.refactoring.RefactoringSessionTransformer.createArgument(RefactoringSessionTransformer.java:183)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryManager.transformDescriptor(RefactoringHistoryManager.java:459)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryManager.addRefactoringDescriptor(RefactoringHistoryManager.java:705)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistorySerializer.processHistoryNotification(RefactoringHistorySerializer.java:106)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistorySerializer.historyNotification(RefactoringHistorySerializer.java:72)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$3.run(RefactoringHistoryService.java:217)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$RefactoringDescriptorStack.push(RefactoringHistoryService.java:210)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$RefactoringDescriptorStack.access$0(RefactoringHistoryService.java:202)
	at org.eclipse.ltk.internal.core.refactoring.history.RefactoringHistoryService$RefactoringOperationHistoryListener.historyNotification(RefactoringHistoryService.java:379)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyListeners(DefaultOperationHistory.java:876)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.notifyDone(DefaultOperationHistory.java:939)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.closeOperation(DefaultOperationHistory.java:1330)
	at org.eclipse.ltk.internal.core.refactoring.UndoManager2.changePerformed(UndoManager2.java:149)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:239)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1733)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1715)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:280)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.access$1(UIPerformChangeOperation.java:1)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$1.run(UIPerformChangeOperation.java:66)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:37)
	at org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$2.run(UIPerformChangeOperation.java:84)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:123)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3264)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2910)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:156)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:317)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:304)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:545)
	at org.eclipse.ltk.internal.ui.refactoring.ErrorWizardPage.performFinish(ErrorWizardPage.java:167)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:611)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:446)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:498)
	at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:645)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:811)
	at org.eclipse.jface.window.Window.open(Window.java:789)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:132)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:145)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:304)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:105)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:267)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:492)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:530)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:480)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:392)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:925)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1899)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1863)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:417)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:99)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Tod Creasey 2006-02-13 16:14:25 EST
Created attachment 34617 [details]
Example project

Zip file of error against 20060213-1200
Martin Aeschlimann 2006-02-14 11:49:25 EST
Tobias, can you investigate if this is fixable for M5?
Tobias Widmer 2006-02-14 12:34:10 EST
Created attachment 34694 [details]
patch to not store empty strings
Tobias Widmer 2006-02-14 12:35:17 EST
Change MoveInnerToTopRefactoring to not create arguments for empty strings. The fix is very low risk.
Tobias Widmer 2006-02-15 04:00:49 EST
Fixed in HEAD > 20060215
Benno Baumgartner 2006-02-16 04:33:47 EST
verified in I20060216-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=113385,113385,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] [pull up] Pull up refactoring loses method annotation,2006/2/14,behavior change,0,1,annotation,pull up method,nan,"Bug 113385 - [refactoring] [pull up] Pull up refactoring loses method annotation
David Saff 2005-10-21 13:59:35 EDT
In M2.  Given code:

public class PullUpLosesAnnotation {
	
}

class SubclassA extends PullUpLosesAnnotation {
	@Deprecated public void foo() {}
}

Select foo, and Refactor > Pull Up.  The @Deprecated annotation is lost.  When
this happens to @Before or @Test in JUnit 4 test classes, the result is very
confusing.
Dirk Baeumer 2005-10-22 13:26:01 EDT
Tobias, can you please investigate. 

If easy to fix, we might want to back port it to 3.1.2.
Tobias Widmer 2005-11-14 09:36:51 EST
This is an easy fix (just copy all extended modifiers). I can backport it to 
3.1.2 if desired
Dirk Baeumer 2005-11-14 11:46:31 EST
+1 for 3.1.2.
Martin Aeschlimann 2006-01-05 10:10:35 EST
removing 3.1.2 tag. Ok to fix if time permitting.
Tobias Widmer 2006-01-11 12:39:55 EST
Fixed in HEAD > 20060111
Benno Baumgartner 2006-02-14 10:03:26 EST
verified in I20060214-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=102288,102288,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] Convert anonymous: generates fields for constants,2006/2/6,behavior change,1,1,anonymous class,inline class,Incorrect Type Resolving,"Bug 102288 - [refactoring] Convert anonymous: generates fields for constants
David Saff 2005-06-30 06:26:43 EDT
In 3.1.

Consider code:

public class Foo {	
	private static final int SEVEN = 7;
	private static final int FIVE = 5;

	public static void main(String[] args) {		
		Runnable runnable = new Runnable() {
			public void run() {
				System.out.println(""The answer is "" + (FIVE * SEVEN));
			}		
		};
		runnable.run();
	}
}

Select the anonymous Runnable, and execute Convert Anonymous Class to Nested. 
The result:

public class Foo {	
	private static class Twelve implements Runnable {
		private final int fFive;

		private final int fSeven;

		private Twelve(int five, int seven) {
			super();
			fFive = five;
			fSeven = seven;
		}

		public void run() {
			System.out.println(""The answer is "" + (fFive * fSeven));
		}
	}

	private static final int SEVEN = 7;
	private static final int FIVE = 5;

	public static void main(String[] args) {		
		Runnable runnable = new Twelve(FIVE, SEVEN);
		runnable.run();
	}
}

I never want this behavior--I want the constants to be used as constants.
Dirk Baeumer 2005-06-30 11:48:17 EDT
Tobias, can you please check what the result was in 3.0.2 ?
Tobias Widmer 2005-06-30 12:00:42 EDT
This is also the case in 3.0, 3.0.2.

We might think about putting some effort into the Convert Anonymous (and Move 
Member Type...) refactorings for 3.2. There are quite a few bugs open for 
those (code style, unnecessary code, missing cases, generics problems)
Dirk Baeumer 2005-08-10 06:57:24 EDT
We should definitelly improve this during the 3.2 time frame.
Markus Keller 2006-02-05 16:02:52 EST
Created attachment 34165 [details]
Fix

Here's a fix with test case.

The special case for enum constants has been fixed with bug 99681, but the general problem occurs for all final fields.
Tobias Widmer 2006-02-06 13:10:48 EST
Fixed in HEAD > 20060206
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=124659,124659,P3,JDT,UI,tobias_widmer,RESO,FIXE,java.lang.ArrayIndexOutOfBoundsException refactoring member type to seperate file,2006/1/20,exception,0,1,nan,Move Member Type to New File,nan,"Bug 124659 - java.lang.ArrayIndexOutOfBoundsException refactoring member type to seperate file
Tod Creasey 2006-01-20 10:41:46 EST
20050119

When I try and refactor a member type to a seperate file I get the exception below. I will attach the file in questions

STEPS
1) Select FileMarkerGroup#AttributeMapping
2) Select Refactor-> Move Member Type to New File
3) Deselect the enclosing instance field option
4) Hit OK

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2006-01-20 10:36:48.687
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:341)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:308)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:545)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:154)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:611)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:437)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:490)
	at org.eclipse.jface.dialogs.Dialog$3.widgetSelected(Dialog.java:637)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:920)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:811)
	at org.eclipse.jface.window.Window.open(Window.java:789)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:132)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:145)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:304)
	at org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:105)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:267)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:243)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:492)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:530)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:480)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:392)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:920)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3287)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2907)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1790)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1754)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:400)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:109)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:93)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:69)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:374)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:169)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: java.lang.ArrayIndexOutOfBoundsException: 1
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustMemberVisibility(MemberVisibilityAdjustor.java:534)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustMemberVisibility(MemberVisibilityAdjustor.java:523)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:729)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:800)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:723)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:117)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
java.lang.ArrayIndexOutOfBoundsException: 1
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustMemberVisibility(MemberVisibilityAdjustor.java:534)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustMemberVisibility(MemberVisibilityAdjustor.java:523)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:729)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:800)
	at org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:723)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:83)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:117)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:87)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Tod Creasey 2006-01-20 10:43:23 EST
Created attachment 33350 [details]
File that shows the issue
Tobias Widmer 2006-01-20 11:19:46 EST
Fixed in HEAD > 20060120
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=114509,114509,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] Move instance method with generating delegates unnecessarily raises field visibility,2006/1/11,unnecessary change,0,1,nan,move instance method,nan,"Bug 114509 - [refactoring] Move instance method with generating delegates unnecessarily raises field visibility
Benno Baumgartner 2005-11-01 08:48:04 EST
Version: 3.2.0
Build id: I20051031-2000

Having:
public class Foo {
	private Bar _bar;

	public void foo() {
		_bar.bar();
	}
}

public class Bar {
	public void bar() {}
	void x(Foo f) {
		f.foo();
	}
}

Then move Foo#foo to Bar with 'Create delegate in source type' enabled results
in changing visibility of field _bar to default. IMHO it can remain private.

see also bug 94975
Dirk Baeumer 2005-11-01 09:49:56 EST
Tobias, please investigate.
Tobias Widmer 2006-01-11 11:01:59 EST
Target needs no visibility update at all if leave delegate is enabled

Fixed in HEAD > 20060111
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=114539,114539,P2,JDT,Core,frederic_fusier,VERI,FIXE,[search] Internal error when refactoring code with errors,2006/1/10,crash,0,1,nan,move field,nan,"Bug 114539 - [search] Internal error when refactoring code with errors
Tom Hofmann 2005-11-01 10:31:10 EST
3.2 M3 test pass

- have the following two CUs in the 'org.foo' package:

----- Foo.java -----
public class Foo {
	int bar= Bar.FOO;
}
----- Bar.java -----
class Bar {
	private static final int FOO= 0;
}
--------------------

- note the compile error in Foo due to FOO being private
- in Bar.java, select FOO and choose Refactor>Move, target to type 'Foo'

> get this:

!ENTRY org.eclipse.ltk.ui.refactoring 4 10000 2005-11-01 16:28:48.229
!MESSAGE Internal Error
!STACK 0
java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:293)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:573)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:416)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
	at
org.eclipse.jdt.internal.ui.refactoring.MoveMembersWizard$MoveMembersInputPage.getNextPage(MoveMembersWizard.java:201)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed(RefactoringWizardDialog2.java:447)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:445)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:587)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1056)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3061)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2743)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:809)
	at org.eclipse.jface.window.Window.open(Window.java:787)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:131)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:144)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveStaticMembersRefactoring(RefactoringExecutionStarter.java:300)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.MoveStaticMembersAction.run(MoveStaticMembersAction.java:110)
	at org.eclipse.jdt.ui.actions.MoveAction.tryMoveStaticMembers(MoveAction.java:164)
	at org.eclipse.jdt.ui.actions.MoveAction.run(MoveAction.java:142)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
	at
org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)
	at org.eclipse.core.commands.Command.execute(Command.java:287)
	at
org.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:401)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:459)
	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:781)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:828)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:550)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:493)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:117)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1247)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1055)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1080)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1092)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:646)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:1982)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:566)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:1401)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:3693)
	at org.eclipse.swt.internal.gtk.OS._gtk_main_do_event(Native Method)
	at org.eclipse.swt.internal.gtk.OS.gtk_main_do_event(OS.java:4955)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1062)
	at org.eclipse.swt.internal.gtk.OS._g_main_context_iteration(Native Method)
	at org.eclipse.swt.internal.gtk.OS.g_main_context_iteration(OS.java:1308)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2741)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1774)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1738)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:376)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:165)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: java.lang.NullPointerException
	at
org.eclipse.jdt.internal.core.search.matching.FieldLocator.matchReportReference(FieldLocator.java:199)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2089)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2212)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2023)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1471)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:958)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:999)
	at
org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1117)
	at
org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:94)
	at
org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:208)
	at
org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:464)
	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:532)
	at
org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.searchPattern(RefactoringSearchEngine2.java:476)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:783)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveStaticMembersProcessor.createChange(MoveStaticMembersProcessor.java:652)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveStaticMembersProcessor.checkFinalConditions(MoveStaticMembersProcessor.java:320)
	at
org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:169)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:117)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1705)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Dirk Baeumer 2005-11-01 11:07:07 EST
Moving to Core. The NPE happens in the search engine (match locator).
Frederic Fusier 2005-11-01 11:59:55 EST
Unfortunately this NPE may happen in 3.1 as it has been introduced while
implementing search for generics :-(

Surely a good candidate for 3.1.2...
Philippe, do you agree?
Frederic Fusier 2005-11-01 12:12:44 EST
Created attachment 29079 [details]
Patch to fix this issue
Frederic Fusier 2005-11-04 10:20:40 EST
Fixed and released in HEAD.

Setting target to 3.2 M4 waiting for acknowledgement to report it in
R3_1_maintenance stream.
Philipe Mulet 2005-11-18 02:54:50 EST
+1 for 3.1.2
Frederic Fusier 2005-11-23 12:49:26 EST
Released in R3_1_maintenance stream.
Olivier Thomann 2005-12-13 10:30:12 EST
The NPE doesn't happen anymore, but the resulting cu looks wrong:

package org.foo;
public class Foo {
	int bar= Bar.FOO;
	private static final int FOO= 0;
}

Because FOO has been moved to the Foo class, Bar.FOO is reported as an error.

Verified for 3.2M4 in I20051212-2000 because the NPE doesn't occur anymore.
Open bug 120583 for the wrong CU contents.
Maxime Daniel 2006-01-10 05:58:05 EST
Verified for 3.1.2 using build M20060109-1200.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97411,97411,P3,JDT,UI,eclipsetalk2,RESO,FIXE,[refactoring] Move Member Type to New File does not make private constructor visible,2006/1/10,compile error ,1,1,nan,inline class,ast rewrite issue,"Bug 97411 - [refactoring] Move Member Type to New File does not  make private constructor visible
Markus Keller 2005-05-31 05:56:28 EDT
I20050527-1300

public class Try {
	private static final class Color {
		private Color(String name) {}
	}
	void usage() {
		Color c= new Color(""ultrared"");
	}
}

Applying ""Move Member Type to New File"" to Color gives a warning that the
visibility of type Color will be changed to default. However, the visibility of
the private constructor is not changed, which leads to a compile error.

Interestingly, there's not warning at all if Color is not ""static"".

Such examples can easily be reproduced by converting an anonymous class to a
nested class (e.g. new TestCase() {...} in TestSuite#warning(String)).
Dirk Baeumer 2005-06-01 08:55:03 EDT
Annoying but not critical. In the past we didn't do visibility updating at all.
Postpone > 3.1
Tobias Widmer 2005-10-19 13:29:46 EDT
Fixed in HEAD > 20051018
Philip Mayer 2005-11-01 06:33:25 EST
Verified in I20051031-2000.
Markus Keller 2005-11-01 08:50:22 EST
Reopening.

The fix in I20051031-2000 seems to think that every method is a constructor (see
the wrong warning messages) and that all methods should be made package-private.

The correct solution would be to make all members that are accessed from outside
the moved type package-private. The others should stay untouched.

An example showing the problems introduced by the fix:

public class Try {
    private static final class Color {
        private Color(String name) {
            this();
        }
        private Color() {}
        private void foo() {}
        private void bar() {}
        private static void staticMethod() {}
        private int fBar;
    }
    void usage() {
        Color c= new Color(""ultrared"");
        c.foo();
        int i= c.fBar;
    }
}
Tobias Widmer 2005-12-14 11:24:23 EST
*** Bug 120642 has been marked as a duplicate of this bug. ***
Philip Mayer 2005-12-15 09:57:52 EST
Created attachment 31812 [details]
Fix

Code for handling these issues has been added to MemberVisibilityAdjustor; patch removes code from MoveInnerToTop.
Philip Mayer 2006-01-10 05:37:54 EST
Created attachment 32754 [details]
Updated to current HEAD
Tobias Widmer 2006-01-10 05:43:00 EST
Fixed in HEAD > 20060110
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=117465,117465,P3,JDT,UI,eclipsetalk2,RESO,FIXE,[refactoring] [move] Moving method to another class incorrectly sets field visibility,2006/1/10,unnecessary change,1,1,enum,move method,ast rewrite issue,"Bug 117465 - [refactoring] [move] Moving method to another class incorrectly sets field visibility
Max Gilead 2005-11-22 06:12:04 EST
Initial source:

package test1;
public class Test1 {
        public void methodToMove() {}
        private TestTarget target;
        public TestTarget getTestTarget() { return target; }
}

package test1;
public class TestTarget {}

package test2;
import test1.Test1;
public class Test2 {
        public Test2() {
                new Test1().methodToMove();
}}

After moving method:

package test1;
public class Test1 {
        TestTarget target;
        public TestTarget getTestTarget() { return target; }
}

package test1;
public class TestTarget {
        public void methodToMove() {}
}

package test2;
import test1.Test1;
public class Test2 {
        public Test2() {
                new Test1().target.methodToMove();
}}


Test.target field should be public instead of friendly.
Max Gilead 2005-11-29 06:43:30 EST
Similar problem:

public class Foo {
	public enum FooEnum {
		FOO_ENUM(null);
		private FooEnum(String bar) {}
}}

after moving FooEnum to separate file it's

public enum FooEnum {
	FOO_ENUM(null);
	FooEnum(String bar) {}
}

while constructor should be left private.
Philip Mayer 2005-12-15 06:08:01 EST
The bug in comment #1 is a duplicate of bug 97411 comment #4.

Investigating issue in initial comment...
Philip Mayer 2005-12-15 09:56:51 EST
Created attachment 31811 [details]
Fix

Fixes field visibility bug.
Tobias Widmer 2006-01-10 05:03:02 EST
Fixed in HEAD > 20060110
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=38469,38469,P3,JDT,UI,dirk_baeumer,RESO,FIXE,inline method: incorrect in innerclasses [refactoring],2006/1/4,behavior change,0,1,super constructor,inline method,nan,"Bug 38469 - inline method: incorrect in innerclasses [refactoring]
Adam Kiezun 2003-06-05 05:51:51 EDT
public int fred(){
		return super.hashCode();
	}
	void f(int p){
		new Ad(){
			void f(){
				int u= Ad.this.fred();
			}
		};
	}

inline fred
the temp u is now initialized to a different value - no compile error
a different hashCode method is called
Dirk Baeumer 2006-01-04 05:13:33 EST
Works if fred is:

public int fred(){
	return hashCode();
}

The only option I see is to not allow inlining super calls in ""this."" calls.
Dirk Baeumer 2006-01-04 05:43:09 EST
Fixed for >= I20060110.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=122389,122389,P3,JDT,UI,dirk_baeumer,RESO,FIXE,[refactoring] [extract method] Two variable assignment in while loop incorrectly extracts,2006/1/3,behavior change,0,1,nan,extract method,overly weak precondition,"Bug 122389 - [refactoring] [extract method]  Two variable assignment in while loop incorrectly extracts
Emerson Murphy-Hill 2005-12-30 11:49:01 EST
The following test passes before ""extract method,"" but fails afterward.  Build id: I20051102-1600

import junit.framework.TestCase;

public class A extends TestCase{
	
    private int getGridY(int y) {
        int tmp = 0, res = 1;
        while (res < y) {
        	//extract here
            tmp = res;
            res += 1;
            //to here
        }
        return tmp;
    }
    
    public void testCase(){    	
    	assertEquals(getGridY(7),6);
    }
}
Dirk Baeumer 2006-01-03 08:48:20 EST
Still exists in I20051215-1506.

The problem is that extracting the code shouldn't be allowed since both tmp and res are modified inside the code to be extracted and both are read afterwards.
Dirk Baeumer 2006-01-03 09:41:08 EST
Problem was caused by loop reentrance. Fixed for >= I20060110.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=100212,100212,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] Encapsulate field breaks static import statement.,2005/12/13,compile error,0,1,static import,encapsulate field,nan,"Bug 100212 - [refactoring] Encapsulate field breaks static import statement.
Brian Miller 2005-06-15 11:26:39 EDT
To Import.x do Refactor>>EncapsulateField.  See the resulting static import 
statement is illegal.


-------------------- bug/Bug.java ----------------------
package bug;
import static bug.Import.x;
class Bug { int y=x; }

-------------------- bug/Import.java -------------------
package bug;
class Import { static int x; }
Dirk Baeumer 2005-06-15 16:29:07 EDT
I thought that this is an easy fix, but unfortunatelly it is not. Only skipping
import declarations isn't enough. I also have to inspect all reference and see
if the field is seen through a static import. If so the field reference has to
be replaced by a 'Type.fieldName' reference and the import statement has to be
replaced by a non static import statement to the type.

Code changes are too big so late in the cycle.
Dirk Baeumer 2005-11-20 10:51:05 EST
Fixed for build >= I20051122.
Philip Mayer 2005-12-13 12:15:24 EST
Verified in I20051213-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=118045,118045,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] cannot pull up method from implementation to interface,2005/12/13,incorrect warning message,0,1,nan,pull up method,overly strong precondition,"Bug 118045 - [refactoring] cannot pull up method from implementation to interface
Thomas Singer 2005-11-25 07:27:06 EST
I have a simple class Clazz implementing an interface Interfaze. I've written a new instance method in Clazz and now want to pull it up to Interfaze, but Eclipse does not allow me: ""Pull up is not allowed on this type. Type has no super types."". Of course it has - the Interfaze.
Olivier Thomann 2005-11-25 08:34:29 EST
Move to JDT/UI
Martin Aeschlimann 2005-11-28 04:12:43 EST
Tobias, can you comment?
Tobias Widmer 2005-11-28 04:16:55 EST
This should work with all non-binary super-interfaces. If you can provide a reproducible testcase with version information, please reopen.
Thomas Singer 2005-11-28 04:49:31 EST
Of course I can provide an example, even the simplest possible:

  public interface IFoo {
  }

  public class Foo implements IFoo {

    public void test() {
    }
  }

No try to pull up test() to IFoo. I would expect the following result:

  public interface IFoo {

    void test();
  }

  public class Foo implements IFoo {

    public void test() {
    }
  }
Tobias Widmer 2005-11-28 05:18:37 EST
Fixed in HEAD > 20051128
Benno Baumgartner 2005-12-13 09:31:34 EST
verified 20051213-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=118133,118133,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] InvocationTargetException on a valid refactoring,2005/12/13,exception,0,1,nan,extract constant,nan,"Bug 118133 - [refactoring] InvocationTargetException on a valid refactoring
Hosam 2005-11-26 11:25:33 EST
In the constructor, I had code like:
xyz = ClassA.staticMethod().someOtherMethod();

where xyz is declared as a final variable in the class.

I also had in several methods the following code:
abc = ClassA.staticMethod();

I selected ""ClassA.staticMethod()"" that was in the constructor, then chose to extract constant. I gave it the name ""abc"". Pressing OK gave me an error dialog saying that an internal error happened.

Attached is eclipse's log.
Hosam 2005-11-26 11:26:16 EST
Created attachment 30659 [details]
Eclipse log
Markus Keller 2005-11-28 06:23:01 EST
Hosam, could it be that you
- entered a name for the constant,
- pressed Preview or OK,
- got an error page,
- pressed Back,
- pressed Preview or OK again,
-> only now got the error page?
Markus Keller 2005-11-28 06:41:50 EST
Fixed in HEAD. We did not clear caches when going back from the error page.

Steps to reproduce:
- Have this:
public class ClassA {
    private final Object xyz;
    ClassA() {
        xyz = ClassA.class;
    }
}
- extract ClassA.class to constant ""xyz""
- on the error page, press back
- press preview
Hosam 2005-11-29 16:28:04 EST
(In reply to comment #2)
I think it happened in the exact scenario I described. Only class and variable names were different. I'm not used to using the preview anyway, I usually press OK directly (because I'm very confident in eclipse ;) ).

It has been a while since I reported this, so I'm not 100% sure that this is what happened. However, I'm 90% confident, since this is always my behavior. I never use preview (unless Eclipse forces me to).
Benno Baumgartner 2005-12-13 07:02:59 EST
verified 20051213-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=119394,119394,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] IndexOutOfBoundsException in Change Method Signature,2005/12/13,exception,0,1,anonymous class,Change method Signature,nan,"Bug 119394 - [refactoring] IndexOutOfBoundsException in Change Method Signature
Philip Mayer 2005-12-06 06:52:31 EST
Build id: I20051130-1215

Having:

--------------
public class Foo {
	public void test() {
		Foo b= new Foo() {
			public void foo() {
			}
		};
	}
}
--------------

Invoke Change Signature on foo(); add one parameter, press ""Preview"":

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:308)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:571)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:414)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:75)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:115)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.nextOrPreviewPressed(RefactoringWizardDialog2.java:475)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:472)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:660)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:906)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3241)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2861)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:808)
	at org.eclipse.jface.window.Window.open(Window.java:786)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:131)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:144)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.activate(UserInterfaceStarter.java:56)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter$1.activate(RefactoringExecutionStarter.java:182)
	at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startChangeSignatureRefactoring(RefactoringExecutionStarter.java:187)
	at org.eclipse.jdt.ui.actions.ModifyParametersAction.run(ModifyParametersAction.java:132)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:253)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:225)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:492)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:530)
	at org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:480)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:392)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:906)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3241)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2861)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1763)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1727)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:396)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:109)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:369)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:167)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: java.lang.IndexOutOfBoundsException: Index: 0, Size: 0
	at java.util.ArrayList.RangeCheck(ArrayList.java:547)
	at java.util.ArrayList.get(ArrayList.java:322)
	at org.eclipse.jdt.core.dom.ASTNode$NodeList.get(ASTNode.java:1194)
	at org.eclipse.jdt.internal.corext.refactoring.TypeContextChecker$MethodTypesChecker.resolveBindings(TypeContextChecker.java:176)
	at org.eclipse.jdt.internal.corext.refactoring.TypeContextChecker$MethodTypesChecker.checkAndResolveMethodTypes(TypeContextChecker.java:118)
	at org.eclipse.jdt.internal.corext.refactoring.TypeContextChecker.checkAndResolveMethodTypes(TypeContextChecker.java:437)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.checkSignature(ChangeSignatureRefactoring.java:329)
	at org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.checkFinalConditions(ChangeSignatureRefactoring.java:709)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:117)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Markus Keller 2005-12-07 09:08:26 EST
Fixed in HEAD.
Philip Mayer 2005-12-13 05:38:36 EST
Verified in I20051213-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=116342,116342,P2,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] [extract method] Pre/post-increment/decrement in loops allowed to be extracted,2005/12/13,behavior change,0,1,nan,extract method,nan,"Bug 116342 - [refactoring] [extract method] Pre/post-increment/decrement in loops allowed to be extracted
Emerson Murphy-Hill 2005-11-14 17:24:19 EST
Try an extract method refactoring on the following code, indicated by the comments:

import junit.framework.TestCase;

public class BugTest extends TestCase{
	
	  public void testLoop(){

		int x = 0;
		
		for (int i = x; i < 10; i++)    
			//extract here...
		    assertEquals(i,x++);
			//...to here
	  }
}

If the refactoring were behavior preserving, the test should pass after the
refactoring.
Dirk Baeumer 2005-11-20 13:37:29 EST
The following case is treated correctly:

public class BugTest extends TestCase {
	public void testLoop() {
		int x = 0;
		for (int i = x; i < 10; i++) {
			// start
			x++;
			assertEquals(i, x);
			// end
		}
	}
}

seems to be a problem with the loop reentrance calculation.
Dirk Baeumer 2005-11-20 13:38:57 EST
No, the last case has problems as well. But it ""at least"" returns x from the extracted method.
Dirk Baeumer 2005-11-20 13:41:05 EST
Stupid me. The correct equivalent is

public class BugTest extends TestCase {
	public void testLoop() {
		int x = 0;
		for (int i = x; i < 10; i++) {
			// start
			assertEquals(i, x);
			x++;
			// end
		}
	}
}

which is handled correctly
Dirk Baeumer 2005-11-20 18:13:27 EST
Extract method works correctly if the body of the for statement is a block:

public class BugTest extends TestCase {
	public void testLoop() {
		int x = 0;
		for (int i = x; i < 10; i++) {
			// start
			assertEquals(i, x++);
			// end
		}
	}
}
Dirk Baeumer 2005-11-20 18:24:03 EST
The problem is that the selection is larger than the body statement of the for loop (it covers the comments). That's why the loop reentrance visitor assumes that the for statement isn't affected.

The fix is to adjust the selection to the covered nodes.
Dirk Baeumer 2005-11-20 19:01:34 EST
Fixed for build >= I20051122.
Philip Mayer 2005-12-13 04:11:38 EST
Verifying...
Philip Mayer 2005-12-13 04:18:51 EST
Verified in I20051213-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=119822,119822,P2,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] NPE in when switching to refactoring preview page,2005/12/13,compile error,0,1,nan,rename class,nan,"Bug 119822 - [refactoring] NPE in when switching to refactoring preview page
Dirk Baeumer 2005-12-08 03:06:32 EST
N20051208-0010

- use the following test case:

package p;

public class Foo {
	Foo getFoo() {
		return null;
	}
}

- rename Foo -> Bar and check update similar names
- press next

java.lang.NullPointerException
at org.eclipse.ltk.internal.ui.refactoring.CompositeChangeNode.getFlattendedChildren(CompositeChangeNode.java:50)
at org.eclipse.ltk.internal.ui.refactoring.CompositeChangeNode.doCreateChildren(CompositeChangeNode.java:42)
at org.eclipse.ltk.internal.ui.refactoring.AbstractChangeNode.getChildren(AbstractChangeNode.java:78)
at org.eclipse.ltk.internal.ui.refactoring.ChangeElementContentProvider.getChildren(ChangeElementContentProvider.java:34)
at org.eclipse.ltk.internal.ui.refactoring.ChangeElementContentProvider.getElements(ChangeElementContentProvider.java:62)
at org.eclipse.jface.viewers.StructuredViewer.getRawChildren(StructuredViewer.java:848)
at org.eclipse.jface.viewers.AbstractTreeViewer.getRawChildren(AbstractTreeViewer.java:896)
at org.eclipse.jface.viewers.TreeViewer.getRawChildren(TreeViewer.java:684)
at org.eclipse.jface.viewers.StructuredViewer.getFilteredChildren(StructuredViewer.java:790)
at org.eclipse.jface.viewers.StructuredViewer.getSortedChildren(StructuredViewer.java:905)
at org.eclipse.jface.viewers.AbstractTreeViewer$1.run(AbstractTreeViewer.java:512)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren(AbstractTreeViewer.java:494)
at org.eclipse.jface.viewers.TreeViewer.createChildren(TreeViewer.java:794)
at org.eclipse.jface.viewers.AbstractTreeViewer$5.run(AbstractTreeViewer.java:985)
at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1201)
at org.eclipse.jface.viewers.CheckboxTreeViewer.preservingSelection(CheckboxTreeViewer.java:364)
at org.eclipse.jface.viewers.AbstractTreeViewer.inputChanged(AbstractTreeViewer.java:975)
at org.eclipse.ltk.internal.ui.refactoring.ChangeElementTreeViewer.inputChanged(ChangeElementTreeViewer.java:96)
at org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:248)
at org.eclipse.jface.viewers.StructuredViewer.setInput(StructuredViewer.java:1417)
at org.eclipse.ltk.internal.ui.refactoring.PreviewWizardPage.setTreeViewerInput(PreviewWizardPage.java:438)
at org.eclipse.ltk.internal.ui.refactoring.PreviewWizardPage.createStandardPreviewPage(PreviewWizardPage.java:350)
at org.eclipse.ltk.internal.ui.refactoring.PreviewWizardPage.createControl(PreviewWizardPage.java:317)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.showCurrentPage(RefactoringWizardDialog2.java:459)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.nextOrPreviewPressed(RefactoringWizardDialog2.java:490)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:476)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$3.widgetSelected(RefactoringWizardDialog2.java:697)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:90)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:906)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3241)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2861)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:808)
at org.eclipse.jface.window.Window.open(Window.java:786)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:131)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:144)
at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
at org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.activate(UserInterfaceStarter.java:56)
at org.eclipse.jdt.internal.ui.refactoring.reorg.RenameUserInterfaceStarter.activate(RenameUserInterfaceStarter.java:113)
at org.eclipse.jdt.ui.refactoring.RenameSupport.openDialog(RenameSupport.java:115)
at org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startRenameRefactoring(RefactoringExecutionStarter.java:334)
at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:171)
at org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:131)
at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:117)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:253)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:225)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:492)
at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
at org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)
at org.eclipse.core.commands.Command.execute(Command.java:306)
at org.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:401)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:461)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:786)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:833)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:555)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:498)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:118)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Display.filterEvent(Display.java:976)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:905)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:930)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:915)
at org.eclipse.swt.widgets.Control.traverse(Control.java:2912)
at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2753)
at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:856)
at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2771)
at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:3746)
at org.eclipse.swt.widgets.Display.filterMessage(Display.java:990)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2857)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1763)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1727)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:396)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:106)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:109)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:92)
at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:68)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:369)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:167)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:338)
at org.eclipse.core.launcher.Main.basicRun(Main.java:282)
at org.eclipse.core.launcher.Main.run(Main.java:977)
at org.eclipse.core.launcher.Main.main(Main.java:952)

Martin, Tobias was going to change something there. May be he already did ;-)
Dirk Baeumer 2005-12-08 03:09:08 EST
Happens to rename method as well.
Dirk Baeumer 2005-12-08 03:10:57 EST
Moving to Tobias since the NPE is caused by his change.
Dirk Baeumer 2005-12-08 03:14:02 EST
And some minor nodes: classes like this are typically named filter and the method is named select. See IParticipantDesciptorFilter or ViewerFilter.

We use requestor when some component produces something and a result is delivered (for example search engine).
Markus Keller 2005-12-08 03:51:48 EST
*** Bug 119717 has been marked as a duplicate of this bug. ***
Markus Keller 2005-12-08 04:06:00 EST
I released a temporary workaround in CompositeChangeNode.
Tobias Widmer 2005-12-08 04:57:08 EST
Fixed in HEAD > 20051208
Philip Mayer 2005-12-13 03:32:20 EST
Verifying...
Philip Mayer 2005-12-13 03:40:49 EST
Verified in I20051213-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=111056,111056,P3,JDT,UI,eclipsetalk2,RESO,FIXE,[refactoring] Move Member Type to New File does not make private member visible,2005/11/11,compile error,0,1,nan,Move Member Type to New File,nan,"Bug 111056 - [refactoring] Move Member Type to New File does not make private member visible
Markus Keller 2005-09-29 09:20:09 EDT
I20050928-1300

The fix for bug 100555 introduced this new problem:

public class Try {
    public static class MoveToNewFile {
        @SuppressWarnings(""unused"")
        private String a;
        public String getA() {
            return a;
        }
    }
    
    Object tryA= new MoveToNewFile().a;
}

'Move Member Type to New File' does not make the private field 'a' visible and
therefore leads to a compile error. It is bad style to access private members of
nested classes, but JLS3 §6.6.1 allows access from within the body of the top
level class.
Philip Mayer 2005-11-07 11:50:56 EST
Created attachment 29443 [details]
patch for jdt.ui and jdt.ui.tests.refactoring
Philip Mayer 2005-11-08 11:22:07 EST
Defer this patch. There is another issue associated with this bug. When moving
static types, the same issue appears with private, default or protected members
inside the static moved type.

Investigating...
Philip Mayer 2005-11-09 09:15:57 EST
Test case for move static members: Two classes in the same package:

----
public class A {

  static class Inner {
     String a;
  }
}

public class B {

 Object o= new A.Inner().a;
}
---

Move Inner into a class in a different package. Both the class Inner and the
field a should have their visibility adjusted.

-> have to provide visibility adjustments for members of moved types.
Philip Mayer 2005-11-11 04:04:19 EST
Created attachment 29758 [details]
patch for jdt.ui and jdt.ui.tests.refactoring

Fixes adjusting the visibility of moved element and the visibility of members
of moved element.

Also fixes adjusting the visibility of parents of elements called from within
moved element (bug 115633).
Tobias Widmer 2005-11-11 05:22:44 EST
Reviewed and released patch by Philip

Fixed in HEAD > 20051111
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=107998,107998,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] [move] Move method out of non-static inner class too strict.,2005/11/3,not available,0,1,inner class,move method,overly strong preconditions,"Bug 107998 - [refactoring] [move] Move method out of non-static inner class too strict.
Brian Miller 2005-08-25 11:35:46 EDT
The inner class is non-static, but the method only accesses a static field.  
So Eclipse shouldn't refuse to move it.  Interestingly, Eclipse allows moving 
the 'number' field, but not the method, even though they're in the same inner 
class.

------------------------- Bug.java ------------------
public class Bug {
    public static int field;
    class Inner{
        int number=field;
        int method(){return field;}
    }
}
Tobias Widmer 2005-10-20 04:56:39 EDT
Moving the number field is a purely textual move
Moving the method is a refactoring, which has been fixed to treat static 
references to outer types correctly

Fixed in HEAD > 20051020
Benno Baumgartner 2005-11-03 04:15:19 EST
Verified in I20051102-1600
Markus Keller 2005-11-03 04:17:59 EST
Verified in I20051102-1600 that method() can be moved to t, but method2() cannot.

public class Bug {
    public static int field;
    public Bug instance;
    class Inner{
        int number=field;
        Target t;
        int method(){return field;}
        Object method2(){return instance;}
    }
}

class Target {
	
}
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=106329,106329,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Pull Up fails with method type variable of the same name as class type variable,2005/11/1,compile error,0,1,java generics,pull up method,nan,"Bug 106329 - [refactoring] Pull Up fails with method type variable of the same name as class type variable
Markus Keller 2005-08-08 06:37:26 EDT
I20050803-0800

- pull up countItem(..) to Collector
-> compile errors, since references to method type variable T have been replaced
by E

- remove 'static' modifier from countItem(..) and pull up again
-> no compile error, but changed semantics because the method parameter types
don't use the method type variable any more.

package org.example;
import java.util.HashMap;
class Collector<E> {
	
}
public class Stats<T> extends Collector<T> {
	static <T> void countItem(HashMap<T, Integer> frequencies, T item) {
		Integer frequency = frequencies.get(item);
		if (frequency == null)
			frequency = 1;
		else
			frequency++;
		frequencies.put(item, frequency);
	}
}
Tobias Widmer 2005-10-19 12:08:52 EDT
Fixed in HEAD > 20051019
Philip Mayer 2005-11-01 06:41:14 EST
Verified in I20051031-2000.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=100555,100555,P3,JDT,UI,eclipsetalk2,VERI,FIXE,[refactoring] Move Member Type to New File unnecessarily makes private field visible,2005/11/1,unnecessary change,0,1,nan,Move Member Type to New File,nan,"Bug 100555 - [refactoring] Move Member Type to New File unnecessarily makes private field visible
Markus Keller 2005-06-17 07:07:17 EDT
I20050617-0010

Move Member Type to New File unnecessarily makes private field visible. Maybe
related to bug 96308.

public class Try {
	public static class MoveToNewFile {
		@SuppressWarnings(""unused"")
		private String a;
		public String getA() {
			return a;
		}
	}
}

The new file looks like this:

public class MoveToNewFile {
    @SuppressWarnings(""unused"") String a;
    public String getA() {
        return a;
    }
}

The visibility of 'a' has been changed from private to default. Should stay
private. The bad formatting of the annotation is bug 99729.
Tobias Widmer 2005-09-21 06:58:56 EDT
Philip, can you please have a look?
Philip Mayer 2005-09-22 11:22:08 EDT
Fixed in HEAD.
Tobias Widmer 2005-09-22 11:51:23 EDT
Fixed by fix for bug 42439
Benno Baumgartner 2005-11-01 08:19:03 EST
Verified using I20051031-2000
Markus Keller 2005-11-01 09:10:19 EST
Setting to verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=107026,107026,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[1.5][refactoring] NPE in ExtractMethodInputPage with enum's,2005/9/20,exception,0,1,enum,extract method,nan,"Bug 107026 - [1.5][refactoring] NPE in ExtractMethodInputPage with enum's
Andrey Loskutov 2005-08-15 10:49:03 EDT
I'm trying to refactor some code inside of enum's methods
on Eclipse 3.1.1 Build id: M20050811-0400
and I have go this exception:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.refactoring.code.ExtractMethodInputPage.
getLabel(ExtractMethodInputPage.java:243)
	at org.eclipse.jdt.internal.ui.refactoring.code.ExtractMethodInputPage.
createControl(ExtractMethodInputPage.java:119)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.
createContents(RefactoringWizardDialog2.java:555)
	at org.eclipse.jface.window.Window.create(Window.java:418)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:996)
	at org.eclipse.jface.window.Window.open(Window.java:776)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.
run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.
run(RefactoringWizardOpenOperation.java:138)
	at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.
activate(RefactoringStarter.java:40)
	at org.eclipse.jdt.ui.actions.ExtractMethodAction.run(ExtractMethodAction.
java:84)

This is an inner enum, defined in another class, and code looks like
public class ABC {
    protected enum Functions implements PropsSetter {
        MINIMUM_FOURIER {
            public void applyTo(Properties props){
                doSomething();
                codeToRefactor1();
                codeToRefactor2();
                ...
                codeToRefactorN();
            }
        },
    }
[...]
}
The exception occurs if I select all ""codeToRefactor"" methods and say ""refactor-
>extract method""
Frederic Fusier 2005-08-15 11:08:02 EDT
Move to JDT/UI
Olivier Thomann 2005-08-15 11:32:20 EDT
Created attachment 26110 [details]
Proposed fix

This fix is returning a label like this:
new MINIMUM_FOURNIER() {...} for the destination type. This might not be ideal.
Maybe simply the name of the enum constant declaration is enough.
Also I did a default handling of the null type. This needs to be improved.
Since null is not expected to be returned by this method, I didn't know the
best way to handle the case where no parent can be retrieved.
Martin Aeschlimann 2005-09-19 05:34:07 EDT
fixed > 20050919
Martin Aeschlimann 2005-09-20 12:53:49 EDT
verified in 20050920-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=108666,108666,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] Infer type argument gives strange result,2005/9/20,fail to refactoring,1,1,vector,Infer Type Arguments,overly weak preconditions,"Bug 108666 - [refactoring] Infer type argument gives strange result
Dani Megert 2005-09-02 08:43:04 EDT
M20050831-1200 + the two plug-ins in
\\Rosenberg.zurich.ibm.com\public\t\jabiru\plugin-export\M20050831-1200.from20050902_1247

Found this while verifying bug 105829:
1. create 5.0 project with JUnit
2. add the following CU
public class A {
	void foo() {
		Vector v1= new Vector();
		Vector v2= new Vector();
		v2.add(v1);
		v1.add(v2);
	}
}

3. use infer type directly on CU A ==> no changes
4. use it on the project
==>
public class A {
	void foo() {
		Vector<Vector> v1= new Vector<Vector>();
		Vector<Vector<Vector>> v2= new Vector<Vector<Vector>>();
		v2.add(v1);
		v1.add(v2);
	}
}
Dirk Baeumer 2005-09-02 11:22:56 EDT
Markus, can you please comment.
Dirk Baeumer 2005-09-06 13:54:15 EDT
Ping...
Markus Keller 2005-09-07 12:04:13 EDT
Self-contained example to reproduce:

package a;
import java.util.Vector;
public class A {
	void foo() {
		Vector v1= new Vector();
		Vector v2= new Vector();
		v2.add(v1);
		v1.add(v2);
	}
	private void bla(String s) {}
}

If bla(String) is commented out => no changes.
If bla(String) is active => type arguments for Vectors correctly inferred.

The reason why bla(string) makes a difference is quite involved:
Without a reference to another type than Vector, all known types in the universe
are equal to or supertypes of Vector. In the constraints solving phase, this
leads to the situation that the elements contained in v1 and v2 are believed to
be undetermined and hence no type arguments are inferred. The fix is in
SupertypesOfSingleton#containsAll(TypeSet), which should return false if the
other is the Universe.

This problem only occurs when no unrelated types are present, which almost never
occurs in real life. I'll only fix this in HEAD, since it's not a severe
problem, and it's hard to prove that the fix cannot have unexpected consequences.
Markus Keller 2005-09-07 12:06:09 EDT
Created attachment 26911 [details]
Fix
Markus Keller 2005-09-07 12:09:06 EDT
Fixed in HEAD and updated test.
Philip Mayer 2005-09-20 12:00:56 EDT
Verified scenario in comment 3 works as expected in I20050920-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=109071,109071,P3,JDT,UI,eclipsetalk2,VERI,FIXE,[refactoring] Inlining array with initializer gives illegal expression.,2005/9/20,compile error,1,1,static initializer,inline field,ast rewrite issue,"Bug 109071 - [refactoring] Inlining array with initializer gives illegal expression.
Brian Miller 2005-09-08 11:56:09 EDT
-------------------- Bug.java ------------------
class Bug {
    static final int[]array={};
    {
        for(int i=array.length; i<array.length; array[i]=i);
    }
}
Markus Keller 2005-09-15 06:41:35 EDT
Philip, could you please have a look?
Philip Mayer 2005-09-15 12:49:49 EDT
Created attachment 27174 [details]
Patch for handling array (
+initializer) inlining in local variables

Patch for local variables only; static fields pending.
Philip Mayer 2005-09-15 12:51:29 EDT
Created attachment 27175 [details]
And a patch for the tests...

Again, only for local variables
Markus Keller 2005-09-16 10:26:46 EDT
Thanks, Philip. Released fix for local variables to HEAD.
Philip Mayer 2005-09-16 10:44:43 EDT
Created attachment 27215 [details]
Patch for handling array (+initializer) inlining in static fields
Philip Mayer 2005-09-16 10:45:23 EDT
Created attachment 27216 [details]
And a patch for the tests...
Markus Keller 2005-09-16 11:27:26 EDT
Released the second pair of patches to HEAD with the following changes:
- made constructor-initalized field final
- replaced method isArrayInitializer() by an instanceof check
Tom Hofmann 2005-09-20 10:02:34 EDT
verifying...
Tom Hofmann 2005-09-20 10:12:10 EDT
verified scenario in comment 0 works as expected.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=96949,96949,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Convert anonymous: generates unnecessary call to super(),2005/9/20,unnecessary change,0,1,anonymous class,convert anonymous to nested class,nan,"Bug 96949 - [refactoring] Convert anonymous: generates unnecessary call to super()
David Saff 2005-05-27 07:11:03 EDT
Against I20050527-0010

Given code:

   public void foo(final int pVar1) {
      final int lVar2= 1;
      Runnable r= new Runnable() {
		public void run() {
			int x= pVar1 + lVar2;
		}
      };
   }

When converting anonymous inner class to nested class TheThing, the generated
class contains an unnecessary call to super() in the constructor:

private TheThing(int pVar1, int pVar2) {
	super();
	fVar1 = pVar1;
	fVar2 = pVar2;
}
Dirk Baeumer 2005-05-27 09:47:56 EDT
Tobias, could it be that this is caused by some code settings. Anyways, not
critical for 3.1.
Tobias Widmer 2005-05-27 09:51:38 EDT
I have a one line fix ready for that
Dirk Baeumer 2005-05-27 09:57:44 EDT
Not critical. If we have room we can do it for 3.2. Since we have a limited
budget we first have to see what other PRs we have to fix.
Tobias Widmer 2005-05-31 05:29:35 EDT
Regarding comment 1: We do not yet have a code style preference for super() 
calls. We probably should think about adding one, since Add Constructors From 
Superclass and Generate Constructor using Fields offer one
Tobias Widmer 2005-09-05 05:44:39 EDT
Fixed in HEAD > 20050905
Benno Baumgartner 2005-09-20 03:57:24 EDT
Verifying...
Benno Baumgartner 2005-09-20 04:07:46 EDT
...verifyied
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=102018,102018,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Assertion fails in ExtractTempRefactoring.,2005/9/2,exception,1,1,nan,extract local variable,ast rewrite issue,"Bug 102018 - [refactoring] Assertion fails in ExtractTempRefactoring.
Brian Miller 2005-06-28 10:25:50 EDT
Steps:
1) Hilite all of the System...getKey() expression.
2) Pick menu item Refactor>>Extract Local Variable.
3) Press Ok.  The wizard then warns of a duplicate local variable.
4) Press Back.
5) Change suggested variable name from 'key' to 'foo'.
6) Press Ok.  Assertion then fails.

------------------------ Bug.java ----------------
class Bug {
    {
        System.getenv().entrySet().iterator().next().getKey();
        String key;
     }
}
Markus Keller 2005-07-22 16:14:40 EDT
*** Bug 104828 has been marked as a duplicate of this bug. ***
Markus Keller 2005-07-22 16:19:08 EDT
Created attachment 25195 [details]
Minimal fix

The problem is that fImportEdit is not re-created when checkFinalConditions()
is called again.
Tobias Widmer 2005-08-08 08:24:14 EDT
Fixed in HEAD 20050808
Tobias Widmer 2005-08-10 08:58:17 EDT
+1 for 3.1.1 from my side

Martin, can you please vote?
Martin Aeschlimann 2005-08-10 10:31:40 EDT
patch looks good, verified it works.
Tobias Widmer 2005-08-10 12:06:11 EDT
Fixed in 3.1.1 maintenance stream > 20050810
Tom Hofmann 2005-09-02 09:53:17 EDT
verifying...
Tom Hofmann 2005-09-02 10:29:02 EDT
verified scenario works as expected.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=104030,104030,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] extract interface:NPE in SuperTypeConstraintsModel,2005/9/2,exception,1,1,nan,extract interface,ast rewrite issue,"Bug 104030 - [refactoring] extract interface:NPE in SuperTypeConstraintsModel
Adam Kiezun 2005-07-15 11:46:41 EDT
3.1
extract the attached source
open interace Node
'Extract Interface', select all methods

java.lang.NullPointerException
at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsModel.createTypeVariable(SuperTypeConstraintsModel.java:478)
at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsCreator.endVisit(SuperTypeConstraintsCreator.java:685)
at
org.eclipse.jdt.internal.corext.dom.HierarchicalASTVisitor.endVisit(HierarchicalASTVisitor.java:707)
at org.eclipse.jdt.core.dom.SimpleType.accept0(SimpleType.java:138)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:495)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:299)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor.performFirstPass(SuperTypeRefactoringProcessor.java:306)
at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor$3.acceptAST(SuperTypeRefactoringProcessor.java:656)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:691)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:455)
at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:664)
at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor.solveSuperTypeConstraints(SuperTypeRefactoringProcessor.java:650)
at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.access$2(ExtractInterfaceProcessor.java:1)
at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor$2.acceptAST(ExtractInterfaceProcessor.java:1106)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:691)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:455)
at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:664)
at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.rewriteTypeOccurrences(ExtractInterfaceProcessor.java:1088)
at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.createChangeManager(ExtractInterfaceProcessor.java:359)
at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.checkFinalConditions(ExtractInterfaceProcessor.java:224)
at
org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:169)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Adam Kiezun 2005-07-15 11:47:33 EDT
Created attachment 24845 [details]
the benchmark
Dirk Baeumer 2005-07-15 16:08:54 EDT
Tobias, please also investigate how risky a fix would be for 3.1.1.
Tobias Widmer 2005-07-18 04:52:17 EDT
The scenario works for me using a fresh 5.0 project with imported source.

However, the resolved binding in SuperTypeConstraintsModel#createTypeVariable 
is accessed without null check.

Fix is trivial and absolutely safe

Attaching patch
Tobias Widmer 2005-07-18 04:53:04 EDT
Created attachment 24898 [details]
proposed fix
Dirk Baeumer 2005-07-26 05:51:38 EDT
Approved for 3.1.1
Tobias Widmer 2005-08-08 08:15:46 EDT
Martin, can you approve for 3.1.1?
Tobias Widmer 2005-08-08 08:36:31 EDT
Fixed in HEAD 20050808
Martin Aeschlimann 2005-08-09 05:00:14 EDT
patch looks good, ok for 3.1.1.
Tobias Widmer 2005-08-10 09:14:55 EDT
Fixed in 3.1.1 maintenance stream > 20050810
Dani Megert 2005-09-02 09:47:51 EDT
Start verification...
Dani Megert 2005-09-02 10:07:21 EDT
Could also not reproduce with attached example. Verified in source:
M20050831-1200\plugins\org.eclipse.jdt.source_3.1.1\src\org.eclipse.jdt.ui_3.1.1
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=108115,108115,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] Extract Local Variable and Ex. Constant don't find matching invocations of generic methods,2005/9/2,fail to refactoring,1,1,java generics,extract local variable,Incorrect Type Resolving,"Bug 108115 - [refactoring] Extract Local Variable and Ex. Constant don't find matching invocations of generic methods
Markus Keller 2005-08-26 10:23:48 EDT
M20050824-1200

See JDT/Core bug 104293. For that specific instance of the problem, there's an
easy workaround in JdtASTMatcher that we should submit for 3.1.1.
Markus Keller 2005-08-26 10:24:56 EDT
Created attachment 26527 [details]
Fix
Markus Keller 2005-08-26 10:26:05 EDT
Created attachment 26528 [details]
Regression Tests
Markus Keller 2005-08-26 10:28:29 EDT
Tobias & Dirk, please review for 3.1.1.
Tobias Widmer 2005-08-26 10:45:22 EDT
Patch looks good, +1 for 3.1.1
Dirk Baeumer 2005-08-26 12:49:10 EDT
Using Bindings.equals requires node.resolveBinding() not being null. This wasn't
the case before. Markus, can you please improve the patch.
Markus Keller 2005-08-29 05:13:55 EDT
Created attachment 26579 [details]
Better fix

Duh, stupid me. Here's a better fix.
Markus Keller 2005-08-29 05:15:55 EDT
Created attachment 26580 [details]
Better Tests

Tests, including test for comment 5.
Markus Keller 2005-08-29 05:18:22 EDT
Created attachment 26581 [details]
Better fix 2

Selected wrong file before :-(
Markus Keller 2005-08-29 05:47:46 EDT
Created attachment 26582 [details]
Better fix 3

3rd try to submit the better fix (it's monday morning;-)
Dirk Baeumer 2005-08-29 06:06:15 EDT
Patch looks ok to me. 

For 3.2: doesn't it make sense to say that the two nodes are equal if we don't
have bindings for them. I would opt to return false in this case as well.
Markus Keller 2005-08-30 09:20:41 EDT
Tobias, could you please review the latest fix again?

> For 3.2: doesn't it make sense to say that the two nodes are equal if we don't
> have bindings for them. I would opt to return false in this case as well.

Yes, I agree it would make sense to consider nodes without bindings as equal
(and return _true_ in that case). I'll file a new bug for that and fix it in
HEAD after having tested this fix for a while.
Tobias Widmer 2005-08-30 09:35:51 EDT
Patch looks ok to me
Markus Keller 2005-08-30 10:02:31 EDT
Released patches to HEAD and 3.1.1 branch.
The other bug is bug 108354.
Tobias Widmer 2005-09-02 08:54:42 EDT
Verified using M20050831-1200 + ZRH plugin export
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=105829,105829,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] infer type arguments: StackOverflowError,2005/9/2,crash,1,1,vector,Infer Type Arguments,ast rewrite issue,"Bug 105829 - [refactoring] infer type arguments: StackOverflowError
Adam Kiezun 2005-08-02 13:03:38 EDT
3.1
public class A {
	void foo() {
		Vector v1= new Vector();
		Vector v2= new Vector();
		v2.add(v1);
		v1.add(v2);
	}
}

Caused by: java.lang.StackOverflowError
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:297)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:298)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:298)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfIthParamFrom(ParametricStructureComputer.java:298)
at
org.eclipse.jdt.internal.corext.refactoring.generics.ParametricStructureComputer.updateStructureOfType(ParametricStructureComputer.java:400)
...
Dirk Baeumer 2005-08-02 13:37:38 EDT
Markus, how risky is a fix for 3.1.1 ?
Markus Keller 2005-08-17 05:57:03 EDT
Created attachment 26184 [details]
Fix

The patch extends the check for ...

	void foo() {
		Vector v1= new Vector();
		v1.add(v1);
	}

... to work with multi-level cycles, too.

The fix is low risk and just leaves v1 and v2 raw. I opt to put it into 3.1.1.
Dirk Baeumer 2005-08-17 13:54:29 EDT
Patch looks good to me.
Markus Keller 2005-08-26 08:59:16 EDT
Tobias, could you pleas have a look too?
Tobias Widmer 2005-08-26 10:33:02 EDT
Patch looks good, verified that performance regression is almost unnoticeable.

+1 for 3.1.1
Markus Keller 2005-08-26 11:11:01 EDT
Fixed in HEAD and 3.1.1 branch.
Dani Megert 2005-09-02 08:26:36 EDT
Start verification...
Dani Megert 2005-09-02 08:47:39 EDT
Verified using:
M20050831-1200 + the two plug-ins in
\\Rosenberg.zurich.ibm.com\public\t\jabiru\plugin-export\M20050831-1200.from20050902_1247

There's no stack overflow but I found the following strange behavior, see bug
108666 for details. Closing this one as verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=102534,102534,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] Inline method: Null pointer exception,2005/8/9,exception,1,1,static initializer,inline method,ast rewrite issue,"Bug 102534 - [refactoring] Inline method: Null pointer exception
Trevor Robinson 2005-07-01 16:32:21 EDT
Trying to inline:

    DirectedExpect addRespExpect(
        final GlobalTxnRecord txn,
        final PktNodeInfo fromNode,
        final PktNodeInfo toNode,
        final String description,
        final RoutedPacket pkt,
        final BitVector matchBits,
        final BitVector checkBits,
        final PacketHandler destHandler)
    {
        final DirectedExpect expect = new DirectedExpect(expectMgr, txn,
            fromNode, toNode, description, pkt, matchBits, destHandler);
        expect.setCheckPacket(checkBits);
        expect.activate();
        return expect;
    }

into:

    final PacketHandler srcRespHandler = new PacketHandler()
    {
        public void execute(final FullExpect expect, final PacketRecord pktRec)
        {
            final GlobalTxnRecord txn = expect.getTxn();
            if (pktRec.toNode.contains(txn.tgtNode))
            {
                // ...
            }
            else
            {
                final DirectedPacket fwdPkt;
                final PktNodeInfo localTgtNode;
                final BitVector matchBits;
                // ...
                addRespExpect(txn, pktRec.toNode, localTgtNode,
                    ""forwarded source response"", fwdPkt, matchBits, null, this);
            }
        }
    };

results in:

Error 2005-07-01 15:21:42.842 Internal Error
java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:293)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:547)
at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:613)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:417)
...
Caused by: java.lang.NullPointerException
at
org.eclipse.jdt.internal.corext.refactoring.code.CallInliner.replaceCall(CallInliner.java:599)
at
org.eclipse.jdt.internal.corext.refactoring.code.CallInliner.perform(CallInliner.java:471)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:238)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
at
org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)

eclipse.buildId=I20050627-1435
java.version=1.5.0_02
java.vendor=Sun Microsystems Inc.
Dirk Baeumer 2005-07-02 13:29:57 EDT
To investigate for 3.1.1.
Dirk Baeumer 2005-07-11 09:59:42 EDT
Trevor,

I tried to reproduce the problem using the test case below and generated stubs
for the additional types. However, I was not able to produce the NPE. Do you
still have the code around. Can you provide the complete code of the else part
of the outer if statement that contains the call to addRespExpect. There must be
something that got replaced by //... that causes the refactoring to misinterpret
the context.

package p102534;

public class TestCase {
	private Manager expectMgr;
	
    DirectedExpect addRespExpect(
            final GlobalTxnRecord txn,
            final PktNodeInfo fromNode,
            final PktNodeInfo toNode,
            final String description,
            final RoutedPacket pkt,
            final BitVector matchBits,
            final BitVector checkBits,
            final PacketHandler destHandler)
        {
            final DirectedExpect expect = new DirectedExpect(expectMgr, txn,
                fromNode, toNode, description, pkt, matchBits, destHandler);
            expect.setCheckPacket(checkBits);
            expect.activate();
            return expect;
        }

    private void testCase() {
        final PacketHandler srcRespHandler = new PacketHandler()
        {
            public void execute(final FullExpect expect, final PacketRecord pktRec)
            {
                final GlobalTxnRecord txn = expect.getTxn();
                if (pktRec.toNode.contains(txn.tgtNode))
                {
                    // ...
                }
                else
                {
                    final DirectedPacket fwdPkt= null;
                    final PktNodeInfo localTgtNode= null;
                    final BitVector matchBits= null;
                    // ...
                    addRespExpect(txn, pktRec.toNode, localTgtNode,
                        ""forwarded source response"", fwdPkt, matchBits, null, this);
                }
            }
        };    	
    }
}
Dirk Baeumer 2005-07-11 10:10:12 EDT
I think I found it. Could it be that there was a label in front of the
addRespExpect call ?
Dirk Baeumer 2005-07-11 11:03:50 EDT
The full fix is too risky for 3.1.1. The problem is that not all statements can
be  labeled. For example a local declaration can't be labeled. The fix for 3.1.1
will be to introduce a block like in other control statements that can have a
single statement as a body.
Dirk Baeumer 2005-07-11 11:05:59 EDT
Created attachment 24543 [details]
Code patch
Dirk Baeumer 2005-07-11 11:06:50 EDT
Created attachment 24544 [details]
Additional test resources
Dirk Baeumer 2005-07-11 11:07:38 EDT
Created attachment 24545 [details]
Additional test methods
Dirk Baeumer 2005-07-26 11:32:23 EDT
Fix reviewed by Martin Aeschlimann and Tom Eicher. Fix released for 3.1.1.
Opened PR 105168 to track the issue in the 3.2 stream.
Dirk Baeumer 2005-07-26 11:33:06 EDT
Added two additional test cases TestLabelOne and TestLabelTwo.
Martin Aeschlimann 2005-08-09 09:46:51 EDT
start verifying...
Martin Aeschlimann 2005-08-09 09:59:40 EDT
verified in I20050808-2000 (3.2) and M20050804-1200 (3.1.1)
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=100846,100846,P2,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] Change method signature does not disallow changing implementations of binary methods,2005/6/22,behavior change,0,1,nan,change method signature,nan,"Bug 100846 - [refactoring] Change method signature does not disallow changing implementations of binary methods
Tobias Widmer 2005-06-20 11:13:42 EDT
3.1 RC3

Steps to reproduce:
- Create compilation unit

class MyList extends ArrayList {
   public String toString() {
     return super.toString();
   }
}

- Add parameter to MyList#toString()

-> CMS does not complain, causing a semantic change
-> During the computation of the method ripple, the refactoring should 
generate an error status as soon as a binary declaration occurs in the ripple

-> This problem probably affects all refactoring clients of RippleMethodFinder
(2)
Dirk Baeumer 2005-06-20 18:17:43 EDT
Markus, I looked into this a little deeper and it is actually loss of
functionality. What happened in 3.0 is that the refactoring asked you that there
is a super implementation and whether you want to refactor this one. If it was
binary the refactoring stopped.

The ripple method finder behaves the same as in 3.0 (it ignores binary methods).
However the loss of functionality we have with asking whether to execute the
method on Object#toString has to be fixed since it makes the behaviour of the
ripple method finder worse.

Markus, step by I will explain how the old code worked (it is some old Adam hack
;-)).
Markus Keller 2005-06-21 08:48:26 EDT
Created attachment 23609 [details]
Fix
Markus Keller 2005-06-21 08:49:20 EDT
Created attachment 23610 [details]
Patch for tests
Markus Keller 2005-06-21 09:05:37 EDT
Created attachment 23612 [details]
Fix (NLS'd)
Dirk Baeumer 2005-06-21 09:26:29 EDT
Daniel, Philippe, can you please cast your vote.
Dani Megert 2005-06-21 10:28:49 EDT
Reviewed the fix with Markus. +1 for 3.1 RC4
Markus Keller 2005-06-21 11:15:40 EDT
I hear that nobody in the call voted against this fix, so I assume we have
enough +1's. Fix reviewed by Tobias and Tom, released to HEAD.
David Saff 2005-06-22 05:54:59 EDT
Verified in N20050622-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=99392,99392,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Use Supertype Where Possible... leaves dialog open,2005/6/21,incorrect warning message,1,1,nan,Use supertype wherever possible,ast rewrite issue,"Bug 99392 - [refactoring] Use Supertype Where Possible... leaves dialog open
Dani Megert 2005-06-10 11:54:08 EDT
I20050610-0010 + plug-in export for smoke

1. Have A.java like:
----------------------------
public class A {
	void foo() {
		C c= null;
		c.toString();
	}
}
class B extends A {}
class C extends B {}
----------------------------
2. select 'C' after 'class'
3. Refactor > Use Supertype Where Possible...
4. seelct 'Object'
5. press OK
==> source has been changed but dialog stays open saying it's not possible to do
the change.
Dirk Baeumer 2005-06-13 19:05:27 EDT
Tobias, can you please investigate.
Tobias Widmer 2005-06-14 11:40:28 EDT
There are two things:
- The message should read something like ""Type cannot be further replaced by 
supertype""
- Enablement of the OK button should be updated when a type has been processed
Tobias Widmer 2005-06-15 09:01:08 EDT
Created attachment 23178 [details]
patch

This patch fixes the problem that composite changes are always emptied after
execution in a processor-based refactoring. The decision whether to close the
dialog is now made based on the number of changed files which is directly
retrieved from the processor
Dirk Baeumer 2005-06-15 10:53:49 EDT
+1 for RC3.

Daniel, can you please cast your vote.
Dani Megert 2005-06-15 12:09:48 EDT
+1 for 3.1 RC3.
Tobias Widmer 2005-06-15 12:48:40 EDT
Fixed > 20050615
Dirk Baeumer 2005-06-17 05:32:40 EDT
start verifying...
Dirk Baeumer 2005-06-17 05:38:52 EDT
Verified on I20050617-0010 using the following example:

public class A {
	void bar() {
		
	}
}
class B extends A {
}
class C extends B {
}

class Use {
	void foo() {
		A c= null;
		c.bar();
	}
}

- choose Object and press OK dialog stays open
- choose A and press OK. Changes are applied and dialog closes
Dirk Baeumer 2005-06-17 05:40:08 EDT
Sourc code was of course C c= null; Pasted in the refactored source ;-).
Tobias Widmer 2005-06-21 05:16:31 EDT
*** Bug 95092 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=99958,99958,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] NPE in Infer Type Arguments,2005/6/17,exception,0,1,nan,Infer Type Arguments,nan,"Bug 99958 - [refactoring] NPE in Infer Type Arguments
Tobias Widmer 2005-06-14 09:56:55 EDT
3.1 RC2

Steps to reproduce:
- Workspace with JDT UI imported in source
- All dependencies of JDT UI imported as linked binary projects

-> Invoke Infer Type Arguments on JDT UI

-> Following NPE occurs:

java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run
(RefactoringWizardDialog2.java:293)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange
(RefactoringWizard.java:573)
at 
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage
(RefactoringWizard.java:416)
at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage
(UserInputWizardPage.java:74)
at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage
(UserInputWizardPage.java:114)
at 
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed
(RefactoringWizardDialog2.java:447)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3
(RefactoringWizardDialog2.java:445)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2
$1.widgetSelected(RefactoringWizardDialog2.java:584)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3058)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2691)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:809)
at org.eclipse.jface.window.Window.open(Window.java:787)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run
(RefactoringWizardOpenOperation.java:125)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run
(RefactoringWizardOpenOperation.java:138)
at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate
(RefactoringStarter.java:40)
at 
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startIn
ferTypeArgumentsRefactoring(RefactoringExecutionStarter.java:225)
at org.eclipse.jdt.ui.actions.InferTypeArgumentsAction.run
(InferTypeArgumentsAction.java:113)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun
(SelectionDispatchAction.java:222)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run
(SelectionDispatchAction.java:198)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:538)
at org.eclipse.jface.action.ActionContributionItem.access$2
(ActionContributionItem.java:488)
at org.eclipse.jface.action.ActionContributionItem$5.handleEvent
(ActionContributionItem.java:400)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3058)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2691)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1716)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1680)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:365)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run
(PlatformActivator.java:226)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:376)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:163)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
at org.eclipse.core.launcher.Main.basicRun(Main.java:278)
at org.eclipse.core.launcher.Main.run(Main.java:973)
at org.eclipse.core.launcher.Main.main(Main.java:948)
Caused by: java.lang.NullPointerException
at org.eclipse.jdt.internal.core.util.BindingKeyParser.<init>
(BindingKeyParser.java:417)
at org.eclipse.jdt.internal.core.util.KeyToSignature.<init>
(KeyToSignature.java:42)
at org.eclipse.jdt.core.BindingKey.internalToSignature(BindingKey.java:233)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.getTypeArguments(InferTypeArgumentsRefactoring.java:374)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.rewriteTypeVariable(InferTypeArgumentsRefactoring.java:342)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.rewriteConstraintVariable(InferTypeArgumentsRefactoring.java:323)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.rewriteDeclarations(InferTypeArgumentsRefactoring.java:302)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.checkFinalConditions(InferTypeArgumentsRefactoring.java:229)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run
(CheckConditionsOperation.java:84)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run
(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run
(WorkbenchRunnableAdapter.java:86)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:113)
Root exception:
java.lang.NullPointerException
at org.eclipse.jdt.internal.core.util.BindingKeyParser.<init>
(BindingKeyParser.java:417)
at org.eclipse.jdt.internal.core.util.KeyToSignature.<init>
(KeyToSignature.java:42)
at org.eclipse.jdt.core.BindingKey.internalToSignature(BindingKey.java:233)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.getTypeArguments(InferTypeArgumentsRefactoring.java:374)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.rewriteTypeVariable(InferTypeArgumentsRefactoring.java:342)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.rewriteConstraintVariable(InferTypeArgumentsRefactoring.java:323)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.rewriteDeclarations(InferTypeArgumentsRefactoring.java:302)
at 
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactor
ing.checkFinalConditions(InferTypeArgumentsRefactoring.java:229)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run
(CheckConditionsOperation.java:84)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run
(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run
(WorkbenchRunnableAdapter.java:86)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:113)


The problem seems to be in file TypeHistoryInfo.java, method getEnclosingNames
(): A TType (ArrayType) has been created for 'char[]', but without valid 
binding key
Markus Keller 2005-06-15 06:18:29 EDT
Created attachment 23145 [details]
Patch

Dirk, here's the one-line patch for TypeEnvironment. When I create an ArrayType
without having a binding, I forgot to set the binding key manually.

I would like to fix this for 3.1, since the fix is low-risk and it avoids
spurious and hard-to-find failures.
Dirk Baeumer 2005-06-15 06:52:24 EDT
+1 for RC3. 

Martin, can you please cast your vote.
Markus Keller 2005-06-15 08:19:30 EDT
Here's a stand-alone test case to reproduce:

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;

public class TypeInfoHistory {
	char[][] getEnclosingNames(String enclosingNames) {
		StringTokenizer tokenizer= new StringTokenizer(enclosingNames, ""."");
		List names= new ArrayList();
		while (tokenizer.hasMoreTokens()) {
			String name= tokenizer.nextToken();
			names.add(name.toCharArray());
		}
		return (char[][])names.toArray(new char[names.size()][]);
	}
}
Markus Keller 2005-06-15 11:44:04 EDT
Martin, please approve the patch for 3.1 RC3.
I filed bug 100151 for making the implementation cleaner in 3.2.
Martin Aeschlimann 2005-06-15 11:53:52 EDT
+1 for RC3. I also tested Markus' example and the scenario where I found the
problem.
Markus Keller 2005-06-15 12:14:46 EDT
Released the patch.
Dirk Baeumer 2005-06-17 08:21:51 EDT
Start verifying...
Dirk Baeumer 2005-06-17 09:25:16 EDT
Verified example from comment #3 on I20050617-0010 and run infer on jdt.ui from
HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=99681,99681,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Convert anonymous creates unnecessary fields for enum types,2005/6/17,unnecessary change,0,1,enum,convert anonymous to nested class,nan,"Bug 99681 - [refactoring] Convert anonymous creates unnecessary fields for enum types
David Saff 2005-06-13 11:05:17 EDT
In RC2.

Given

import java.util.HashSet;

public class Exposer {
	enum Color {
		RED, GREEN, BLUE;
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		new HashSet<Color>() {
			public void addAllColors() {
				add(Color.RED);
				add(Color.GREEN);
				add(Color.BLUE);
			}
		};
		
	}

}

Converting the HashSet to nested creates three unused fields, red, green, and blue.
Dirk Baeumer 2005-06-13 17:56:56 EDT
Tobias, can you please comment. Why does this happen ?
Tobias Widmer 2005-06-15 05:19:12 EDT
The enum constants are incorrectly recognized as local variables
Tobias Widmer 2005-06-15 05:20:43 EDT
Created attachment 23138 [details]
patch

This patch fixes the TempUsageFinder to correctly handle enum constants as
static fields
Tobias Widmer 2005-06-16 08:10:46 EDT
Dirk, can you vote on this one?
Dirk Baeumer 2005-06-16 08:28:24 EDT
+1 for RC3.

Martin, can you please vote.
Dirk Baeumer 2005-06-16 09:05:53 EDT
Daniel, can you please vote for Martin ?
Dani Megert 2005-06-16 09:23:18 EDT
I've reviewed the fix with Tobias.
+1 for 3.1 RC3.
Tobias Widmer 2005-06-16 09:25:52 EDT
Fixed > 20050616
Dirk Baeumer 2005-06-17 07:59:58 EDT
Start verifying...
Dirk Baeumer 2005-06-17 08:02:26 EDT
Verified on I20050617-0010 using the example from comment #0.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=99605,99605,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring][refactoring] Move member type to new file does not update type parameters,2005/6/17,compile error,0,1,nan,Move Member Type to New File,nan,"Bug 99605 - [refactoring][refactoring] Move member type to new file does not update type parameters
David Saff 2005-06-13 06:55:27 EDT
In RC2.  Given code:

class Sub extends ArrayList<Sub.Color> {
	static class Color {}
}

Move Member Type to New File on Color.  The type parameter is not updated,
leading to a compile error.
Dirk Baeumer 2005-06-13 18:49:40 EDT
Normal references to Sub.Color are correctly updated.

Tobias, can you please comment on the reason for this.
Tobias Widmer 2005-06-14 10:22:01 EDT
Method updateParameterizedTypeReference incorrectly returns if no new type 
parameters are introduced and misses the rewriting.

The easy fix is to let updateTypeReference handle the type arguments as well.
Tobias Widmer 2005-06-15 05:30:08 EDT
Created attachment 23139 [details]
patch

This patch fixes a regression introduced when fixing bug 97529
Dirk Baeumer 2005-06-16 03:31:40 EDT
+1 for RC3.

Martin, can you please cast your vote.
Tobias Widmer 2005-06-16 05:32:29 EDT
Created attachment 23275 [details]
patch
Martin Aeschlimann 2005-06-16 06:00:00 EDT
new patch is good, +1 for RC3
Tobias Widmer 2005-06-16 08:08:11 EDT
Fixed > 20050616
Dirk Baeumer 2005-06-17 07:57:56 EDT
Start verifying...
Dirk Baeumer 2005-06-17 07:59:40 EDT
Verified on I20050617-0010 given the example in comment #0.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=99789,99789,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Move Member Type to New File destroys variable declarations,2005/6/17,compile error,0,1,nan,Move Member Type to New File,nan,"Bug 99789 - [refactoring] Move Member Type to New File destroys variable declarations
Tobias Polley 2005-06-13 15:12:27 EDT
Eclipse 3.1RC2: Executing ""Move Member Type to New File"" on the class A.B in

public class A {
  public static class B {
    @SuppressWarnings(""unused"")
    private final String a, b;
    public B(String a1, String b1) {
      a = a1;
      b = b1;
    }
    public String getA() {
      return a;
    }
    public String getB() {
      return b;
    }
  }
}

results in 

public class B {
  @SuppressWarnings(""unused"")
  private final String;
  String a;
  String b;
...

which, of course is incorrect. (compiler error, etc.)

(The presence or absence of the annotation does not change anything.)
Dirk Baeumer 2005-06-13 17:14:53 EDT
Reproducable given the test case below. Problem doesn't occur when there are two
separate delcarations.

Tobias, can you please investigate if the is an AST rewrite problem or local to
Move member type.
Tobias Widmer 2005-06-14 10:12:37 EDT
It is a problem with the member visibility adjustor, which tries to correct 
the visibility of all fragments of a field declaration.

Fix is to handle the rewrite of all fragments in a separate case
Tobias Widmer 2005-06-15 05:03:07 EDT
Created attachment 23137 [details]
Patch

This patch fixed the rewriting of field declaration in
MemberVisibilityAdjustor. The field declaration is correctly deleted if all
fragments need to be rewritten.
Tobias Widmer 2005-06-15 06:28:25 EDT
In the example above, the modifiers (including annotations) are not copied to 
the new field declaration. This patch also accounts for that.

Patch fixes following problems:
- When extracting a variable declaration fragment to a new field declaration, 
it correctly copies all annotations and modifiers (except visibility). It uses 
ModifierRewrite afterwards to set the visibility to the desired flag value
- In case that all fragments have been rewritten, a spurious field declaration 
remained in the code, yielding compile errors. This empty field declaration is 
now removed as well.
Dirk Baeumer 2005-06-15 06:34:08 EDT
+1 for RC3.

Martin, can you please cast your vote.
Tobias Widmer 2005-06-15 11:02:16 EDT
Created attachment 23201 [details]
patch
Martin Aeschlimann 2005-06-15 11:11:49 EDT
+1 for RC3, new patch is better
Tobias Widmer 2005-06-15 12:47:48 EDT
Fixed > 20050615
Markus Keller 2005-06-17 07:01:07 EDT
Verified in I20050617-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=85133,85133,P3,JDT,Debug,cocoakevin,VERI,FIXE,refactoring: NPE in BreakpointUtils.addJavaBreakpointAttributes,2005/6/16,exception,0,1,nan,rename class,nan,"Bug 85133 - refactoring: NPE in BreakpointUtils.addJavaBreakpointAttributes
Dani Megert 2005-02-14 06:11:02 EST
I20050209-0800

I was using rename refactoring on a class that had some breakpoints.

!ENTRY org.eclipse.ltk.core.refactoring 4 10000 2005-02-14 12:08:46.180
!MESSAGE Participant org.eclipse.jdt.debug.refactoring.javaBreakpointITypeRename
removed due to the following exception
!STACK 0
java.lang.NullPointerException
	at
org.eclipse.jdt.internal.debug.ui.BreakpointUtils.addJavaBreakpointAttributes(BreakpointUtils.java:205)
	at
org.eclipse.jdt.internal.debug.core.refactoring.JavaLineBreakpointTypeChange.performChange(JavaLineBreakpointTypeChange.java:59)
	at
org.eclipse.jdt.internal.debug.core.refactoring.JavaBreakpointTypeChange.performTypeRename(JavaBreakpointTypeChange.java:274)
	at
org.eclipse.jdt.internal.debug.core.refactoring.JavaBreakpointTypeChange.perform(JavaBreakpointTypeChange.java:235)
	at
org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:270)
	at
org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run(PerformChangeOperation.java:231)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1695)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1715)
	at
org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange(PerformChangeOperation.java:279)
	at
org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.access$1(UIPerformChangeOperation.java:1)
	at
org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$1.run(UIPerformChangeOperation.java:60)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:118)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:2855)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2519)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.block(ModalContext.java:151)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:301)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:282)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:544)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:610)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:406)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:396)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:543)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2878)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2516)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:718)
	at org.eclipse.jface.window.Window.open(Window.java:696)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.activate(UserInterfaceStarter.java:56)
	at
org.eclipse.jdt.internal.ui.refactoring.reorg.RenameUserInterfaceStarter.activate(RenameUserInterfaceStarter.java:113)
	at org.eclipse.jdt.ui.refactoring.RenameSupport.openDialog(RenameSupport.java:114)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:178)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run(RenameJavaElementAction.java:131)
	at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:116)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:216)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:188)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:1003)
	at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:557)
	at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:507)
	at
org.eclipse.jface.action.ActionContributionItem$6.handleEvent(ActionContributionItem.java:421)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2878)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2516)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1624)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1590)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:299)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:144)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:102)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:227)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:281)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:131)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:261)
	at org.eclipse.core.launcher.Main.run(Main.java:817)
	at org.eclipse.core.launcher.Main.main(Main.java:801)
Luc Bourlier 2005-02-14 13:51:38 EST
I can reproduce the problem if the breakpoint is in an inner type of the renamed
type.

public class Bug_85133 {
  class Inner {
    void foo() {
      System.out.println(); // breakpoint here
    }
  }
}

We are not able to get a reference to the 'new' inner type when the refactoring
support asks us to perform our changes.

If you put a breakpoint line 274 of JavaBreakpointTypeChange (jdt.debug.ui), and
rename 'Bug_85133', newChangedType is tagged as '(not open)'. It looks like this
is why we are not able to find the new inner type.
If I call a method on newChangedType, it becomes no more '(not open)', and
project#findType() for the inner type return the correct object.
I could 'force-open' newChangedType, but i don't think I should have too.

Moving to JDT/UI for comment.
Dirk Baeumer 2005-02-16 13:19:27 EST
In the described scenario the Java model is not yet in sync. Seems to be related
to bug 83646.

Moving to JDT/core.
Dirk Baeumer 2005-02-16 13:21:09 EST
We rename the compilation unit using ICompilationUnit#rename
Jerome Lanneluc 2005-06-13 07:47:21 EDT
IJavaProject#findType(...) accepts only dot-separated qualified names.
JavaLineBreakpointTypeChange should use
'fDeclaringType.getFullyQualifiedName('.') instead.
Darin Wright 2005-06-14 09:27:47 EDT
*** Bug 99792 has been marked as a duplicate of this bug. ***
Darin Wright 2005-06-14 10:42:23 EDT
RC3 candidate
Darin Wright 2005-06-14 14:52:40 EDT
+1.

CC'ing Dirk for additional vote
Dirk Baeumer 2005-06-14 16:48:40 EDT
+1 for RC3.
Kevin Barnes 2005-06-15 14:52:27 EDT
Fixed in JavaBreakpointTypeChange
Kevin Barnes 2005-06-15 15:40:04 EDT
marking FIXED.

note: There are other places in JavaBreakpointTypeChange that call getFullyQualifiedName() instead of 
getFullyQualifiedName('.') or use '$' instead of '.' 
Will file new PR(s)
Kevin Barnes 2005-06-15 15:46:22 EDT
filed Bug 100285
Darin Wright 2005-06-15 17:19:57 EDT
I can still get the NPE on the first try:

* new workspace
* create the type/breakpoint from comment#1
* rename the type
> NPE

java.lang.NullPointerException
	at 
org.eclipse.jdt.internal.debug.ui.BreakpointUtils.addJavaBreakpointAttributes
(BreakpointUtils.java:206)
	at 
org.eclipse.jdt.internal.debug.core.refactoring.JavaLineBreakpointTypeChange.pe
rformChange(JavaLineBreakpointTypeChange.java:59)
	at 
org.eclipse.jdt.internal.debug.core.refactoring.JavaBreakpointTypeChange.perfor
mTypeRename(JavaBreakpointTypeChange.java:274)
	at 
org.eclipse.jdt.internal.debug.core.refactoring.JavaBreakpointTypeChange.perfor
m(JavaBreakpointTypeChange.java:235)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform
(CompositeChange.java:279)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation$1.run
(PerformChangeOperation.java:232)
	at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1719)
	at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1739)
	at 
org.eclipse.ltk.core.refactoring.PerformChangeOperation.executeChange
(PerformChangeOperation.java:280)
	at 
org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation.access$1
(UIPerformChangeOperation.java:1)
	at 
org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$1.run
(UIPerformChangeOperation.java:63)
	at org.eclipse.core.internal.runtime.InternalPlatform.run
(InternalPlatform.java:1044)
	at org.eclipse.core.runtime.Platform.run(Platform.java:783)
	at 
org.eclipse.ltk.internal.ui.refactoring.UIPerformChangeOperation$2.run
(UIPerformChangeOperation.java:81)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:118)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2694)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.block
(ModalContext.java:153)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:303)
	at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run
(RefactoringWizardDialog2.java:293)
	at 
org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish
(RefactoringWizard.java:547)
	at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish
(UserInputWizardPage.java:153)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish
(RefactoringWizard.java:613)
	at 
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed
(RefactoringWizardDialog2.java:417)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:409)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:556)
	at org.eclipse.swt.widgets.TypedListener.handleEvent
(TypedListener.java:89)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3058)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2691)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:809)
	at org.eclipse.jface.window.Window.open(Window.java:787)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run
(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile
(BusyIndicator.java:69)
	at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run
(RefactoringWizardOpenOperation.java:138)
	at 
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate
(RefactoringStarter.java:40)
	at 
org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.activate
(UserInterfaceStarter.java:56)
	at 
org.eclipse.jdt.internal.ui.refactoring.reorg.RenameUserInterfaceStarter.activa
te(RenameUserInterfaceStarter.java:113)
	at org.eclipse.jdt.ui.refactoring.RenameSupport.openDialog
(RenameSupport.java:114)
	at 
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startRe
nameRefactoring(RefactoringExecutionStarter.java:327)
	at 
org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run
(RenameJavaElementAction.java:171)
	at 
org.eclipse.jdt.internal.ui.refactoring.actions.RenameJavaElementAction.run
(RenameJavaElementAction.java:102)
	at org.eclipse.jdt.ui.actions.RenameAction.run(RenameAction.java:108)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun
(SelectionDispatchAction.java:222)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run
(SelectionDispatchAction.java:198)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at 
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:538)
	at org.eclipse.jface.action.ActionContributionItem.access$2
(ActionContributionItem.java:488)
	at org.eclipse.jface.action.ActionContributionItem$5.handleEvent
(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3058)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2691)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1716)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1680)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench
(Workbench.java:365)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run
(IDEApplication.java:103)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run
(PlatformActivator.java:226)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:376)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:163)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:58)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:60)
	at java.lang.reflect.Method.invoke(Method.java:391)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:278)
	at org.eclipse.core.launcher.Main.run(Main.java:973)
	at org.eclipse.core.launcher.Main.main(Main.java:948)
Darin Wright 2005-06-15 17:20:25 EDT
(Then if I rename again, it does not happen).
Darin Wright 2005-06-15 17:41:15 EDT
Note, renaming the outer type works, but renaming the inner does not. It 
appears to be a timing issue, as when I debug the change, it works. If I just 
try it with no breakpoints, it fails with an NPE.
Darin Wright 2005-06-15 18:08:15 EDT
Dirk, do you know of anything that can cause a timing issue with refactorings? 
It looks like we go to look up the new type, and it does not exist yet. 
However, if we delay a bit, the new type does exist.
Kevin Barnes 2005-06-16 11:05:46 EDT
Debugged this a little more and it appears to be the same problem that Luc described in comment 2, just 
showing up in a different location. I renamed the Inner class to FFF and found that JavaProject.findType
(String, WorkingCopyOwner) eventually calls IType.getType(""FFF"") and a type tagged as '(not open)' was 
returned. The type.exists() test then fails and null is returned. Why is the type 'not open'? When does it get 
flagged open?
Jerome Lanneluc 2005-06-16 11:09:58 EDT
""not open"" only means that it is not in the Java model cache. If ot doesn't
exist, it will never be open.
Darin Wright 2005-06-16 15:14:09 EDT
*** Bug 100285 has been marked as a duplicate of this bug. ***
Darin Wright 2005-06-16 15:16:35 EDT
Forcing the type's compiation unit to reconcile before retrieving the new type 
works. However, this requries a lock on the CU which at this point it too high 
of a risk to introduce a deadlock. So the fix is to bail on the refactoring 
(not update the breakpoint) in this case.

This problem will now be tracked with bug 99803.

The NPE is now fixed.
Darin Wright 2005-06-16 15:17:44 EDT
Please verify, Kevin. Changes in JavaLineBreakpointTypeChange.
Kevin Barnes 2005-06-16 15:40:20 EDT
verified
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=99974,99974,P3,JDT,UI,dirk_baeumer,RESO,FIXE,[refactoring] Inline method deletes all comments,2005/6/15,comment related,0,1,comment related,inline method,nan,"Bug 99974 - [refactoring] Inline method deletes all comments
David Saff 2005-06-14 11:04:05 EDT
In RC2.

Given code:


public class Foo {
	private int bar() {
		// an important fact about a
		int a = 1;
		// an important fact about returning
		return a;
		// one final precious thought
	}
	
	private void baz() {
		bar();
	}
}

Inlining bar deletes all of the inline comments.
Dirk Baeumer 2005-06-15 03:28:49 EDT
This is not quite as drammatic as it sounds since normally all comments between
the first and the last statement of the method are kept (excpet when inlining a
method with a return statement at the end since the comment isn't covered here).
So for example

	private void bar() {
		int a = 1;
		// an important fact about returning
		// one final precious thought
                bar();
	}

all comments are kept. However still quitre annying...
Dirk Baeumer 2005-06-15 04:40:15 EDT
Fix is easy. All we have to do is to use the extended source ranges which cover
comments as well.

Opt to fix this for RC2. Dani, can you cast your vote.

+1 for RC3.
Dirk Baeumer 2005-06-15 04:40:54 EDT
Created attachment 23135 [details]
Additional test cases
Dirk Baeumer 2005-06-15 04:41:47 EDT
Created attachment 23136 [details]
Patch against Source Provider
Dani Megert 2005-06-15 05:36:02 EDT
Reviewed the patch.
+1 for 3.1 RC3.
Dirk Baeumer 2005-06-15 05:58:26 EDT
For RC2 I fixed the cases where leading and trailing comments are lost in void
methods. So the case:

	private void bar() {
                // comment
                foo();
		// one final precious thought
                foo();
                // comment
	}

is now handled correcty. I opened bug 100143 to track the remaining issues which
need more work. So when verifying the bug please verify the above scenario not
the one provided in comment #0
Dirk Baeumer 2005-06-15 06:01:35 EDT
Fix got reviewed by Markus Keller.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97529,97529,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Move member type to new file creates doubled type params,2005/6/10,compile error,0,1,java generics,move member type to new file,nan,"Bug 97529 - [refactoring] Move member type to new file creates doubled type params
David Saff 2005-05-31 11:25:05 EDT
In RC1. Given code:

public class A {
	static class B<T> {
		
	}
	
	private <T> B<T> foo() {
		return new B<T>();
	}
}

Select B, and ""move member type to new file.""  The result:

public class A {
	private <T> B<T><T> foo() {
		return new B<T><T>();
	}
}
Dirk Baeumer 2005-06-01 09:02:14 EDT
Tobias, can you please investigate. IMO not super critical for 3.1. Depends on
risk and overall bug load.
Tobias Widmer 2005-06-03 11:48:58 EDT
This happens only in the case when no additional type arguments have to be 
added to a parameterized type. The easy fix is to skip processing if this 
turned out to be unsuccessful
Tobias Widmer 2005-06-03 11:59:35 EDT
Fixed > 20050603
Tom Hofmann 2005-06-10 08:53:58 EDT
verifying...
Tom Hofmann 2005-06-10 09:09:17 EDT
Verified the scenario in comment 0 works as expected.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=98474,98474,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] convert anonymous to nested should use name conventions,2005/6/10,fail to refactoring,0,1,anonymous class,convert anonymous to nested class,nan,"Bug 98474 - [refactoring] convert anonymous to nested should use name conventions
Martin Aeschlimann 2005-06-06 04:04:17 EDT
20050606

the 'convert anonymous to nested' refactoring doesn't use name conventions and
didn't use the 'f' prefix for fields as I configured.
Dirk Baeumer 2005-06-07 06:51:16 EDT
Tobias, can you please comment ?
Martin Aeschlimann 2005-06-07 07:03:08 EDT
Example is:

public class B {
    void foo() {
        final String string = null;
        new A() {
            void foo() {
                String g = string;
            }
        };
    }
}
Tobias Widmer 2005-06-07 07:06:37 EDT
The following works:

public class Test {
	private int fTest;
	public Test() {
		final int lProbe= 0;
		Runnable runnable= new Runnable() {
			public void run() {
				System.out.println(fTest + lProbe);
			}
		};
	}
}
Dirk Baeumer 2005-06-07 09:10:51 EDT
Tobias, can you investigate why example from #2 doesn't work ?
Tobias Widmer 2005-06-07 09:39:19 EDT
The refactoring currently proposes no new names if code conventions are 
missing or not followed in the unrefactored code.

This has to be fixed for RC2
Tobias Widmer 2005-06-07 09:44:15 EDT
Fixed > 20050607
Tom Hofmann 2005-06-10 08:05:31 EDT
verifying...
Tom Hofmann 2005-06-10 08:47:46 EDT
verified that the example in comment 2 works as expected: the string field is
named fString.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97431,97431,P3,JDT,UI,tobias_widmer,VERI,FIXE,[Refactor] Convert anonymous to nested on Generic - Compile Errors,2005/6/10,compile error,0,1,anonymous class,Convert Anonymous to nested class,nan,"Bug 97431 - [Refactor] Convert anonymous to nested on Generic - Compile Errors
Benjamin Pasero 2005-05-31 07:14:36 EDT
Version: 3.1.0
Build id: I20050527-1300 (RC1)

Steps to reproduce:
1.) Have a class Foo like this:

enum Direction {
	UP, DOWN, LEFT, RIGHT;
}

public class Foo {
	void foo() {
		new Object() {
			Direction dir = Direction.UP;
		};
	}
}

2.) Click into the anonymous class and call Refactor > Convert Anonymous Class
to nested
3.) Call the nested Class ""Bar""

Actual Results:
Compile errors

Expected Results:
No Compile errors
- new Bar(UP); should be new Bar(Direction.UP);
- Direction dir = Direction.up; should be Direction dir = Direction.UP;

Regards,
Ben
Dirk Baeumer 2005-05-31 13:58:59 EDT
Tobias, can you please investigate a fix and judge how risky it is.
Tobias Widmer 2005-06-01 05:41:35 EDT
The problem is that IVariableBindings which resolve to enum constants are 
incorrectly rewritten. The fix is to test whether the binding resolves to enum 
constants.

The fix only affects enum constants
Tobias Widmer 2005-06-01 05:45:21 EDT
Fixed > 20050601
Dirk Baeumer 2005-06-10 08:45:14 EDT
Start verifying...
Dirk Baeumer 2005-06-10 08:47:06 EDT
Verified on I20050610-0010 that it correctly generates a inner class.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97306,97306,P3,JDT,UI,markus.kell.r,VERI,FIXE,[5.0] Unexspected error in Infer Type Arguments refactoring with varargs [refactoring],2005/6/10,exception,0,1,varargs,Infer Type Arguments,nan,"Bug 97306 - [5.0] Unexspected error in Infer Type Arguments refactoring with varargs [refactoring]
Tobias Widmer 2005-05-30 12:21:01 EDT
3.1 RC1

Steps to reproduce:
- Invoke Infer Type Argument on attached project

-> Instead of showing the cu in the context viewer, the stacktrace of the 
error could be displayed

Attaching project and log
Tobias Widmer 2005-05-30 12:22:06 EDT
Created attachment 21970 [details]
project
Tobias Widmer 2005-05-30 12:22:55 EDT
Created attachment 21971 [details]
error log
Dirk Baeumer 2005-05-31 04:05:52 EDT
Markus, please investigate for RC2.
Markus Keller 2005-06-08 12:34:06 EDT
Fixed the AIOOBE that happened with varargs methods. Will not show the
stacktrace in the context viewer, since we don't do this at other places either.

Here's a test case:

package p;

import java.util.ArrayList;
import java.util.List;

class A {
	{
		ArrayList arrayList = new ArrayList();
		arrayList.add(12L);
		take("""");
		take("""", arrayList);
		take("""", new ArrayList[] {arrayList});
		take("""", arrayList, arrayList);
	}
	void take(String format, List... args) {}
}
Dirk Baeumer 2005-06-10 06:45:59 EDT
Start verifying...
Dirk Baeumer 2005-06-10 07:04:02 EDT
Verified that the test case provided under comment #4 doesn't create an AIOOBE
anymore.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=98394,98394,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] NPE while adding generic wildcard to method parameter,2005/6/10,exception,0,1,java generics,change method signature,nan,"Bug 98394 - [refactoring]  NPE while adding generic wildcard to method parameter
Stefan Zeiger 2005-06-03 18:17:43 EDT
Take the following code:

interface I
{
  public void test(Class arg);
}

public class C implements I
{
  public void test(Class arg) {}
}

Select either method declaration, do Refactor -> Change Method Signature, change
the type ""Class"" to ""Class<?>"", select Preview or OK. This results in the
following exception:

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:293)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:573)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:416)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed(RefactoringWizardDialog2.java:447)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:445)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:584)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2929)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2562)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:809)
	at org.eclipse.jface.window.Window.open(Window.java:787)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.internal.ui.refactoring.UserInterfaceStarter.activate(UserInterfaceStarter.java:56)
	at
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter$1.activate(RefactoringExecutionStarter.java:175)
	at
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startChangeSignatureRefactoring(RefactoringExecutionStarter.java:180)
	at
org.eclipse.jdt.ui.actions.ModifyParametersAction.run(ModifyParametersAction.java:132)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
	at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:66)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:844)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2929)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2562)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1694)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1658)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:366)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:226)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:375)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:162)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:334)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:278)
	at org.eclipse.core.launcher.Main.run(Main.java:973)
	at org.eclipse.core.launcher.Main.main(Main.java:948)
Caused by: java.lang.NullPointerException
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.collectTypeVariables(ChangeSignatureRefactoring.java:514)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.collectTypeVariables(ChangeSignatureRefactoring.java:530)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.collectTypeVariables(ChangeSignatureRefactoring.java:526)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.checkTypeVariables(ChangeSignatureRefactoring.java:502)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactoring.checkFinalConditions(ChangeSignatureRefactoring.java:743)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)

Tested with 3.1RC1. The same happens with an abstract superclass instead of an
interface. It does not happen when there is no subclass / implementing class.
Olivier Thomann 2005-06-03 20:45:39 EDT
Move to JDT/UI
Olivier Thomann 2005-06-03 20:46:44 EDT
Created attachment 22379 [details]
Apply on HEAD

Here is a patch that fixes the problem. getBound() can be null and the null
case was not checked.
Dirk Baeumer 2005-06-04 12:48:55 EDT
Markus, we should fix this for RC2.
Markus Keller 2005-06-06 10:05:44 EDT
Thanks, Olivier. Released patch to HEAD and added test case.
Tobias Widmer 2005-06-10 06:50:00 EDT
Verified on I20050610-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97397,97397,P3,JDT,UI,markus.kell.r,VERI,FIXE,[Refactor] Change Method Signature - Varargs not allowed,2005/6/10,fail to refactoring,0,1,varargs,change method signature,overly strict preconditions,"Bug 97397 - [Refactor] Change Method Signature - Varargs not allowed
Benjamin Pasero 2005-05-31 04:21:44 EDT
Version: 3.1.0
Build id: I20050527-1300 (RC1)

Steps to reproduce:
1.) Have a Method

public void foo(String... strings) {

}

2.) Call Refactor > Change Method Signature on foo() 
3.) Edit the Parameter ""String... strings""
4.) Remove a single point from ""String..."" in the Type Input
5.) Add a single point to the Type

Actual Results:
""String..."" is not a valid parameter Type Name

Expected Results:
""String..."" is valid

Regards,
Ben
Dirk Baeumer 2005-05-31 05:43:58 EDT
Markus, removing ... and adding ... in the edit dialog doesn't work.

Should be an easy fix for 3.1. Right ?
Markus Keller 2005-06-01 08:39:01 EDT
Fixed.
Tobias Widmer 2005-06-10 06:18:59 EDT
Verified using I20050610-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97236,97236,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Use supertype where possible: does not work for generic type,2005/6/10,not available,0,1,java generics,Use supertype wherever possible,nan,"Bug 97236 - [refactoring] Use supertype where possible: does not work for generic type
Tom Hofmann 2005-05-30 09:03:26 EDT
3.1-RC1 test pass

- Have the type system below
- In SubType2.java, execute ""Use supertype where possible""

> expected: User2.java is modified to use SuperType<?> or SuperType<Integer> for
its field and parameter type
< actual: no changes detected

--------- SuperType2.java -----------
package com.example;

public class SuperType2<ELEM extends Number> {
	public void over() {}

}
--------- SubType2.java -------------
package com.example;

public class SubType2 extends SuperType2<Integer> {
}
--------- User.java -----------------
package com.example;

public class User2 {

	SubType2 fSub;
	
	void fill(SubType2 sub) {
		sub.over();
	}
	
	void user() {
		fSub.over();
	}

}
-------------------------------------
Tom Hofmann 2005-05-30 09:09:31 EDT
Note: the same works if SuperType implements a non-generic interace ISuper
defining the 'over' method.
Dirk Baeumer 2005-06-01 06:39:16 EDT
Tobias, can you please investigate. 

I opt to postpone this since subclasses of generic classes are less likely.
Tobias Widmer 2005-06-01 08:41:07 EDT
The problem is that Bindings.findTypeInHierarchy does not reliably work for 
parameterized types. Fix is simply to compare the type declarations.

I have a fix ready
Tobias Widmer 2005-06-08 10:37:25 EDT
Created attachment 22610 [details]
Patch

Attaching patch
Tobias Widmer 2005-06-09 08:39:46 EDT
Created attachment 22679 [details]
Patch
Tobias Widmer 2005-06-09 08:40:19 EDT
Fixed > 20050609
Dirk Baeumer 2005-06-10 06:13:32 EDT
Verified that the scenario works. However detected another bug 99323.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97507,97507,P3,JDT,UI,jdt-ui-inbox,VERI,FIXE,[refactoring] Introduce factory fails for bounded type parameters,2005/6/10,compile error,0,1,bounded type,Introduce Factory,nan,"Bug 97507 - [refactoring] Introduce factory fails for bounded type parameters
David Saff 2005-05-31 11:01:51 EDT
In RC1.

Given class:

public class A<T, L extends List<T>> {
	private L _attribute;

	A(L list) {
		_attribute = list;
	}
}

Invoke ""Introduce Factory"" on A.  The result is

	public static <T, L> A<T, L> createA(L list) {
		return new A<T, L>(list);
	}

The bounds on the type parameters have been lost, so it doesn't compile
Dirk Baeumer 2005-06-01 08:59:10 EDT
Bob, how risky would it be to fix this for 3.1. ?
Robert M. Fuhrer 2005-06-01 09:58:54 EDT
Not at all risky. There was code to copy the type bounds to the static factory
method, but it was never exercised, and there was a trivial error in a condition
checking whether the bound was Object. I've already fixed it, added a unit test,
and verified the fix on the full suite of tests. I'll append a patch shortly.
Robert M. Fuhrer 2005-06-01 10:06:22 EDT
Created attachment 22139 [details]
One-line bug fix

This patch is relative to 3.1M7. Since it's just one line, it should apply
without problems to newer source (e.g. HEAD).
Robert M. Fuhrer 2005-06-01 10:07:10 EDT
Created attachment 22140 [details]
Unit test for bug fix

This patch is relative to 3.1M7. It should hopefully apply without problems to
newer source (e.g. HEAD).
Dirk Baeumer 2005-06-06 11:28:31 EDT
Should fix for RC2.
Dirk Baeumer 2005-06-07 06:37:33 EDT
Fixed for RC2
Tobias Widmer 2005-06-10 06:02:03 EDT
Verified using I20050610-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97207,97207,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] Infer Generic Type Arguments NullPE with missing bindings,2005/6/10,exception,0,1,java generics,Infer Type Arguments,nan,"Bug 97207 - [refactoring] Infer Generic Type Arguments NullPE with missing bindings
Benjamin Pasero 2005-05-30 06:02:01 EDT
Version: 3.1.0
Build id: I20050527-1300 (RC1)

Steps to reproduce:
1.) Have a class like this:

public class Main {
	public void loadSashWeights() {
		Hashtable<String, I[]> hash = new Hashtable<String, I[]>();
		hash.put(""Foo"", new int[] { 3 });
	}
}

2.) Run Refactor > Infer Generic Type Arguments

Actual Results:
Find the attached Error Log

Expected Results:
-

Regards,
Ben
Benjamin Pasero 2005-05-30 06:02:27 EDT
Created attachment 21953 [details]
Error Log
Markus Keller 2005-06-01 10:08:05 EDT
Dirk, we have to decide what to do if a compilation unit has compile errors
(missing type 'I' in the example). Currently, I just assume that every entity
has a binding. I see two solutions:

1) Check CUs for compile errors and skip CU (or don't allow the whole
refactoring) then.

2) Make a pass over the constraint creator and ensure it doesn't throw NPEs when
bindings are missing. I would just not create constraint variables for these
entities, which effectively removes these constructs from constraint processing
altogether and can lead to further problems or false inferences.
Dirk Baeumer 2005-06-01 12:01:02 EDT
Nice would be 2.) However I opt for one but we should show the user a list of
CUs we skipped with a error icon.
Markus Keller 2005-06-09 04:07:34 EDT
Released fix 1) to HEAD.
Dirk Baeumer 2005-06-09 13:29:14 EDT
Start verifying...
Dirk Baeumer 2005-06-09 13:31:17 EDT
Verified that compilation units with compile errors are skipped.
Markus Keller 2005-06-10 05:57:20 EDT
*** Bug 94686 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97478,97478,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] Extract method from generic method,2005/6/10,compile error,0,1,java generics,extract method,nan,"Bug 97478 - [refactoring] Extract method from generic method
David Saff 2005-05-31 10:03:07 EDT
I think I've already logged this somewhere.  My apologies if true.  Given method:

import java.util.List;

public class A {
	private <T> int foo(List<T> list) {
		return list.size();
	}
}

Extract expression ""list.size()"".  This leads to a compile error, because the
generic parameter <T> is not added to the new method.
Dirk Baeumer 2005-05-31 13:45:00 EDT
RC2 candidate.
Dirk Baeumer 2005-06-09 08:57:13 EDT
This is really annoying since it happens for all type variables not directly
covered by the selection.

Fix is low-medium risk. Added 7 new test cases to cover the various scenarios.
Tobias Widmer 2005-06-10 05:05:09 EDT
Verified using I20050610-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=97209,97209,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] JavaModelException when executing Pull Up in generic type,2005/6/9,exception,0,1,java generics,pull up method,nan,"Bug 97209 - [refactoring] JavaModelException when executing Pull Up in generic type
Tom Hofmann 2005-05-30 06:07:15 EDT
3.1-RC1 test pass

- have the type hierarchy below (note that the two type variables are not connected)
- try to pull up sub from SubType to SuperType
- get the JavaModelException below


------- SuperType.java ---------
package com.example;



public class SuperType<ELEM extends Number> {

	void add(ELEM e) {

	}

	

	ELEM get() {

		return null;

	}

}

------- SubType.java -----------
package com.example;



public class SubType<ELEM> extends SuperType<Integer> {

	void sub(Integer i) {

		add(i);

	}



}

--------------------------------


java.lang.reflect.InvocationTargetException
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:90)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Caused by: Java Model Exception: Java Model Status [add(Integer)
{key=Lcom/example/SuperType;.add(TELEM;)V} [in SuperType [in [Working copy]
SuperType.java [in com.example [in src [in Generics]]]]] does not exist]
	at
org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:468)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:499)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:232)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:218)
	at org.eclipse.jdt.internal.core.Member.getFlags(Member.java:147)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustOutgoingVisibility(MemberVisibilityAdjustor.java:671)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustOutgoingVisibility(MemberVisibilityAdjustor.java:690)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustOutgoingVisibility(MemberVisibilityAdjustor.java:722)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.adjustVisibility(MemberVisibilityAdjustor.java:763)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoring.createChangeManager(PullUpRefactoring.java:949)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoring.checkFinalConditions(PullUpRefactoring.java:615)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1719)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	... 1 more
Tom Hofmann 2005-05-30 06:12:19 EDT
Note (1): the same happens if SubType is not a generic type

Note (2): the same works, if SubType.sub(Integer) does not call
SuperType.add(ELEM). In this case, the method is correctly pulled up. The pulled
up method still has an 'Integer' parameter type - one could expect that since
the parameter type corresponds with the type argument to the superclass
specification of SubType, the pull up operation could offer to convert the
method and substitute ELEM as parameter type.
Tom Hofmann 2005-05-30 06:14:45 EDT
Re. the last note (2):

Expanding the parameter type if it is the same as a type argument to the
supertype would make 'Push Down' and 'Pull Up' symmetrical, as the conversion
happens when pushing down: In the example, 'add(ELEM)' is pushed down to
'add(Integer)'.
Dirk Baeumer 2005-05-30 17:21:53 EDT
Tobias, a candidate for 3.2.

How risky is it to fix. I am asking since the visibility adjuster is used in
several other places.
Tobias Widmer 2005-05-31 04:30:07 EDT
ad 1: Its a search problem, see bug 94160

ad 2: This must be fixed
Dirk Baeumer 2005-05-31 05:40:27 EDT
Approved for RC2. If we have to change the MemberVisibilityAdjustor and it is a
larger change then I would prefer that you review it since the code is used in
Move member as well.
Tobias Widmer 2005-05-31 05:45:35 EDT
Just to clarify: Comment 0 is entirely covered by bug 94160, which does not 
involve any changes in JDT UI.

The only thing to fix in the PullUp Refactoring is the renaming of the type 
parameters during pull up.
Dirk Baeumer 2005-05-31 05:48:08 EDT
Thanks for clarification. You consider 94160 a must fix I guess.
Tobias Widmer 2005-05-31 05:51:23 EDT
Yes, the search engine seems to deliver incorrect resolved source methods.
Tobias Widmer 2005-06-06 05:17:31 EDT
Fixed > 20050606
Dirk Baeumer 2005-06-09 13:34:58 EDT
Start verifying...
Dirk Baeumer 2005-06-09 13:37:45 EDT
Verified that the exception doesn't occur anymore. However the generated result
has a compile error in SuperType. Will open a separate bug report (see 99211).
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=88806,88806,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] Change Method Signature removes comment between parameter type and name,2005/5/30,comment related,0,1,comment related,change method signature,nan,"Bug 88806 - [refactoring] Change Method Signature removes comment between parameter type and name
Trevor Robinson 2005-03-22 15:53:16 EST
Build N20050303-0010

I started with this method:

    public void packetReceived(
        final RoutedPacket pkt,
        final PktNodeInfo fromNode,
        final PktNodeInfo toNode,
        final BitVector/*64*/sendTime,
        final BitVector/*64*/recvTime)

Note that there is a comment instead of a space between the type BitVector and
the argument name. While I would prefer a space, the current Eclipse formatter
does not leave one. (I believe at one point it used to put a space before the
comment and a newline after, which was arguably worse.) However, the formatter
is not the issue here.

Now, I want to use the Change Method Signature to replace those BitVector
arguments with long arguments. Here's what it produces:

    public void packetReceived(
        final RoutedPacket pkt,
        final PktNodeInfo fromNode,
        final PktNodeInfo toNode,
        final longsendTime,
        final longrecvTime)

Note that the comment is gone (which is fine with me, but maybe not right in all
sitations), but there is no space to separate the tokens.
Markus Keller 2005-05-23 11:12:47 EDT
Fixed in HEAD. Comments are not deleted any more when the type or name is changed.
Dirk Baeumer 2005-05-27 07:01:09 EDT
Start verifying...
Dirk Baeumer 2005-05-30 10:28:02 EDT
Verified on RC1.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=84670,84670,P3,JDT,UI,dirk_baeumer,VERI,FIXE,ChangeTypeRefactoring fails when parameterized type is assigned to raw type,2005/5/30,fail to refactoring,0,1,nan,generalize type,nan,"Bug 84670 - ChangeTypeRefactoring fails when parameterized type is assigned to raw type
Dirk Baeumer 2005-02-08 07:12:26 EST
The helper method implemented in ChangeTypeRefactoring checking if a type A is
assignment compatible to type B doesn't handle raw types correctlt. Had to
disable test method testRawSubType
Dirk Baeumer 2005-02-08 07:13:27 EST
Frank, we are currently porting extract interface and use super type where
possible to the new type constraint infrastucture. This use the new TType which
have a correct implementation for this. You should consider converting as well.
Dirk Baeumer 2005-02-08 07:18:42 EST
CC Markus since he nows all the details.
Dirk Baeumer 2005-03-29 07:56:48 EST
Frank, how does it look time wise for M7 which is mid of May.
Frank Tip 2005-05-17 16:29:26 EDT
This problem is due to the fact that 
   Bindings.equals(type1.getErasure(), type2)
returns ""false"" if type1 is java.lang.Comparable<String>
and type2 is java.lang.Comparable. This used to return
""true"", and I'm not sure when this behavior changed.

I'm reassigning the bug to Dirk, because this is not
a problem specific to the Generalize Type refactoring.

  -Frank
Dirk Baeumer 2005-05-17 18:15:42 EDT
Markus, can you please comment on this. Has this something to due with the fact
that we are now calling Binding.isEqualTo ?
Markus Keller 2005-05-18 12:42:18 EDT
ITypeBinding#getErasure() is javadoc'd to return a generic type binding when
called on a parameterized type binding. If you compare this to a raw type
binding, you will get false, which is correct.

In general, if you want to compare two type bindings regardless of type
arguments / rawness, you should use the #getTypeDeclaration() version of both
bindings.

The switch to IBinding#isEqualTo(..) has only been made in the end of March, so
this should not be the guilty. We had some discussions about what getErasure()
should return and JDT/Core had some bugs concerning binding key uniqueness, but
the behavior you see now is what will stay for 3.1.
Frank Tip 2005-05-18 15:30:32 EDT
Created attachment 21373 [details]
patch for bugs 84670 and 94715
Frank Tip 2005-05-18 15:31:37 EDT
Created attachment 21374 [details]
tests patch for bug 84670 and 94715

Thanks, Markus. Here is a patch that includes this fix.
  -Frank
Markus Keller 2005-05-19 07:11:53 EDT
Released the patch.
David Saff 2005-05-27 10:53:48 EDT
Verifying...
David Saff 2005-05-27 10:54:49 EDT
Gentlemen,

Can someone attach a test case?  Thanks.
Markus Keller 2005-05-27 11:05:45 EDT
As Dirk said in comment 0, he had to disable test case testRawSubType (in
ChangeTypeRefactoringTests). That test case look like this:

public class A_testRawSubType_in {
	void foo(Interface i){
		Comparable c= i.getName();
	}
}
interface Interface {
	String getName(); // generalize type ""String""
}

David, could you please check some similar cases?
David Saff 2005-05-30 09:31:37 EDT
Checked some similar cases.  Verified in I20050527-1300.  Markus, please update
state.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=95121,95121,P3,JDT,UI,markus.kell.r,VERI,FIXE,[refactoring] Change method signature refuses to operate on annotation member,2005/5/30,incorrect warning message,0,1,annotation,change method signature,nan,"Bug 95121 - [refactoring] Change method signature refuses to operate on annotation member
David Saff 2005-05-13 10:17:23 EDT
Against I20050513-0010

Given:

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;


@Retention(RetentionPolicy.RUNTIME)
public @interface IsTest {
	String setUp() default """";
	String tearDown() default """";
}

Select setUp(), and then Refactor > Change Method Signature.  Error dialog pops
up:  ""To activate this refactoring, please select the name of a non-binary
method.""  I can understand not wanting to offer Change Method Signature for
annotation members: the only useful things you could do are changing the return
type and the name.  But the error message doesn't seem to match.
Dirk Baeumer 2005-05-17 05:09:19 EDT
Not cirtical for 3.1. Markus, if we have time we should improve the error
message here.
Markus Keller 2005-05-24 05:26:16 EDT
Fixed.
Benjamin Pasero 2005-05-30 06:42:33 EDT
Verified I20050527-1300
Please update state.

Regards,
Ben
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=95153,95153,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Move member type to new file misses required container field,2005/5/30,exception,0,1,nan,move member type to new file,nan,"Bug 95153 - [refactoring] Move member type to new file misses required container field
David Saff 2005-05-13 12:16:17 EDT
Against I20050513-0010

Code:

public class Bar {
	private final class Inner {
		public void add() {
			// Bar.this.hashCode();
			addTo(Bar.this);
		}
		
		void addTo(Bar map) {
			
		}
	}
}

If you move Inner to a new file, the UI incorrectly does not require a field of
type Bar to be added, and the error below is thrown if one is not provided.  If
the commented line is uncommented, the field is required, and all is good.

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:282)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish(RefactoringWizard.java:547)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish(UserInputWizardPage.java:153)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish(RefactoringWizard.java:613)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed(RefactoringWizardDialog2.java:406)
	at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:409)
	at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:556)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2921)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2554)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:803)
	at org.eclipse.jface.window.Window.open(Window.java:781)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:273)
	at
org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:154)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
	at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2921)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2554)
	at org.eclipse.jdt.internal.ui.actions.QuickMenuAction.run(QuickMenuAction.java:79)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
	at
org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)
	at org.eclipse.core.commands.Command.execute(Command.java:311)
	at
org.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:396)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:452)
	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:722)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:766)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:543)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:486)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:110)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:781)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:841)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:866)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:851)
	at org.eclipse.swt.widgets.Control.traverse(Control.java:2779)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2620)
	at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:827)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2638)
	at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:3341)
	at org.eclipse.swt.widgets.Display.filterMessage(Display.java:795)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2550)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1601)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1565)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:315)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:230)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:371)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:160)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:330)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:274)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.SimpleName.setIdentifier(SimpleName.java:193)
	at org.eclipse.jdt.core.dom.AST.newSimpleName(AST.java:1239)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring$TypeReferenceQualifier.visit(MoveInnerToTopRefactoring.java:261)
	at org.eclipse.jdt.core.dom.ThisExpression.accept0(ThisExpression.java:136)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.MethodInvocation.accept0(MethodInvocation.java:244)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
	at
org.eclipse.jdt.core.dom.ExpressionStatement.accept0(ExpressionStatement.java:143)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:501)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createCompilationUnitRewrite(MoveInnerToTopRefactoring.java:883)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.createChangeManager(MoveInnerToTopRefactoring.java:817)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:729)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at
org.eclipse.ltk.core.refactoring.PerformChangeOperation.run(PerformChangeOperation.java:189)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1716)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Tobias Widmer 2005-05-19 10:20:57 EDT
Fixed > 20050519
Benjamin Pasero 2005-05-30 06:34:28 EDT
Verified I20050527-1300
Please update state.

Regards,
Ben
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=95148,95148,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Move member type to new file fails on member of enum,2005/5/30,exception,0,1,enum,Move member type to new file,nan,"Bug 95148 - [refactoring] Move member type to new file fails on member of enum
David Saff 2005-05-13 12:02:47 EDT
Against I20050513-0010.

Code:

public enum CopyOfHelperType {
	SETUP, TEARDOWN;

	static class AnnotationInvoker {
		private CopyOfHelperType type;

		public AnnotationInvoker(CopyOfHelperType type) {
			this.type = type;
		}

		void invoke(Object theInstance) throws IllegalAccessException, Throwable {
		}		
	}
	
	public void invokeTheAnnotation(final Object theInstance) throws Throwable,
IllegalAccessException {
		new AnnotationInvoker(this).invoke(theInstance);
	}
}

Move AnnotationInvoker to a new file.  Assertion failed error:

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at org.eclipse.jface.window.ApplicationWindow$1.run(ApplicationWindow.java:624)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at org.eclipse.jface.window.ApplicationWindow.run(ApplicationWindow.java:621)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2137)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:573)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:416)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.getStartingPage(RefactoringWizard.java:399)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.createContents(RefactoringWizardDialog2.java:526)
	at org.eclipse.jface.window.Window.create(Window.java:418)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:996)
	at org.eclipse.jface.window.Window.open(Window.java:770)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.internal.corext.refactoring.RefactoringExecutionStarter.startMoveInnerRefactoring(RefactoringExecutionStarter.java:273)
	at
org.eclipse.jdt.ui.actions.ConvertNestedToTopAction.run(ConvertNestedToTopAction.java:154)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:226)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:198)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
	at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2921)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2554)
	at org.eclipse.jdt.internal.ui.actions.QuickMenuAction.run(QuickMenuAction.java:79)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
	at
org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)
	at org.eclipse.core.commands.Command.execute(Command.java:311)
	at
org.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:396)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:452)
	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:722)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:766)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:543)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:486)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:110)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:781)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:841)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:866)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:851)
	at org.eclipse.swt.widgets.Control.traverse(Control.java:2779)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2620)
	at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:827)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2638)
	at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:3341)
	at org.eclipse.swt.widgets.Display.filterMessage(Display.java:795)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2550)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1601)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1565)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:315)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:230)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:371)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:160)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:330)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:274)
	at org.eclipse.core.launcher.Main.run(Main.java:977)
	at org.eclipse.core.launcher.Main.main(Main.java:952)
Caused by: org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: null
argument;
	at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:108)
	at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:86)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.findTypeDeclaration(MoveInnerToTopRefactoring.java:389)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkConstructorParameterNames(MoveInnerToTopRefactoring.java:681)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.MoveInnerToTopRefactoring.checkFinalConditions(MoveInnerToTopRefactoring.java:727)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1716)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Tobias Widmer 2005-05-19 09:43:26 EDT
Fixed > 20050519
Benjamin Pasero 2005-05-30 06:35:22 EDT
Verified I20050527-1300
Please update state.

Regards,
Ben
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=95145,95145,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Move member type to new file creates compile error,2005/5/30,compile error,0,1,java generics,Move member type to new file,nan,"Bug 95145 - [refactoring] Move member type to new file creates compile error
David Saff 2005-05-13 11:56:15 EDT
Against I20050513-0010.

public class Exposer<T> {
	class Inner {
		T foo;
	}
	
	T foo() {
		Inner inner = new Inner();
		return inner.foo;
	}
}

Move Inner to a new file.  The resulting code does not compile (the required
type parameter is not added to the Inner reference in foo())
Dirk Baeumer 2005-05-17 05:17:13 EDT
Tobias, how expensive is this to fix. Time permitted.
Tobias Widmer 2005-05-17 05:41:08 EDT
Its only a missing case. I'll fix it
Tobias Widmer 2005-05-19 07:08:50 EDT
Fixed > 20050519
Benjamin Pasero 2005-05-30 06:36:11 EDT
Verified I20050527-1300
Please update state.

Regards,
Ben
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=95135,95135,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] NPE from convert anonymous to nested inside enum,2005/5/30,exception,0,1,enum,convert anonymous to nested class,nan,"Bug 95135 - [refactoring] NPE from convert anonymous to nested inside enum
David Saff 2005-05-13 11:24:28 EDT
Against I20050513-0010

Code:

public enum CopyOfHelperType {
	SETUP, TEARDOWN;

	public void invokeTheAnnotation() {
		new Object() {
			void invoke() {
			}
		}.invoke();
	}
}

Try to convert the anonymous object to nested.  On every keystroke when entering
the new name, an NPE (below) is logged in the error log, and the OK button is
never enabled
Tobias Widmer 2005-05-18 11:26:39 EDT
Fixed > 20050517
Benjamin Pasero 2005-05-30 06:37:12 EDT
Verified I20050527-1300
Please update state.

Regards,
Ben
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=86968,86968,P3,JDT,UI,dirk_baeumer,VERI,FIXE,Temporary variable type incorrect [refactoring] [inline] [1.5],2005/5/27,behavior change,0,1,java generics,inline local variable,nan,"Bug 86968 - Temporary variable type incorrect [refactoring] [inline] [1.5]
Marco Foco 2005-03-02 03:22:51 EST
public static <T> T reduce(Iterable<T> seq, Combiner<T> combiner) {
    Iterator<T> it = seq.iterator();
[...]

when trying to inline it in an invocation like

    Integer result = reduce(li, new IntegerAdder());

it produces this as first line:

    Iterator<T><Integer> it = li.iterator();

(full source code at http://www.mindview.net/WebLog/log-0064 )
Frederic Fusier 2005-03-02 03:39:47 EST
Move to JDT/UI
Dirk Baeumer 2005-05-18 06:32:59 EDT
Fixed for RC1.
David Saff 2005-05-27 11:06:59 EDT
Verified in I20050527-0010.
David Saff 2005-05-27 11:09:34 EDT
Dirk, please update bug state.
Dirk Baeumer 2005-05-27 12:29:41 EDT
Marking as verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=95401,95401,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] [inline] Inlining method of generic class gives illegal result.,2005/5/27,behavior change,0,1,java generics,inline method,nan,"Bug 95401 - [refactoring] [inline] Inlining method of generic class gives illegal result.
Brian Miller 2005-05-16 13:13:59 EDT
--------------------- BEFORE --------------------------
class Bug {
    class Model<Row extends java.util.List> {
        Row getObjectAtRow(){
            return new java.util.HashSet<Row>().iterator().next();
        }
    }
    class UI<Clazz extends java.util.ArrayList>{
        public final Clazz[] getBeginAndEndSelections()
        {
          return (Clazz[])java.lang.reflect.Array.newInstance
(tableModel_.getObjectAtRow().getClass(),1);
        }  
    }
    Model<java.util.ArrayList> tableModel_;
    void foo(){
          new UI<java.util.ArrayList>().getBeginAndEndSelections();        
    }
}


------------------------- AFTER -------------------------------------
class Bug {
    class Model<Row extends java.util.List> {
        Row getObjectAtRow(){
            return new java.util.HashSet<Row>().iterator().next();
        }
    }
    class UI<Clazz extends java.util.ArrayList>{  
    }
    Model<java.util.ArrayList> tableModel_;
    void foo(){
          Clazz[] getBeginAndEndSelections = (ArrayList[])
java.lang.reflect.Array.newInstance(new UI<java.util.ArrayList>
().tableModel_.getObjectAtRow().getClass(),1); // COMPILE ERROR!
    }
}
Brian Miller 2005-05-16 13:36:22 EDT
The method being inlined is getBeginAndEndSelections().
Dirk Baeumer 2005-05-17 04:45:07 EDT
Brian, which build are you using ?
Brian Miller 2005-05-17 09:53:16 EDT
The problem occurs in both M6 and M7.
Dirk Baeumer 2005-05-18 05:16:30 EDT
There are two different issues here:

- problem one is that the return type of the declaration is used instead of
  the parameterized instantiation. Thus the type declaration is Clazz[] instead
  of ArrayList[].

- the problem that the field tableModel_ isn't accessable inside foo through
  class UI. This problem can't be fixed. The only thing I can add is a waring
  that the field isn't accessable outside.
Dirk Baeumer 2005-05-18 05:30:30 EDT
Short test case for the access to outer field problem

class Short {
	class Inner {
		int foo() {
			return field.intValue();
		}
	}
	
	Integer field;
	
	void use() {
		new Inner().foo();
	}
}
Dirk Baeumer 2005-05-18 05:32:38 EDT
I opened bug 95719 for the access to the outer field.
Dirk Baeumer 2005-05-18 05:35:22 EDT
Fixed the problem with using the type variable for the return type instead of
the type argument.

The problem with the access to the outer non visible field is tracked by 95719,
which might have to wait > 3.1. As said the code can't be fixed anyways so the
only thing I can do here is to warn the user.
Dirk Baeumer 2005-05-18 05:40:54 EDT
Last statement is incorrect. The problem can be fixed by removing the qualification.
Tobias Widmer 2005-05-27 11:31:04 EDT
Verified issue 1 in comment 4 on I20050527-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=94426,94426,P3,JDT,UI,dirk_baeumer,VERI,FIXE,"[refactoring] inline method shows ""no changes"" for non-fatal error",2005/5/27,incorrect warning message,0,1,nan,inline method,nan,"Bug 94426 - [refactoring] inline method shows ""no changes"" for non-fatal error
Tom Hofmann 2005-05-10 12:59:20 EDT
I20050509-2000 (M7 test pass)

Scenario similar to bug 90772:

- have this CU:

package m7testing;


/**
 * @since 3.1
 */
public class SubDeprecation  {
	/**
	 * @see Other#foo()
	 */
	public void foo() {
		System.out.println(""foo"");
	}
	
	void m() {
		foo();
	}
}

- caret on the foo declaration
- Inline Method, make sure ""Inline All' is checked
- Press 'Preview'

> warning dialog, warning about an inaccurate reference in the javadoc comment
of 'foo'

- Press 'Continue'

> expected: refactoring is executed
< actual: Dialog saying ""Refactoring does not change any sourcecode""

Note that the same works if the 'inaccurate reference' is not present
Dirk Baeumer 2005-05-18 04:04:42 EDT
Fixed. 

Inaqurate matches in Javadoc will not cause any warning anymore since they are
ignored anyways. Added two test cases.
Tobias Widmer 2005-05-27 10:48:31 EDT
Verified on I20050527-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=92519,92519,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] inline method - result does not compile,2005/5/27,compile error,0,1,nan,inline method,nan,"Bug 92519 - [refactoring] inline method - result does not compile
Adam Kiezun 2005-04-24 14:23:12 EDT
3.1M6

Inline the setter.

public class InlineMethodBug {
    private Object data;

    InlineMethodBug(Object data){
		this.setData(data);
    }

    //inline this method, remove decl
	private void setData(Object bytes) {
		this.data= bytes;
	}
}

you get this (does not compile):
public class InlineMethodBug {
	private Object data;

	InlineMethodBug(Object data){
	    InlineMethodBug r = this;
	    r.r.data= data;
    }
}
Dirk Baeumer 2005-05-25 06:45:00 EDT
Fixed.
Tobias Widmer 2005-05-27 10:43:21 EDT
Verified on I20050527-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=81178,81178,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] disable extract method on case constants,2005/5/27,compile error,0,1,switch case,extract method,overly weak precondtions,"Bug 81178 - [refactoring] disable extract method on case constants
Martin Aeschlimann 2004-12-15 10:48:09 EST
20041215

It's currently possible to extract an method from a case expression which result
in something like:

    private void foo(int e) {
        switch (e) {
            case foo():
                break;
        }
    }
Dirk Baeumer 2005-05-18 09:15:31 EDT
Fixed. Is now disallowed.
David Saff 2005-05-27 10:34:15 EDT
Verifying...
David Saff 2005-05-27 10:35:17 EDT
Verified against I20050527-0010.  Dirk, please update state.
Dirk Baeumer 2005-05-27 10:38:37 EDT
Mark as verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=90907,90907,P3,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] [extract method] extract methods and varargs - incorrect order of params (compile error),2005/5/27,compile error,0,1,varargs,extract method,nan,"Bug 90907 - [refactoring] [extract method] extract methods and varargs - incorrect order of params (compile error)
Adam Kiezun 2005-04-09 16:33:29 EDT
3.1M6
    String foo(String... strings){
        String s= ""foo"";
        for (String string : strings) {
            System.out.println(string + s);
        }
        return s;
    }

extract the middle 3 lines (the for loop)

you get:
private void aa(String... strings, String s) {
	for (String string : strings) {
           System.out.println(string + s);
       }
}
which does not compile (varagr must be last)
Dirk Baeumer 2005-05-18 06:21:54 EDT
Fixed.
Tobias Widmer 2005-05-27 10:35:52 EDT
Verified on I20050527-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=67417,67417,P3,JDT,UI,dirk_baeumer,VERI,FIXE,NPE when performing Refactor>Inline [refactoring],2005/5/27,exception,0,1,nan,inline method,nan,"Bug 67417 - NPE when performing Refactor>Inline [refactoring]
David Audel 2004-06-16 04:11:59 EDT
build 3.0RC2

1) create X.java
public class X {
	void bar() {
		show("""");
	}
	public void show(String d) {
		System.out.println(d);
	}
	public void show(String d) {
		System.out.println("""");
	}
}
2) Select a 'foo' method declaration
3) Open Refactor menu
4) Select Refactor>Inlinne
an NPE occur

!ENTRY org.eclipse.ui 4 0 Jun 16, 2004 10:01:45.848
!MESSAGE java.lang.NullPointerException
!STACK 0
java.lang.NullPointerException
	at 
org.eclipse.jdt.internal.corext.refactoring.code.TargetProvider.create
(TargetProvider.java:89)
	at 
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.<init>
(InlineMethodRefactoring.java:131)
	at 
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.create
(InlineMethodRefactoring.java:147)
	at org.eclipse.jdt.ui.actions.InlineAction.tryInlineMethod
(InlineAction.java:141)
	at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:116)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun
(SelectionDispatchAction.java:216)
	at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run
(SelectionDispatchAction.java:188)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:881)
	at 
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:915)
	at org.eclipse.jface.action.ActionContributionItem.access$2
(ActionContributionItem.java:866)
	at org.eclipse.jface.action.ActionContributionItem$7.handleEvent
(ActionContributionItem.java:785)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:796)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2732)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2398)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1362)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1333)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench
(Workbench.java:252)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:141)
	at org.eclipse.ui.internal.ide.IDEApplication.run
(IDEApplication.java:96)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run
(PlatformActivator.java:334)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:272)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:128)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:324)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:185)
	at org.eclipse.core.launcher.Main.run(Main.java:638)
	at org.eclipse.core.launcher.Main.main(Main.java:622)
Dirk Baeumer 2004-06-16 08:38:50 EDT
Unusual case. Not critical for 3.0.
Dirk Baeumer 2005-05-23 12:38:34 EDT
Fixed.
David Saff 2005-05-27 05:24:02 EDT
Verifying...
David Saff 2005-05-27 05:27:14 EDT
I couldn't quite figure out what the original bug was, since there is no method
foo() in the example.  So I created Y.java, which called X.bar(), and attempted
to inline X.bar.  The refactoring was correctly disallowed because X.bar had
compile errors.
David Saff 2005-05-27 05:29:42 EDT
Didn't finish my thought.  Dirk, if that was the bug fixed, then please update
bug to VERIFIED.
Dirk Baeumer 2005-05-27 06:27:01 EDT
David, to reproduce try to inline show. Test it with the invocation and with
both declarations.
Tobias Widmer 2005-05-27 10:28:20 EDT
Verified on I20050527-0010
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=79906,79906,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] convert anonym to inner should follow naming conventions,2005/5/27,fail to refactoring,0,1,anonymous class,convert anonymous to inner class,nan,"Bug 79906 - [refactoring]  convert anonym to inner should follow naming conventions
Martin Aeschlimann 2004-12-01 13:25:44 EST
20041201

The 'convert anonym to inner class' refactoring should follow the naming
conventions.
- use field pre/suffixes for introduced fields,
remove params and local pre/suffixes for used variables
- use 'this' if preferred by the user

for example:
   public void foo(final int pVar1) {
      final int lVar2= 1;
      Runnable r= new Runnable() {
		public void run() {
			int x= pVar1 + lVar2;
		}
      };
   }
->
   private final class Inner implements Runnable {
		private final int fVar1;
		private final int fVar2;

		private Inner(int pVar1, int pVar2) {
			super();
			fVar1 = pVar1;
			fVar2 = pVar2;
		}
		public void run() {
			int x= fVar1 + fVar2;
		}
	}
Dirk Baeumer 2004-12-02 06:49:02 EST
Agree.
Tobias Widmer 2005-01-31 06:31:41 EST
*** Bug 84029 has been marked as a duplicate of this bug. ***
Tobias Widmer 2005-02-14 04:26:11 EST
*** Bug 43724 has been marked as a duplicate of this bug. ***
Tobias Widmer 2005-03-18 07:03:20 EST
*** Bug 88437 has been marked as a duplicate of this bug. ***
Tobias Widmer 2005-05-25 06:43:08 EDT
Fixed > 20050525
David Saff 2005-05-27 07:11:15 EDT
Verifying...
David Saff 2005-05-27 07:12:36 EDT
Verified in I20050527-0010.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=96172,96172,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] Moving method with static import in body gives illegal result.,2005/5/27,compile error,0,1,static import,move method,nan,"Bug 96172 - [refactoring] Moving method with static import in body gives illegal result.
Brian Miller 2005-05-20 16:49:53 EDT
--------------- Source.java ------------------
import static java.lang.Integer.*;
class Source { static int getInt () { return parseInt(""""); } }

---------------- Target.java BEFORE -----------
class Target {}

---------------- Target.java AFTER ------------
class Target { static int getInt () { return parseInt(""""); } } // COMPILE 
ERROR!
Dirk Baeumer 2005-05-23 09:08:44 EDT
Tobias, can you please comment. Doesn't move static handle static imports ? Can
you please invetigate what a fix means for 3.1
Tobias Widmer 2005-05-23 10:44:13 EDT
The problem is the on-demand import, which is not handled correctly. Fixing 
this for RC1
Tobias Widmer 2005-05-24 10:19:37 EDT
Fixed > 20050524
Tom Hofmann 2005-05-27 06:52:20 EDT
verifying...
Tom Hofmann 2005-05-27 07:12:54 EDT
verified works as expected.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=72836,72836,P3,JDT,UI,dirk_baeumer,VERI,FIXE,"[refactor] InLine simple method with ""this."" created extra code",2005/5/27,compile error,0,1,this,inline method,nan,"Bug 72836 - [refactor] InLine simple method with ""this."" created extra code
Gary Gregory 2004-08-27 22:38:45 EDT
For example, start with:

public class InLineTest {

    private void foo() {
        System.out.println();
    }
    
    private void bar() {
        this.foo();
    }

}

Select foo() to in-line and you get:

public class InLineTest {

    private void bar() {
        InLineTest r = this; // THIS EXTRA LINE IS NOT NEEDED AT ALL! ;-)
        System.out.println();
    }

}

Version 3.1M1.
Gary Gregory 2004-08-27 22:40:01 EDT
The workaround was to search and replace in my code all instances of
""this.foo()"" and replace with ""foo()"". Then the in-line refactoring did not
create the extra line. Should not the ""this."" part be treated as a noop in this
case?
Jerome Lanneluc 2004-08-30 05:28:13 EDT
Moving to JDT UI for comments.
Gary Gregory 2004-09-30 17:44:47 EDT
FYI, this still happens in 3.1.M2.
David Scurrah 2005-03-08 17:58:17 EST
(In reply to comment #3)
> FYI, this still happens in 3.1.M2.

Also in 3.1.M5 I have a similiar problem

public class InLineTest {
    Object myO;

    private Object foo() {
        return myO;
    }
    
    private void bar() {
        Object o = this.foo();

        Thread objectPrinterThread = new Thread( new Runnable() {
             public void run() {
                 System.out.println(o);
             }
          });
    }

}

Select foo() to in-line and you get:

public class InLineTest {
    Object myO;

    private void bar() {

        Thread objectPrinterThread = new Thread( new Runnable() {
             public void run() {
                 System.out.println(this.myO);
             }
          });
    }

}

which doesn't compile and should be 
                 System.out.println(InLineTest.this.myO);
Dirk Baeumer 2005-05-20 11:54:44 EDT
The case provided in comment #4 is unrelated to the original bug. I opened bug
96120 for it.
Dirk Baeumer 2005-05-23 07:16:56 EDT
Fixed.
David Saff 2005-05-27 05:36:52 EDT
Verifying...
David Saff 2005-05-27 05:37:07 EDT
Verified in I20050527-0010
David Saff 2005-05-27 05:37:30 EDT
Dirk, please update resolution to VERIFIED.
Dirk Baeumer 2005-05-27 06:19:32 EDT
Marking as verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=93861,93861,P2,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] Syntax errors after inlining a method returning a result with type parameters,2005/5/27,compile error,0,1,java generics,inline method,nan,"Bug 93861 - [refactoring] Syntax errors after inlining a method returning a result with type parameters
Erich Gamma 2005-05-05 18:53:16 EDT
I have the following method:
  static public void setUp(Object test) throws Exception {
    List<Method> befores= getTestMethods(test.getClass(), Before.class);
    for (Method before : befores)
      before.invoke(test);
  }

Which is called from somewhere else:
  protected void setUp() throws Exception {
    JUnit4TestRunner.setUp(fTest);
  }

When inlining this call, I get:
  protected void setUp() throws Exception {
    List<Method><Method> befores=
JUnit4TestRunner.getTestMethods(fTest.getClass(), Before.class);
    for (Method before : befores) 
      before.invoke(fTest);
  }

Notice that the type argument is duplicated
Dirk Baeumer 2005-05-17 10:33:02 EDT
Fixed.
David Saff 2005-05-27 04:54:41 EDT
Verified in I20050527-0010.  Dirk, please change resolution.
Dirk Baeumer 2005-05-27 05:04:10 EDT
Marking as verified.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=93541,93541,P2,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] All extract refactorings and quick fixes fail with wildcard return type,2005/5/27,not available,0,1,java generics,"Extract Local Variable;Extract Constant;Introduce
Parameter;Extract Method",nan,"Bug 93541 - [refactoring] All extract refactorings and quick fixes fail with wildcard return type
Markus Keller 2005-05-03 11:06:30 EDT
N20050503-0010

All extract refactorings and quick fixes fail in examples with a wildcard return
type:

	static ArrayList<? extends Number> al= new ArrayList<Integer>();
	void test () {
		al.get(0); //<-select method invocation expression and extract
	}

- Failing refactorings: Extract Local Variable, Extract Constant, Introduce
Parameter, Extract Method
- Failing Quick Assists: Assign statement to new local variable, .. to new field

I think we should have one utility method with this fix, since all affected
parties currently just use the import rewrite and get back a wildcard type from
there.

The correct declaration type for wildcards is:
- the upper bound of the wildcard if it exists,
- java.lang.Object otherwise
Dirk Baeumer 2005-05-09 12:04:28 EDT
Discussed with Martin and we should add a new method on Bindings which
normalizes a type for use in a declaration.
Dirk Baeumer 2005-05-09 12:06:07 EDT
Created attachment 20840 [details]
Patch with new binding method and its use in extract method
Dirk Baeumer 2005-05-09 12:06:20 EDT
Created attachment 20841 [details]
Additional test cases
Dirk Baeumer 2005-05-09 12:06:42 EDT
Should check if we have to fix this for M7 or 3.1
Dirk Baeumer 2005-05-16 17:20:22 EDT
Fixed for all extract refactorings and introduce parameter. Martin has fixed
this for quick fixes. Right Martin ?
Martin Aeschlimann 2005-05-17 04:23:41 EDT
yes, quick fixes were updated for M7.
David Saff 2005-05-27 04:30:26 EDT
Verifying...
David Saff 2005-05-27 04:40:08 EDT
Verified in I20050527-0010.  Tobias, please change resolution to VERIFIED.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=72926,72926,P3,JDT,UI,dirk_baeumer,RESO,FIXE,In-lining creates compile error and deletes comments. [refactoring],2005/5/24,compile error,0,1,comment related,inline method,nan,"Bug 72926 - In-lining creates compile error and deletes comments. [refactoring]
Gary Gregory 2004-08-30 21:38:37 EDT
This method logWarning in the class A in package P1 is to be in-lined:

public class A {

    public static Logger LOG = Logger.getLogger(AppInterfaceServer.class,
            ServerSettingsConstants.DefaultServerMessagesFileName);

    public void logWarning(String msg) {
        LOG.warn(msg);
    }
}

There in one call site in class B in package P2 which is:

    public void abort(String toReturn) {
        // TODO: Someday figure out how to abort a request done via RMI.
        AppInterfaceServer.getCurrent().logWarning(""AbortRequest not supported
with RMI"");
        return;
    }

After the refactoring it is:

    public void abort(String toReturn) {
        AppInterfaceServer r = AppInterfaceServer.getCurrent();
        LOG.warn(""AbortRequest not supported with RMI"");
        return;
    }

The comment is GONE and the method does not compile since LOG is not defined in B.

So it looks like in-lining is quite literal. Either inlining should force a
preview and give a warning or it should be smarter and create:

    public void abort(String toReturn) {
        AppInterfaceServer.getCurrent().LOG.warn(""AbortRequest not supported
with RMI"");
    }

Or better yet:

    public void abort(String toReturn) {
        AppInterfaceServer.LOG.warn(""AbortRequest not supported with RMI"");
    }

Version 3.1.M1. Thanks.
Jerome Lanneluc 2004-08-31 05:14:08 EDT
Moving to JDT UI for comments.
Dirk Baeumer 2004-08-31 14:26:19 EDT
The comment problem is already covered by bug 40243.

The rest is cleary a bug and has to be investigated.
Dirk Baeumer 2004-09-08 09:57:37 EDT
Here is a smaller example. Inlining foo produces field.bar() instead of 
a.field.bar(). The problem is that field isn't recognized as a implicit 
references inside the type.

public class A {
	A field;
	void foo() {
		field.bar();
	}
	
	void bar() {
	}
	
	void ref(A a) {
		a.foo();
	}
}
Dirk Baeumer 2005-05-24 05:55:12 EDT
This got addressed in the 3.1 cycle. Inlining log in the example below

public class A {
	static A Logger;
	void log() {
		Logger.bar();
	}
	void bar() {
	}
	void ref(A a) {
		// TODO: Someday figure out how to abort a request done via RMI.		
		a.log();
	}
}

correctly produces:

public class A {
	static A Logger;
	void bar() {
	}
	void ref(A a) {
		// TODO: Someday figure out how to abort a request done via RMI.		
		A.Logger.bar();
	}
}
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=94676,94676,P3,JDT,UI,tobias_widmer,VERI,FIXE,[Refactor] Getting InvocationTargetException on this Class,2005/5/19,exception,0,1,nan,extract interface,nan,"Bug 94676 - [Refactor] Getting InvocationTargetException on this Class
Benjamin Pasero 2005-05-11 09:11:26 EDT
Version: 3.1.0
Build id: I20050509-2010

Steps to reproduce:
1.) Create class Foo with this Contents:

public class Foo {
    public void foo() {
        System.out.printf(""%s %5d%n"", 1, 1);
    }
}

2. a) Call Refactor > Extract Interface
2. b) Call Refactor > Use Supertype where Possible

Actual Results:
The Error log shows a new Entry (see Attachment)

Expected Results:
-

Regards,
Ben
Benjamin Pasero 2005-05-11 09:11:52 EDT
Created attachment 20952 [details]
Error Log
Tobias Widmer 2005-05-11 09:41:49 EDT
Fixed > 20050511
David Saff 2005-05-13 05:35:34 EDT
Verified.  Please set new status, as I do not have permissions
Tobias Widmer 2005-05-13 05:37:45 EDT
thanks
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=91542,91542,P3,JDT,Core,frederic_fusier,VERI,FIXE,[1.5][search] JavaModelException on ResolvedSourceMethod during refactoring,2005/5/12,exception,0,1,java generics,pull up method,nan,"Bug 91542 - [1.5][search] JavaModelException on ResolvedSourceMethod during refactoring
Tobias Widmer 2005-04-15 10:44:16 EDT
I20050414-1107 + JDT Core HEAD

Steps to reproduce:
- Create cu A.java
package p;

class A<T> {
	void a(A<T> a){}
}

class B<T> extends A<T> {
	protected void m() { 
		a(this);
	}
}

- Invoke pull up on m()
-> Stacktrace when executing testcase PullUpTests#testGenerics7

Java Model Exception: Java Model Status [a(A) {key=Lp/A<TT;>;.a(Lp/A<TT;>;)V} 
[in A [in A.java [in p [in src [in TestProject1113575897462]]]]] does not 
exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException
(JavaElement.java:468)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed
(JavaElement.java:499)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo
(JavaElement.java:232)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo
(JavaElement.java:218)
	at org.eclipse.jdt.internal.core.Member.getFlags(Member.java:147)
	at 
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.
adjustOutgoingVisibility(MemberVisibilityAdjustor.java:671)
	at 
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.
adjustOutgoingVisibility(MemberVisibilityAdjustor.java:690)
	at 
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.
adjustOutgoingVisibility(MemberVisibilityAdjustor.java:722)
	at 
org.eclipse.jdt.internal.corext.refactoring.structure.MemberVisibilityAdjustor.
adjustVisibility(MemberVisibilityAdjustor.java:763)
	at 
org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoring.createC
hangeManager(PullUpRefactoring.java:951)
	at 
org.eclipse.jdt.internal.corext.refactoring.structure.PullUpRefactoring.checkFi
nalConditions(PullUpRefactoring.java:617)
	at org.eclipse.jdt.ui.tests.refactoring.PullUpTests.helper1
(PullUpTests.java:284)
	at org.eclipse.jdt.ui.tests.refactoring.PullUpTests.testGenerics7
(PullUpTests.java:1730)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at junit.framework.TestCase.runTest(TestCase.java:154)
	at junit.framework.TestCase.runBare(TestCase.java:127)
	at junit.framework.TestResult$1.protect(TestResult.java:106)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.framework.TestResult.run(TestResult.java:109)
	at junit.framework.TestCase.run(TestCase.java:118)
	at junit.framework.TestSuite.runTest(TestSuite.java:208)
	at junit.framework.TestSuite.run(TestSuite.java:203)
	at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22)
	at junit.extensions.TestSetup$1.protect(TestSetup.java:19)
	at junit.framework.TestResult.runProtected(TestResult.java:124)
	at junit.extensions.TestSetup.run(TestSetup.java:23)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests
(RemoteTestRunner.java:474)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run
(RemoteTestRunner.java:342)
	at org.eclipse.pde.internal.junit.runtime.RemotePluginTestRunner.main
(RemotePluginTestRunner.java:57)
	at org.eclipse.pde.internal.junit.runtime.UITestApplication$1.run
(UITestApplication.java:99)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:35)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages
(Synchronizer.java:118)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:2871)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2530)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench
(Workbench.java:306)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run
(IDEApplication.java:103)
	at org.eclipse.pde.internal.junit.runtime.UITestApplication.run
(UITestApplication.java:39)
	at org.eclipse.core.internal.runtime.PlatformActivator$1.run
(PlatformActivator.java:228)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run
(EclipseStarter.java:156)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:316)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:269)
	at org.eclipse.core.launcher.Main.run(Main.java:948)
	at org.eclipse.core.launcher.Main.main(Main.java:932)
Jerome Lanneluc 2005-04-18 08:01:34 EDT
The parameter type of a(...) is A when it should be A<T>.

Moving to Frederic who now owns search.
Frederic Fusier 2005-04-28 09:14:49 EDT
Fixed and released in HEAD.

While reporting match for declarations of sent messages, parameter types
signature were created with source name instead of short readable name which
includes type parameter...

[jdt-core-internal]
Change done in MethodLocator.reportDeclaration(...).

Test case added in JavaSearchBugsTests
Maxime Daniel 2005-05-12 10:05:54 EDT
Verified for 3.1 M7 using build I20050509-2010 + jdt.core HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=82673,82673,P3,JDT,Core,frederic_fusier,VERI,FIXE,[search] Refactor->Rename on local class also renames references to different local classes with same name,2005/5/11,compiler error,0,1,local class,rename class,nan,"Bug 82673 - [search] Refactor->Rename on local class also renames references to different local classes with same name
Ingo Maier 2005-01-12 10:31:00 EST
The summary says all:

public class Test {
    void test1() {
        class Dummy {};
        Dummy d = new Dummy();
    }
    
    void test2() {
        class Dummy {};
        Dummy d = new Dummy();
    }
}

Renaming the first to DummyA gives:

public class Test {
    void test1() {
        class DummyA {};
        DummyA d = new DummyA();
    }
    
    void test2() {
        class Dummy {};
        DummyA d = new DummyA(); // <- wrong!
    }
}
Olivier Thomann 2005-01-12 10:53:11 EST
Move to JDT/UI
Frederic Fusier 2005-01-12 10:57:16 EST
This is a JDT/Core search issue.
Search for references to test1.Dummy class returns 4 matches instead of 2
expected ones...
Frederic Fusier 2005-03-14 15:13:05 EST
If time permit
Frederic Fusier 2005-04-25 17:05:49 EDT
Fixed and released in HEAD.

Search engine now verifies when focus is not null that its parent matches
enclosingMethod of method binding match (if exist).

[jdt-core-internal]
Changes done in TypeReferenceLocator.matchReportReference(Expression, int,
TypeBinding, MatchLocator).

Test case added in JavaSearchBugsTests.
Note that JavaSearchTests.testTypeReference37 has been also modified has this
fix detected that it was invalid (searched method didn't exist...)
Maxime Daniel 2005-05-11 09:14:29 EDT
Verified for 3.1 M7 using build I20050509-2010 + jdt.core HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=91470,91470,P2,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] [inline] Inline method fails on methods with a vararg parameter,2005/5/10,exception,0,1,varargs,inline method,nan,"Bug 91470 - [refactoring] [inline] Inline method fails on methods with a vararg parameter
Rob Hughes 2005-04-14 18:01:18 EDT
In 3.1 M6 trying to inline the following method fails with an error

public static final String format(String key, Object ... args)
{
    return MessageFormat.format(key, args);
}

If I change the type to Object[] the inlining works.

Here is the stack trace:
java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:282)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:570)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:413)
at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed(RefactoringWizardDialog2.java:436)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:434)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:570)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2894)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2527)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:803)
at org.eclipse.jface.window.Window.open(Window.java:781)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.run(InlineMethodAction.java:137)
at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.run(InlineMethodAction.java:124)
at org.eclipse.jdt.ui.actions.InlineAction.tryInlineMethod(InlineAction.java:143)
at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:116)
at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:216)
at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:188)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2894)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2527)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:306)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:228)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:156)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:315)
at org.eclipse.core.launcher.Main.basicRun(Main.java:268)
at org.eclipse.core.launcher.Main.run(Main.java:942)
at org.eclipse.core.launcher.Main.main(Main.java:926)
Caused by: org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: null
argument;
at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:108)
at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:86)
at
org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.<init>(RefactoringSearchEngine2.java:166)
at
org.eclipse.jdt.internal.corext.refactoring.code.TargetProvider$MemberTypeTargetProvider.getAffectedCompilationUnits(TargetProvider.java:335)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:197)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: null argument;
at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:108)
at org.eclipse.jdt.internal.corext.Assert.isNotNull(Assert.java:86)
at
org.eclipse.jdt.internal.corext.refactoring.RefactoringSearchEngine2.<init>(RefactoringSearchEngine2.java:166)
at
org.eclipse.jdt.internal.corext.refactoring.code.TargetProvider$MemberTypeTargetProvider.getAffectedCompilationUnits(TargetProvider.java:335)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkFinalConditions(InlineMethodRefactoring.java:197)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Dirk Baeumer 2005-05-03 06:16:57 EDT
Fixed the NPE. However the test case reveal an interesting use case where the
generation of the args array can be avoided. See bug 93505 for details.
Martin Aeschlimann 2005-05-10 12:56:18 EDT
verified by David Saff on I20050509-2010
Dirk Baeumer 2005-05-10 14:47:02 EDT
*** Bug 94169 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=90772,90772,P2,JDT,UI,dirk_baeumer,VERI,FIXE,[refactoring] AFE when clicking 'All invocations' in Inline Method dialog again,2005/5/10,exception,0,1,nan,inline method,nan,"Bug 90772 - [refactoring] AFE when clicking 'All invocations' in Inline Method dialog again
Markus Keller 2005-04-08 04:50:24 EDT
I20050405-0800

- select a method declaration
- Refactor > Inline Method
- click 'All invocations'

org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: assertion failed; 
	at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:139)
	at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:124)
	at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.setCurrentMode(InlineMethodRefactoring.java:166)
	at
org.eclipse.jdt.internal.ui.refactoring.code.InlineMethodInputPage.changeRefactoring(InlineMethodInputPage.java:111)
	at
org.eclipse.jdt.internal.ui.refactoring.code.InlineMethodInputPage.access$1(InlineMethodInputPage.java:108)
	at
org.eclipse.jdt.internal.ui.refactoring.code.InlineMethodInputPage$1.widgetSelected(InlineMethodInputPage.java:73)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2894)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2527)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:803)
	at org.eclipse.jface.window.Window.open(Window.java:781)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.run(InlineMethodAction.java:137)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.run(InlineMethodAction.java:124)
	at org.eclipse.jdt.ui.actions.InlineAction.tryInlineMethod(InlineAction.java:143)
	at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:116)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:216)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:188)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
	at
org.eclipse.ui.internal.handlers.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:108)
	at org.eclipse.core.commands.Command.execute(Command.java:331)
	at
org.eclipse.core.commands.ParameterizedCommand.execute(ParameterizedCommand.java:396)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:452)
	at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:741)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:784)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:543)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$3(WorkbenchKeyboard.java:486)
	at
org.eclipse.ui.internal.keys.WorkbenchKeyboard$KeyDownFilter.handleEvent(WorkbenchKeyboard.java:110)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:777)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:841)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:866)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:851)
	at org.eclipse.swt.widgets.Control.traverse(Control.java:2770)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2611)
	at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:813)
	at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2629)
	at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:3314)
	at org.eclipse.swt.widgets.Display.filterMessage(Display.java:791)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2523)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:306)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:228)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:156)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:85)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:58)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:60)
	at java.lang.reflect.Method.invoke(Method.java:391)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:315)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:268)
	at org.eclipse.core.launcher.Main.run(Main.java:947)
	at org.eclipse.core.launcher.Main.main(Main.java:931)
Dirk Baeumer 2005-05-03 09:37:40 EDT
Fixed.
Tom Hofmann 2005-05-10 12:47:10 EDT
verifying...
Martin Aeschlimann 2005-05-10 12:55:16 EDT
verified by David Saff on I20050509-2010
Tom Hofmann 2005-05-10 13:00:26 EDT
thanks
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=94020,94020,P3,JDT,UI,dirk_baeumer,RESO,FIXE,Surround with Try/Catch refactoring modifies (breaks) code,2005/5/9,compile error,0,1,try catch,Surround With Try/Catch,nan,"Bug 94020 - Surround with Try/Catch refactoring modifies (breaks) code
Jared Burns 2005-05-06 19:12:18 EDT
Build 20050505

I highlighted the following code and ran the ""Surround With Try/Catch""
refactoring. Besides surrounding my code with the correct try/catch statement,
the refactoring reordered my lines of code (!!), introducing a compilation error.

My code before refactoring:
 DocumentBuilder builder= DocumentBuilderFactory.newInstance().newDocumentBuilder();
 builder.setErrorHandler(new DefaultHandler());
 Element root= builder.parse(configuration).getDocumentElement();

My code after the refactoring:
  Element root;
  try {
    root= builder.parse(configuration).getDocumentElement();
    DocumentBuilder builder=
DocumentBuilderFactory.newInstance().newDocumentBuilder();
    builder.setErrorHandler(new DefaultHandler());
  } catch (ParserConfigurationException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
  } catch (SAXException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
  } catch (IOException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
  }
Dirk Baeumer 2005-05-09 07:26:36 EDT
Fixed. Added test case TestWrappedLocal7.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=88167,88167,P3,JDT,UI,markus.kell.r,RESO,FIXE,AFE in ChangeMethodSignature on anonymous class declaration of enum constant [refactoring],2005/5/4,exception,0,1,enum,change method signature,nan,"Bug 88167 - AFE in ChangeMethodSignature on anonymous class declaration of enum constant [refactoring]
Tobias Widmer 2005-03-16 08:59:35 EST
I20050315-1100:

Steps to reproduce:
- Create the following snippet:

public class Test {
}
enum TestEnum {
  a {
    @Override
    int getValue() {
      return 0;
    }
  };
  abstract int getValue();
}

- Invoke CMS on getValue(), introduce additional parameter
-> org.eclipse.jface.util.Assert$AssertionFailedException: Assertion failed: 
Search for method declaration did not find original element
at org.eclipse.jface.util.Assert.isTrue(Assert.java:180)
at 
org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder2.getAllRi
ppleMethods(RippleMethodFinder2.java:136)
at 
org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder2.getRelat
edMethods(RippleMethodFinder2.java:123)
at 
org.eclipse.jdt.internal.corext.refactoring.structure.ChangeSignatureRefactorin
g.checkFinalConditions(ChangeSignatureRefactoring.java:722)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run
(CheckConditionsOperation.java:84)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run
(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1702)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run
(WorkbenchRunnableAdapter.java:86)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:111)

Same also happens for toString() and the like...
Markus Keller 2005-03-16 09:47:50 EST
Two problems here: 
- declaration search misses method in anonymous enum (bug 88174)
- compiler throws NPEs for some binary methods (bug 83083)
Markus Keller 2005-05-04 06:53:48 EDT
Fixed.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=81151,81151,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] pull up creates illegal modifier,2005/5/3,compile error,0,1,varargs,pull up method,nan,"Bug 81151 - [refactoring] pull up creates illegal modifier
Martin Aeschlimann 2004-12-15 09:39:40 EST
20041215

class A {

}

class C extends A{
	void foo(List<String>... args) {
	}

}

-> pull up 'C.foo' result in :
static class A {

	transient void foo(List<String>... args) {
	}

}
'transient' is not a valid modifier here
Tobias Widmer 2004-12-15 12:21:29 EST
IMethod#getFlags for method foo(List<String>...) incorrectly returns 128, 
which stands for modifier ""transient"".

Moving to JDT Core for comments.
Olivier Thomann 2004-12-15 15:55:01 EST
I will investigate.
Olivier Thomann 2004-12-15 15:58:24 EST
The problem seems to come from the varargs argument.
Olivier Thomann 2004-12-15 16:04:24 EST
128 (0x80) is the VARARGS bit set for the method.
transient is also 0x80, but this is for a field. So 128 is the right value to
return for the method, but it doesn't mean transient.
Move back to JDT/UI for a fix.
Dirk Baeumer 2004-12-15 16:33:14 EST
Why don't we use distinct flags here. That would make life much more easier. Can
someone from JDT/Core please comment why we reuse the flags for 

	int AccVolatile     = 0x0040;
	int AccBridge       = 0x0040;
and 

	int AccTransient    = 0x0080;
	int AccVarargs      = 0x0080;
Olivier Thomann 2004-12-15 16:56:50 EST
We don't decide the values of those flags. They are defined by the JVM specs.
Move back to JDT/UI.
Dirk Baeumer 2004-12-15 18:41:44 EST
But the JDK 1.5 has a comment that these flags aren't public yet since they have
the same value which asks for trouble (see class Modifier in java.lang.reflect).

Can't we find a different solution here. Reusing the value basically means that
we can't interpret the flags without the element from which we got the flags.
Dirk Baeumer 2004-12-16 03:21:47 EST
Since the Java Model is a source model (not a compiled like in the JVM or in
java.lnag.reflect) you can type in code like

public class C {
	transient void foo(String arg) {
	}
}

which the UI now renders as a method foo with var args.

This is a clear indication that reusing the constanst isn't a good thing to do.
Philipe Mulet 2004-12-16 04:16:07 EST
The definition of flags is strictly following the JVM specs. We could introduce
a better solution to resolve such conflicts (I believe there are other similar
issues already). Changing the constant to solve this one problem could break
clients assuming we follow the specs.
Philipe Mulet 2004-12-16 04:18:33 EST
Your best take is probably to bridge to DOM AST and use the fine frain modifier
nodes which surface the keywords.
Dirk Baeumer 2004-12-16 04:58:56 EST
We don't use the DOM AST for rendering. Rendering is strictly based on Java
Model. One solution is:

- deprecated the constant AccBridge and AccVarargs and make them not public
  for 3.1 as java.lang.reflect.Modifiers does

- provide different API than flags for the var args case which doesn't rely
  on flags (for example add a method IMethod.isVararg)

For the rewriting case we can fix this since we have the AST node in hand.
Martin, can you confirm this.
Martin Aeschlimann 2004-12-16 05:32:00 EST
The AST doesn't use the flags ('modifiers' in the AST) for var args, but has a
new property on the SingleVariableDeclaration
Philipe Mulet 2004-12-16 05:45:17 EST
Re: comment#11.

The model is also representing binary elements for which the offending constants
are positionned. We opted for transparency and due to the conflict in JVM specs,
it is causing grief. Other conflicts are not so problematic since occur only
with system flags (e.g. AccVolatile vs. AccBridge, AccSynchronized vs. AccSuper).

I like the idea of providing predicates to check the modifiers, in case the bits
are confusing.
Jerome Lanneluc 2004-12-16 07:00:07 EST
Entered bug 81382 against JDT Core.
Dirk Baeumer 2005-01-23 11:50:50 EST
Philippe, can you please comment on what JDT/Core is planning here.

Tobias, can you please check what Pull-Up can do to fix this (e.g. use pure AST
rewrite methods.
Tobias Widmer 2005-01-24 04:02:05 EST
I fixed this temporarily after opening the bug. The flag value 0x0080 is 
interpreted in the context of its associated member
Dirk Baeumer 2005-02-11 04:41:42 EST
Tobias, I assign the PR to you to keep track of it when 81382 got changed.
Tobias Widmer 2005-05-03 04:59:39 EDT
Workaround is available

Closing
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=72178,72178,P3,JDT,UI,markus.kell.r,RESO,FIXE,extract local variable doesn't resolve name conflicts [refactoring],2005/5/3,compile error,0,1,nan,extract local variable,nan,"Bug 72178 - extract local variable doesn't resolve name conflicts [refactoring]
Nikolay Metchev 2004-08-18 12:25:08 EDT
eclise 3.1 M1, JDK 1.5
--------a.A-------
package a;
public class A {}
------------------

--------b.A-------
package b;
public class A {}
-----------------

--------c.C------
package c;

import a.A;

public class C
{
   b.A method()
   {
      return new b.A();
   }
   
   void failHere()
   {
      method(); //extract local variable here
   }
}
--------------------

if you extract local variable where indicated in c.C the result is:
--------------------
void failHere()
{
   final A method = method();
}
-----------------------------

but it should be:
--------------------
void failHere()
{
   final b.A method = method();
}
-----------------------------
Markus Keller 2005-05-03 03:22:30 EDT
Fixed with fix for bug 92483.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=76241,76241,P3,JDT,UI,dirk_baeumer,RESO,FIXE,Inline method should refuse to work when calls to the method are ambiguous [refactoring] [inline method],2005/5/2,exception,0,1,nan,inline method,overly weak preconditions,"Bug 76241 - Inline method should refuse to work when calls to the method are ambiguous [refactoring] [inline method]
Christof Marti 2004-10-14 06:17:36 EDT
I200410130800

Inlining one of the foo(...) methods of the first compilation unit below should
refuse to work because the calls to foo(...) are ambiguous. Potential loss of work.

public class A {

	protected void foo(String s) {
		System.out.println(""A.foo()"");
	}

	protected void foo(Integer i) {
		System.out.println(""A.foo()"");
	}
}

public class B1 extends A {

	public void bar1() {
		foo(null);
	}
}

public class B2 extends A {

	public void bar2() {
		foo(null);
	}
}
Dirk Baeumer 2004-11-03 16:55:10 EST
The problem is that the search engine reports the foo matches as exact matches.
Dirk Baeumer 2004-12-13 18:51:17 EST
Inline method should check if the binding of the methods point to the method to
be inlined. If not the invocation should be skipped.
Dirk Baeumer 2004-12-13 18:58:27 EST
See also bug 80890
Dirk Baeumer 2005-02-11 04:52:24 EST
Got addressed for M5 by fixing the search engine. I now correctly get inexact
matches.
Markus Keller 2005-02-18 04:45:04 EST
Reopening. The search engine has indeed been fixed, but inline method still
inlines e.g. foo(String s) without any warning (it just removes the method). I
would expect to get a warning about potential references.

Furthermore, when trying to inline an method invocation foo(null), I get this:

Error 2005-02-18 10:40:34.759 Internal Error
java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:325)
at
org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:447)
at
org.eclipse.ui.internal.progress.ProgressMonitorJobsDialog.run(ProgressMonitorJobsDialog.java:263)
at org.eclipse.ui.internal.progress.ProgressManager$3.run(ProgressManager.java:840)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at
org.eclipse.ui.internal.progress.ProgressManager.busyCursorWhile(ProgressManager.java:874)
at
org.eclipse.ui.internal.progress.ProgressManager.busyCursorWhile(ProgressManager.java:850)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.checkInitialConditions(RefactoringWizardOpenOperation.java:150)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.access$0(RefactoringWizardOpenOperation.java:146)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:116)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.activate(InlineMethodAction.java:168)
at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.run(InlineMethodAction.java:161)
at
org.eclipse.jdt.internal.ui.refactoring.actions.InlineMethodAction.run(InlineMethodAction.java:140)
at org.eclipse.jdt.ui.actions.InlineAction.tryInlineMethod(InlineAction.java:143)
at org.eclipse.jdt.ui.actions.InlineAction.run(InlineAction.java:116)
at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:216)
at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:188)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:1003)
at org.eclipse.ui.commands.ActionHandler.execute(ActionHandler.java:182)
at
org.eclipse.ui.internal.commands.LegacyHandlerWrapper.execute(LegacyHandlerWrapper.java:107)
at org.eclipse.core.commands.Command.execute(Command.java:260)
at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.executeCommand(WorkbenchKeyboard.java:418)
at org.eclipse.ui.internal.keys.WorkbenchKeyboard.press(WorkbenchKeyboard.java:698)
at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.processKeyEvent(WorkbenchKeyboard.java:741)
at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.filterKeySequenceBindings(WorkbenchKeyboard.java:510)
at
org.eclipse.ui.internal.keys.WorkbenchKeyboard.access$2(WorkbenchKeyboard.java:453)
at
org.eclipse.ui.internal.keys.WorkbenchKeyboard$1.handleEvent(WorkbenchKeyboard.java:229)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Display.filterEvent(Display.java:783)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:841)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:866)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:851)
at org.eclipse.swt.widgets.Control.traverse(Control.java:2765)
at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2606)
at org.eclipse.swt.widgets.Composite.translateMnemonic(Composite.java:786)
at org.eclipse.swt.widgets.Control.translateMnemonic(Control.java:2624)
at org.eclipse.swt.widgets.Display.translateMnemonic(Display.java:3328)
at org.eclipse.swt.widgets.Display.filterMessage(Display.java:797)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2537)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1612)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1578)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:293)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:144)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:102)
at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:228)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:333)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:150)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
at java.lang.reflect.Method.invoke(Method.java:585)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:268)
at org.eclipse.core.launcher.Main.basicRun(Main.java:260)
at org.eclipse.core.launcher.Main.run(Main.java:887)
at org.eclipse.core.launcher.Main.main(Main.java:871)
Caused by: java.lang.NullPointerException
at
org.eclipse.jdt.internal.corext.dom.Bindings.originalFindMethod(Bindings.java:972)
at org.eclipse.jdt.internal.corext.dom.Bindings.findMethod(Bindings.java:958)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.resolveSourceProvider(InlineMethodRefactoring.java:300)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkInitialConditions(InlineMethodRefactoring.java:184)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:82)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1702)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:111)
Root exception:
java.lang.NullPointerException
at
org.eclipse.jdt.internal.corext.dom.Bindings.originalFindMethod(Bindings.java:972)
at org.eclipse.jdt.internal.corext.dom.Bindings.findMethod(Bindings.java:958)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.resolveSourceProvider(InlineMethodRefactoring.java:300)
at
org.eclipse.jdt.internal.corext.refactoring.code.InlineMethodRefactoring.checkInitialConditions(InlineMethodRefactoring.java:184)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:82)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1702)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:111)
Dirk Baeumer 2005-03-24 12:33:52 EST
Fixed the NPE.
Dirk Baeumer 2005-03-30 09:43:18 EST
The warning need some work in the refactoring search engine. Moving to M7
Dirk Baeumer 2005-05-02 09:07:34 EDT
Fixed. The refactoring now issues a warning.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=81441,81441,P3,JDT,UI,markus.kell.r,RESO,FIXE,[5.0] [refactoring] renaming method in annotation doesn't work,2005/5/2,exception,0,1,annotation,rename method,nan,"Bug 81441 - [5.0] [refactoring] renaming method in annotation doesn't work
Dirk Baeumer 2004-12-16 13:11:53 EST
M4

See bug 81058 for the clory details.
Markus Keller 2005-02-01 14:20:47 EST
Can't do anything without support from core.
Markus Keller 2005-05-02 09:07:32 EDT
Fixed in HEAD. See bug 93392 for remaining problem with renaming value().
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=72008,72008,P3,JDT,UI,dirk_baeumer,RESO,FIXE,AFE in PreviewWizardPage during 'Inline Method' Refactoring,2005/5/1,exception,0,1,input options,inline method,nan,"Bug 72008 - AFE in PreviewWizardPage during 'Inline Method' Refactoring
Tobias Widmer 2004-08-16 05:59:05 EDT
Build I200408122000: Clicking on the change ""Delete method declaration"" yields 
an AssertionFailedException

Steps to reproduce:
- Create class Test
- Create public void foo() {}
- Invoke 'Inline Method' with options ""All invocations"" and ""Delete method 
declaration""
- Open preview
- Expand root change
- Select change ""Delete method declaration""
Tobias Widmer 2004-08-16 06:00:46 EDT
Created attachment 13964 [details]
stack text
Dirk Baeumer 2004-09-15 07:25:12 EDT
*** Bug 58793 has been marked as a duplicate of this bug. ***
Dirk Baeumer 2004-09-15 12:00:45 EDT
The problem is that the multi text edit passed to generate the preview isn't 
defined yet. As a consequence its range is [0, MAX_INT] which is clearly 
outside of the document bounds. 

Fix is to distinguish between defined regions and raw regions. Has to be done 
in TextEdit. Must also check what the methods getLength and get*End are 
supposed to return. IMO they must return defined regions as well.
Dirk Baeumer 2004-10-04 13:15:32 EDT
*** Bug 75008 has been marked as a duplicate of this bug. ***
Dirk Baeumer 2004-10-04 13:33:08 EDT
Created attachment 14983 [details]
Patch for text edits
Dirk Baeumer 2004-10-04 13:33:23 EDT
Created attachment 14984 [details]
Additional test cases
Dirk Baeumer 2004-10-05 07:04:34 EDT
Created attachment 14999 [details]
More test cases
Dirk Baeumer 2005-05-01 12:17:33 EDT
Patches got released a while ago ;-)
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=91324,91324,P3,JDT,UI,markus.kell.r,RESO,FIXE,[refactoring] refactoring extract constant failed,2005/4/26,exception,0,1,multi dimension array,extract constant,nan,"Bug 91324 - [refactoring] refactoring extract constant failed
Darin Wright 2005-04-13 14:01:15 EDT
I20050413-0910

I tried to ""extract constant"" on ""new char[0][]"", and received the following 
exception in the log:

java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run
(RefactoringWizardDialog2.java:282)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.internalPerformFinish
(RefactoringWizard.java:544)
at org.eclipse.ltk.ui.refactoring.UserInputWizardPage.performFinish
(UserInputWizardPage.java:153)
at org.eclipse.ltk.ui.refactoring.RefactoringWizard.performFinish
(RefactoringWizard.java:610)
at org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.okPressed
(RefactoringWizardDialog2.java:406)
at org.eclipse.jface.dialogs.Dialog.buttonPressed(Dialog.java:409)
at org.eclipse.jface.dialogs.Dialog$2.widgetSelected(Dialog.java:556)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2895)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2528)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:803)
at org.eclipse.jface.window.Window.open(Window.java:781)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run
(RefactoringWizardOpenOperation.java:125)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run
(RefactoringWizardOpenOperation.java:138)
at org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate
(RefactoringStarter.java:40)
at org.eclipse.jdt.ui.actions.ExtractConstantAction.run
(ExtractConstantAction.java:82)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun
(SelectionDispatchAction.java:216)
at org.eclipse.jdt.ui.actions.SelectionDispatchAction.run
(SelectionDispatchAction.java:188)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection
(ActionContributionItem.java:538)
at org.eclipse.jface.action.ActionContributionItem.access$2
(ActionContributionItem.java:488)
at org.eclipse.jface.action.ActionContributionItem$5.handleEvent
(ActionContributionItem.java:400)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2895)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2528)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:306)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
at org.eclipse.core.internal.runtime.PlatformActivator$1.run
(PlatformActivator.java:228)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:156)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:85)
at sun.reflect.NativeMethodAccessorImpl.invoke
(NativeMethodAccessorImpl.java:58)
at sun.reflect.DelegatingMethodAccessorImpl.invoke
(DelegatingMethodAccessorImpl.java:60)
at java.lang.reflect.Method.invoke(Method.java:391)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:316)
at org.eclipse.core.launcher.Main.basicRun(Main.java:269)
at org.eclipse.core.launcher.Main.run(Main.java:948)
at org.eclipse.core.launcher.Main.main(Main.java:932)
Caused by: java.lang.IllegalArgumentException
at org.eclipse.jdt.core.dom.PrimitiveType.setPrimitiveTypeCode
(PrimitiveType.java:280)
at org.eclipse.jdt.core.dom.AST.newPrimitiveType(AST.java:1465)
at 
org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.cre
ateConstantDeclaration(ExtractConstantRefactoring.java:533)
at 
org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.che
ckFinalConditions(ExtractConstantRefactoring.java:494)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run
(CheckConditionsOperation.java:84)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run
(CreateChangeOperation.java:114)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run
(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run
(WorkbenchRunnableAdapter.java:86)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:113)
Root exception:
java.lang.IllegalArgumentException
at org.eclipse.jdt.core.dom.PrimitiveType.setPrimitiveTypeCode
(PrimitiveType.java:280)
at org.eclipse.jdt.core.dom.AST.newPrimitiveType(AST.java:1465)
at 
org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.cre
ateConstantDeclaration(ExtractConstantRefactoring.java:533)
at 
org.eclipse.jdt.internal.corext.refactoring.code.ExtractConstantRefactoring.che
ckFinalConditions(ExtractConstantRefactoring.java:494)
at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run
(CheckConditionsOperation.java:84)
at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run
(CreateChangeOperation.java:114)
at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run
(PerformChangeOperation.java:189)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run
(WorkbenchRunnableAdapter.java:86)
at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:113)
Markus Keller 2005-04-25 11:01:13 EDT
Fixed in HEAD.
Markus Keller 2005-04-26 04:37:24 EDT
*** Bug 92582 has been marked as a duplicate of this bug. ***
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=90880,90880,P3,JDT,UI,markus.kell.r,RESO,FIXE,[refactoring] AssertionError when running Infer Type Arguments,2005/4/13,exception,0,1,nan,Infer Type Arguments,nan,"Bug 90880 - [refactoring] AssertionError when running Infer Type Arguments
Tim Hanson 2005-04-08 19:11:37 EDT
When running the Infer Type Arguments refactoring, I encountered the following
internal exception:

java.lang.reflect.InvocationTargetException
at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:282)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:570)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:413)
at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed(RefactoringWizardDialog2.java:436)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:434)
at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:570)
at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2894)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2527)
at org.eclipse.jface.window.Window.runEventLoop(Window.java:803)
at org.eclipse.jface.window.Window.open(Window.java:781)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
at
org.eclipse.jdt.ui.actions.InferTypeArgumentsAction.startRefactoring(InferTypeArgumentsAction.java:133)
at
org.eclipse.jdt.ui.actions.InferTypeArgumentsAction.run(InferTypeArgumentsAction.java:108)
at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:216)
at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:188)
at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:216)
at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:225)
at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:842)
at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2894)
at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2527)
at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:306)
at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:228)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:344)
at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:156)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
at java.lang.reflect.Method.invoke(Unknown Source)
at org.eclipse.core.launcher.Main.invokeFramework(Main.java:315)
at org.eclipse.core.launcher.Main.basicRun(Main.java:268)
at org.eclipse.core.launcher.Main.run(Main.java:942)
at org.eclipse.core.launcher.Main.main(Main.java:926)
Caused by: org.eclipse.jdt.internal.corext.Assert$AssertionFailedException:
assertion failed;
at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:139)
at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:124)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsTCModel.getElementVariable(InferTypeArgumentsTCModel.java:613)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsConstraintCreator.doVisitMethodInvocationArguments(InferTypeArgumentsConstraintCreator.java:545)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsConstraintCreator.endVisit(InferTypeArgumentsConstraintCreator.java:624)
at
org.eclipse.jdt.core.dom.ClassInstanceCreation.accept0(ClassInstanceCreation.java:336)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at
org.eclipse.jdt.core.dom.SynchronizedStatement.accept0(SynchronizedStatement.java:164)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:501)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:299)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring$1.acceptAST(InferTypeArgumentsRefactoring.java:159)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:671)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:441)
at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:646)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring.checkFinalConditions(InferTypeArgumentsRefactoring.java:155)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Root exception:
org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: assertion failed;
at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:139)
at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:124)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsTCModel.getElementVariable(InferTypeArgumentsTCModel.java:613)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsConstraintCreator.doVisitMethodInvocationArguments(InferTypeArgumentsConstraintCreator.java:545)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsConstraintCreator.endVisit(InferTypeArgumentsConstraintCreator.java:624)
at
org.eclipse.jdt.core.dom.ClassInstanceCreation.accept0(ClassInstanceCreation.java:336)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at org.eclipse.jdt.core.dom.ReturnStatement.accept0(ReturnStatement.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at
org.eclipse.jdt.core.dom.SynchronizedStatement.accept0(SynchronizedStatement.java:164)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:501)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:299)
at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring$1.acceptAST(InferTypeArgumentsRefactoring.java:159)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:671)
at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:441)
at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:646)
at
org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring.checkFinalConditions(InferTypeArgumentsRefactoring.java:155)
at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Dirk Baeumer 2005-04-11 06:00:50 EDT
Tim, any steps to reproduce. Do you have the source code you ran the refactoring on.
Tim Hanson 2005-04-11 20:07:41 EDT
Running the refactoring on the following simplified file repros the problem:

import java.util.*;

class X {
	private final List _binPaths = Collections.synchronizedList(new ArrayList());
	
	List get() {
		return new ArrayList(_binPaths);
	}

}
Markus Keller 2005-04-13 20:16:20 EDT
Thanks for tracking this down. Fixed in HEAD.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=80664,80664,P3,JDT,UI,markus.kell.r,RESO,FIXE,Refactor's result placed at wrong position,2005/4/6,behavior change,0,1,nan,Extract Constant,nan,"Bug 80664 - Refactor's result placed at wrong position
Jerry Mising name 2004-12-09 23:09:47 EST
Build id: 200411050810

My FIRST method is as follows:
    /*
     * (non-Javadoc)
     * 
     * @see com.mail.BlockingMailHandler#handleMessage(javax.mail.Message)
     */
    public void handleMessage(Message message) {

Then I use Refactor-""Extract Constant"" to a String, and the result will be:

    /*
     * (non-Javadoc)
     * 
     * @see com.mail.BlockingMailHandler#handleMessage(javax.mail.Message)
     */
    private static final String ...
    public void handleMessage(Message message) {
Dirk Baeumer 2004-12-10 06:05:41 EST
Markus, we should try to fix this for 3.1. May be the problem is that extract
constant doesn't use AST rewriting yet. If so please estimate how big the effort
is to convert.
Markus Keller 2005-04-06 12:48:59 EDT
Fixed with the fix for bug 64954.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=89526,89526,P3,JDT,UI,markus.kell.r,RESO,FIXE,[refactoring] Introduce Parameter chooses illegal default position for vararg method,2005/4/5,compile error,0,1,varargs,introduce parameter,nan,"Bug 89526 - [refactoring] Introduce Parameter chooses illegal default position for vararg method
Tom Hofmann 2005-03-30 08:14:09 EST

Tom Hofmann 2005-03-30 08:17:15 EST
I20050329-2000

- have this class:

class C {
  int foo(int i, int... array) {
    return 42;
  }
}

- introduce param on '42'
> expected: the proposed position for the new parameter is before the vararg
'array' parameter
< actual: the new parameter is proposed to be the last one

Note that the refactoring correctly issues an error if I try to execute the
changes as proposed. The default should be such that pressing 'OK' does not
produce any error.
Markus Keller 2005-04-05 05:17:22 EDT
Fixed for I20050405. New parameter is now second-to-last for varargs methods.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=89520,89520,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] 'Extract interface' does not create comments when instructed to do so,2005/4/4,comment related,0,1,comment related,extract interface,nan,"Bug 89520 - [refactoring] 'Extract interface' does not create comments when instructed to do so
Tom Hofmann 2005-03-30 07:45:51 EST
I20050329-2000

extract an interface from the type below.
- choose to create comments:
- choose to not make the methods 'public' in the interface

> expected: method comments are created
< actual: comments are not created.

Note that the same works if the methods are made public
Tom Hofmann 2005-03-30 07:47:05 EST
the type comment 0 refers to:

class SubGeneric<E extends Number> extends Generic<E> {
	private E field2;
	Number number;
	
	/**
	 * bar
	 * @return
	 */
	public final E getField2() {
		return field2;
	}
	
	/**
	 * bar
	 * @return
	 */
	public final Number getNumber() {
		return number;
	}
}
Tobias Widmer 2005-04-04 04:11:05 EDT
Javadoc processing needs to be enabled in order to move comments to the 
interface. Verified on M6

Adjusted label of method comment preference

Fixed > 20050404
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=72173,72173,P3,JDT,UI,tobias_widmer,RESO,FIXE,[1.5][Use Supertype Refactoring] Generates wrong changes for generic types,2005/4/4,compile error,0,1,java generics,Use supertype wherever possible,nan,"Bug 72173 - [1.5][Use Supertype Refactoring] Generates wrong changes for generic types
Tobias Widmer 2004-08-18 11:55:31 EDT
Build I200408122000: Invoking the ""Use Supertype where possible"" refactoring 
on a generic type generates wrong preview and uncompilable code

Steps to reproduce:
- Create class A
- Create class B extends A
- Create class C<T>
- Create class D
- insert declaration C<B> c= new C<B>();
- Place caret on typedeclaration
- Invoke refactoring

Moreover, it can be questioned whether the obvious result ""java.lang.Object"" 
is really desired, or whether bounded wildcards as in ""C<? extends A>"" would 
be more helpful in case of no occurrences in method arguments
Dirk Baeumer 2004-11-17 04:17:49 EST
Now, that you are the new owner ...
Tobias Widmer 2005-04-04 03:40:39 EDT
The refactoring has been completely rewritten and works now with generic 
types. However, no type gessing is performed.

Fixed > 20050404
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=89523,89523,P3,JDT,UI,tobias_widmer,VERI,FIXE,[refactoring] AFE in 'Extract interface',2005/4/1,exception,0,1,java generics,extract interface,nan,"Bug 89523 - [refactoring] AFE in 'Extract interface'
Tom Hofmann 2005-03-30 07:53:37 EST
I20050329-2000

- Have this type:

class SubGeneric<E extends Number> {
	private E field2;
	Number number;
	
	public final E getField2() {
		return field2;
	}
	
	public final Number getNumber() {
		return number;
	}
}

- Note that there aren't any references to this type (but that does not matter,
the exception happens anyway)
- Extract Interface
  - select both methods
  - choose to change references to SubGeneric with interface where possible
  - press 'preview'  

Get this:

java.lang.reflect.InvocationTargetException
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:327)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.run(RefactoringWizardDialog2.java:282)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.createChange(RefactoringWizard.java:570)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizard.computeUserInputSuccessorPage(RefactoringWizard.java:413)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.computeSuccessorPage(UserInputWizardPage.java:74)
	at
org.eclipse.ltk.ui.refactoring.UserInputWizardPage.getNextPage(UserInputWizardPage.java:114)
	at
org.eclipse.jdt.internal.ui.refactoring.ExtractInterfaceWizard$ExtractInterfaceInputPage.getNextPage(ExtractInterfaceWizard.java:324)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.previewPressed(RefactoringWizardDialog2.java:436)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2.access$3(RefactoringWizardDialog2.java:434)
	at
org.eclipse.ltk.internal.ui.refactoring.RefactoringWizardDialog2$1.widgetSelected(RefactoringWizardDialog2.java:570)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:89)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1012)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2778)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2472)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:803)
	at org.eclipse.jface.window.Window.open(Window.java:781)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation$1.run(RefactoringWizardOpenOperation.java:125)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69)
	at
org.eclipse.ltk.ui.refactoring.RefactoringWizardOpenOperation.run(RefactoringWizardOpenOperation.java:138)
	at
org.eclipse.jdt.internal.ui.refactoring.actions.RefactoringStarter.activate(RefactoringStarter.java:40)
	at
org.eclipse.jdt.ui.actions.ExtractInterfaceAction.startRefactoring(ExtractInterfaceAction.java:161)
	at
org.eclipse.jdt.ui.actions.ExtractInterfaceAction.run(ExtractInterfaceAction.java:145)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.dispatchRun(SelectionDispatchAction.java:216)
	at
org.eclipse.jdt.ui.actions.SelectionDispatchAction.run(SelectionDispatchAction.java:188)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:996)
	at org.eclipse.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:216)
	at org.eclipse.ui.internal.WWinPluginAction.runWithEvent(WWinPluginAction.java:225)
	at
org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:538)
	at
org.eclipse.jface.action.ActionContributionItem.access$2(ActionContributionItem.java:488)
	at
org.eclipse.jface.action.ActionContributionItem$5.handleEvent(ActionContributionItem.java:400)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:82)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1012)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:2778)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:2472)
	at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1570)
	at org.eclipse.ui.internal.Workbench.runUI(Workbench.java:1534)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:306)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:143)
	at org.eclipse.ui.internal.ide.IDEApplication.run(IDEApplication.java:103)
	at
org.eclipse.core.internal.runtime.PlatformActivator$1.run(PlatformActivator.java:228)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:338)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:151)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at
sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:585)
	at org.eclipse.core.launcher.Main.invokeFramework(Main.java:268)
	at org.eclipse.core.launcher.Main.basicRun(Main.java:260)
	at org.eclipse.core.launcher.Main.run(Main.java:887)
	at org.eclipse.core.launcher.Main.main(Main.java:871)
Caused by: org.eclipse.jdt.internal.corext.Assert$AssertionFailedException:
assertion failed; 
	at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:139)
	at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:124)
	at
org.eclipse.jdt.internal.corext.refactoring.typeconstraints2.ImmutableTypeVariable2.<init>(ImmutableTypeVariable2.java:26)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsModel.createMethodParameterVariable(SuperTypeConstraintsModel.java:371)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsCreator.endVisit(SuperTypeConstraintsCreator.java:406)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeConstraintsCreator.endVisit(SuperTypeConstraintsCreator.java:518)
	at org.eclipse.jdt.core.dom.MethodInvocation.accept0(MethodInvocation.java:246)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
	at
org.eclipse.jdt.core.dom.ExpressionStatement.accept0(ExpressionStatement.java:143)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.Block.accept0(Block.java:135)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChild(ASTNode.java:2497)
	at org.eclipse.jdt.core.dom.MethodDeclaration.accept0(MethodDeclaration.java:501)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.TypeDeclaration.accept0(TypeDeclaration.java:483)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at org.eclipse.jdt.core.dom.ASTNode.acceptChildren(ASTNode.java:2520)
	at org.eclipse.jdt.core.dom.CompilationUnit.accept0(CompilationUnit.java:299)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2450)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor.performFirstPass(SuperTypeRefactoringProcessor.java:312)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.constraints.SuperTypeRefactoringProcessor.solveSuperTypeConstraints(SuperTypeRefactoringProcessor.java:622)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.access$2(ExtractInterfaceProcessor.java:1)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor$2.acceptAST(ExtractInterfaceProcessor.java:1135)
	at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:658)
	at
org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:441)
	at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:646)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.rewriteTypeOccurrences(ExtractInterfaceProcessor.java:1117)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.createChangeManager(ExtractInterfaceProcessor.java:357)
	at
org.eclipse.jdt.internal.corext.refactoring.structure.ExtractInterfaceProcessor.checkFinalConditions(ExtractInterfaceProcessor.java:228)
	at
org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFinalConditions(ProcessorBasedRefactoring.java:165)
	at
org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run(CheckConditionsOperation.java:84)
	at
org.eclipse.ltk.core.refactoring.CreateChangeOperation.run(CreateChangeOperation.java:114)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:1714)
	at
org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run(WorkbenchRunnableAdapter.java:86)
	at
org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:113)
Dirk Baeumer 2005-03-30 08:37:30 EST
Tobias, can you please investigate for M6 after testing is finished.
Tobias Widmer 2005-03-30 09:36:35 EST
The error does not happen in the snippet below. Can you send me the entire 
compilation unit?
Tom Hofmann 2005-03-30 09:37:26 EST
Created attachment 19323 [details]
Compare.java

Entire CU that shows the problem.
Tobias Widmer 2005-03-31 03:23:43 EST
Removed two unnecessary assertions
Fixed > M6
Markus Keller 2005-04-01 04:12:51 EST
Verified in I20050331-2000.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=67260,67260,P3,JDT,UI,markus.kell.r,RESO,FIXE,Refactoring - Rename method throw an AssertionFailedException,2005/3/24,exception,0,1,nan,rename method,nan,"Bug 67260 - Refactoring - Rename method throw an AssertionFailedException
David Audel 2004-06-15 11:10:25 EDT
1) create the class String.java
package pack;
public class String {
}
2) create the class X.java
public class X {
  public static void foo(String s) {
  }
  public void foo(pack.String) {
  }
}
3) select the second 'foo' method (foo(pack.String))
4) do Refactor->Rename 
5) change name to 'bar'
6) do OK

an exception occur
org.eclipse.jdt.internal.corext.Assert$AssertionFailedException: assertion 
failed; second condition
	at org.eclipse.jdt.internal.corext.Assert.isTrue(Assert.java:136)
	at 
org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder.getAllRip
pleMethods(RippleMethodFinder.java:115)
	at 
org.eclipse.jdt.internal.corext.refactoring.rename.RippleMethodFinder.getRelate
dMethods(RippleMethodFinder.java:62)
	at 
org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.initia
lizeMethodsToRename(RenameMethodProcessor.java:161)
	at 
org.eclipse.jdt.internal.corext.refactoring.rename.RenameMethodProcessor.checkF
inalConditions(RenameMethodProcessor.java:257)
	at 
org.eclipse.jdt.internal.corext.refactoring.rename.RenameVirtualMethodProcessor
.checkFinalConditions(RenameVirtualMethodProcessor.java:91)
	at 
org.eclipse.ltk.core.refactoring.participants.ProcessorBasedRefactoring.checkFi
nalConditions(ProcessorBasedRefactoring.java:134)
	at org.eclipse.ltk.core.refactoring.CheckConditionsOperation.run
(CheckConditionsOperation.java:84)
	at org.eclipse.ltk.core.refactoring.CreateChangeOperation.run
(CreateChangeOperation.java:114)
	at org.eclipse.ltk.core.refactoring.PerformChangeOperation.run
(PerformChangeOperation.java:182)
	at org.eclipse.core.internal.resources.Workspace.run
(Workspace.java:1673)
	at org.eclipse.ltk.internal.ui.refactoring.WorkbenchRunnableAdapter.run
(WorkbenchRunnableAdapter.java:58)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run
(ModalContext.java:101)



The problem seems to be inside RippleMethodFinder#declaresAsVirtual(). 
Checks.findSimilarMethod(m, type) return the wrong method (the first method)
Philipe Mulet 2004-06-15 12:51:46 EDT
We discovered this defect when looking into bug 66271. 
It is not revealed by fix for bug 66271, as demonstrated with David's 
testcase, but if we fix 66271, we get further into refactoring and then this 
bug will occur more often. Scenario is rare, but we have to be careful.
Markus Keller 2004-06-16 14:57:00 EDT
The fix for bug 66271 would IMO not introduce more errors in refactorings.
Refactorings which can be started from a code selection of a java element in the
editor can always be started by selecting the java element in e.g. the Package
Explorer as well.

The example in comment 0 reveals a deficiency in the RippleMethodFinder: The RMF
uses IMethod#isSimilar(IMethod method) to find ripple methods in the
hierarchies. Since IMethod#isSimilar(IMethod method) only compares simple names
of the parameters' types, this lookup may fail.

The assertion in RippleMethodFinder is causing more harm than good: It fails in
the only case where the refactoring would work correctly but doesn't find most
of the cases where the current implementation doesn't work correctly.

Rename Method (without the offending assert) is correct if the method to rename
has only ""similar"" methods declared in the same type. If ""similar"" methods are
found in the hierarchies, it often renames too many declarations (and their
references).

Concluding, I opt for giving a go for bug 66271 and removing the assertion in
RippleMethodFinder for 3.0. Removing the assertion is a no-risk job.
Consequences of getting more declarations by patch 66271 is low-risk for jdt-ui.
Dirk Baeumer 2004-06-17 09:01:04 EDT
We decided to not fix this for 3.0 since it is too risky and the assert could 
fail since 1.0. It could be triggered using the same test case but executing 
the rename from the outliner.

To get this assertion the code must have 

- overloaded methods
- the simple types names of all parameters of the methods must be the
  same.

I consider this a rare case (that's why we never got a PR for this).
Dirk Baeumer 2005-03-24 06:54:23 EST
Markus, was is the state of this bug ?
Markus Keller 2005-03-24 09:37:02 EST
This has been fixed with the new RippleMethodFinder2.
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=63519,63519,P3,JDT,UI,tobias_widmer,RESO,FIXE,"""Move member type to new file"" omits to add imports [refactoring]",2005/3/17,compile error,0,1,nan,Move member type to new file,nan,"Bug 63519 - ""Move member type to new file"" omits to add imports [refactoring]
Pawe&#322; Sakowski 2004-05-22 07:51:51 EDT
Given the following two classes:
---
package foo;

public abstract class Superclass {
    public int i;
    protected class Inner {
        void go() {
        	i = 1;
        }
    }
    public abstract void go(Inner param);
}
---
package bar;

import foo.Superclass;

public class Subclass extends Superclass {
	public void go(Inner param) {}
}
---

extracting Inner to a new file (with default settings) produces non-building
code, because:
- Subclass receives no 'import foo.Inner' (so, Inner can't be resolved)
- Inner is declared as package-visible, not public-visible (so, the import
wouldn't work anyway)

Eclipse 3.0M9
Dirk Baeumer 2005-03-16 18:10:20 EST
Tobias, is this still a problem ?
Tobias Widmer 2005-03-17 06:52:48 EST
Fixed > 20050316
"
https://bugs.eclipse.org/bugs/show_bug.cgi?id=87483,87483,P3,JDT,UI,tobias_widmer,RESO,FIXE,[refactoring] [extract local] wrong auto-added import line while refactor,2005/3/16,compile error,0,1,inner class,extract local variable,nan,"Bug 87483 - [refactoring] [extract local] wrong auto-added import line while refactor
Immanuel Scholz 2005-03-09 06:47:17 EST
Assume the following two files:

file Base.java:
public class Base {
   public class inner {}
}

file Derrived.java:
public class Derrived extends Base {
   public void foo() {
       inner bar = new inner();
   }
}


If I now select the ""new inner()"" and choose refactoring-Extract local variable
(usually Alt-Shift-L), eclipse does not recognize, that inner is already visible
and want to include ""Base.inner"", which fails.

Ciao, Imi.
Frederic Fusier 2005-03-09 09:04:38 EST
Move to JDT/UI
Tobias Widmer 2005-03-16 08:18:13 EST
Fixed > 20050316
"
